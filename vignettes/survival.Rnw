\documentclass{report}[11pt]
\usepackage{Sweave}
\usepackage{amsmath}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-.5in}
\setlength{\evensidemargin}{\oddsidemargin}
%\VignetteIndexEntry{The survival package}

\SweaveOpts{keep.source=TRUE, fig=FALSE}
% Ross Ihaka suggestions
\DefineVerbatimEnvironment{Sinput}{Verbatim} {xleftmargin=2em}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=2em}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}

% I had been putting figures in the figures/ directory, but the standard
%  R build script does not copy it and then R CMD check fails
\SweaveOpts{prefix.string=compete,width=6,height=4}

\newcommand{\myfig}[1]{\includegraphics[height=!, width=\textwidth]
                        {compete-#1.pdf}}

\newcommand{\code}[1]{\texttt{#1}}
\setkeys{Gin}{width=\textwidth}
<<echo=FALSE>>=
options(continue="  ", width=60)
options(SweaveHooks=list(fig=function() par(mar=c(4.1, 4.1, .3, 1.1))))
pdf.options(pointsize=10) #text in graph about the same as regular text
options(contrasts=c("contr.treatment", "contr.poly")) #ensure default
library("survival")
palette(c("#000000", "#D95F02", "#1B9E77", "#7570B3", "#E7298A", "#66A61E"))

# These functions are used in the document, but not discussed until the end
crisk <- function(what, horizontal = TRUE, ...) {
    nstate <- length(what)
    connect <- matrix(0, nstate, nstate,
                      dimnames=list(what, what))
    connect[1,-1] <- 1  # an arrow from state 1 to each of the others
    if (horizontal) statefig(c(1, nstate-1),  connect, ...)
    else statefig(matrix(c(1, nstate-1), ncol=1), connect, ...)
}

state3 <- function(what, horizontal=TRUE, ...) {
    if (length(what) != 3) stop("Should be 3 states")
    connect <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3,3,
                      dimnames=list(what, what))
    if (horizontal) statefig(1:2, connect, ...)
    else statefig(matrix(1:2, ncol=1), connect, ...)
}

state4 <- function() {
    sname <- c("Entry", "CR", "Transplant", "Transplant")
    layout <- cbind(c(1/2, 3/4, 1/4, 3/4),
                    c(5/6, 1/2, 1/2, 1/6))
    connect <- matrix(0,4,4, dimnames=list(sname, sname))
    connect[1, 2:3] <- 1
    connect[2,4] <- 1
    statefig(layout, connect)
}

state5 <- function(what, ...) {
    sname <- c("Entry", "CR", "Tx", "Rel", "Death")
    connect <- matrix(0, 5, 5, dimnames=list(sname, sname))
    connect[1, -1] <- c(1,1,1, 1.4)
    connect[2, 3:5] <- c(1, 1.4, 1)
    connect[3, c(2,4,5)] <- 1
    connect[4, c(3,5)]  <- 1
    statefig(matrix(c(1,3,1)), connect, cex=.8,...)
}
@

\title{The survival package}
\author{Terry Therneau}

\begin{document}
\maketitle

\chapter{Introduction}
\section{History}
Work on the survival package began in 1985 in connection with the analysis
of medical research data, without any realization at the time that the
work would become a package.
Eventually the software was placed on the Statlib repository hosted by
Carnegie Mellon University. 
Multiple version were released in this fashion but I don't have a list of
dates --- version 2 was the first to
make use of the \code{print} method that was introduced in `New S' in 1988,
which places that release somewhere in 1989.
The library was eventually incorportated directly in S-Plus, and from there it
became a standard part of R.

I suspect that 
one of the primary reasons for the package's success is that all of the
functions have been written to solve real analysis questions that arose from
real data sets; theoretical issues were explored when necessary but they 
have never played a leading role.  
As a statistician in a major medical center, the central focus of my department
is to advance medicine; statistics is a tool to that end.
This also highlights one of the deficiencies of the package: if a particular
analysis question has not yet arisen in one of my studies then the survival 
package will also have nothing to say on the topic. 
Luckily there are many other R packages that build on or extend
the survival package, and anyone working in the field (the author included) 
can expect to use more packages than just this one.
The author certainly never foresaw that the library would become as popular 
as it has.

This vignette is an introduction to version 3.x of the survival package. 
We can think of versions 1.x as the S-Plus era and 2.1 -- 2.44 as maturation of
the package in R.
Version 3 had 4 major goals.
\begin{itemize} 
  \item Make multi-state curves and models as easy to use as an ordinary
    Kaplan-Meier and Cox model.
  \item Deeper support for absolute risk estimates.
  \item Consistent use of robust variance estimates.
  \item Clean up various naming inconsistencies that have arisen over time.
\end{itemize}

With over 600 dependent packages in 2019, not counting Bioconductor, other
guiding lights of the change are
\begin{itemize}
  \item We can't do everything (so don't try).
  \item Allow other packages to build on this one.  That means clear 
    documentation of all of the results that are produced, the use of simple
    S3 objects that are easy to manipulate, and setting up many 
    of the routines as a pair.  For example \code{concordance} and 
    \code{concordancefit}; the former is the user front end and the latter does 
    the actual work.  Other package authors might want to access the lower level
    interface, while accepting the penalty of fewer error checks. 
  \item Don't mess it up!
\end{itemize}

This meant preserving the current argument names as much as possible.
Appendix \ref{sect:changes} summarizes changes that were made which are not
backwards compatable.

The two other major changes are to collapse many of vignettes into this single
large one, and the parallel creation of an actual book.  
We've recognized that the package needs more than a vignette.  
With the book's appearance this vignette can also
be more brief, essentially leaving out a lot of the theory.

Version 3 will not appear all at once, however; it will take some time to get 
all of the documentation sorted out in the way that we like.

\section{Survival data}
The survival package is concerned with time-to-event analysis.
Such outcomes arise very often in the analysis of medical data:
time from chemotherapy to tumor recurrence, the durability of a joint
replacement, recurrent lung infections in subjects with cystic fibrosis,
the appearance of hypertension, hyperlipidemia and other comorbidities 
of age, and of course death itself, from which the overall label of
``survival'' analysis derives.  
A key principle of all such studies is that ``it takes time to observe
time'', which in turn leads to two of the primary challenges.
\begin{enumerate}
  \item Incomplete information.  At the time of an analysis, not everyone
    will have yet had the event.  This is a form of partial information
    known as \emph{censoring}: if a particular subject was enrolled in a
    study 2 years ago, and has not yet had an event at the time of
    analysis, we only know that their time to event is $>2$ years.
  \item Dated results.  In order to report 5 year survival, say, from a 
    treatment, patients need to be enrolled and then followed for 5+ years.
    By the time recruitment and follow-up is finished, analysis done, 
    the report finally published the treatment in question might be 8
    years old and considered to be out of date.  This leads to a tension
    between early reporting and long term outcomes.
\end{enumerate}

<<states, fig=TRUE>>=
oldpar <- par(mar=c(.1, .1, .1, .1), mfrow=c(2,2))
sname1 <- c("Alive", "Dead")
cmat1 <- matrix(c(0,0,1,0), nrow=2, 
                dimnames=list(sname1, sname1))
statefig(c(1,1), cmat1)

sname2 <- c("0", "1", "2", "...")
cmat2 <- matrix(0, 4,4, dimnames= list(sname2, sname2))
cmat2[1,2] <- cmat2[2,3] <- cmat2[3,4] <- 1
statefig(c(1,1,1,1), cmat2, bcol=c(1,1,1,0))

sname3 <- c("Entry", "Transplant", "Withdrawal", "Death")
cmat3 <- matrix(0, 4,4, dimnames=list(sname3, sname3))
cmat3[1, -1] <- 1
statefig(c(1,3), cmat3)

sname4 <- c("Health", "Illness", "Death")
cmat4 <- matrix(0, 3, 3, dimnames = list(sname4, sname4))
cmat4[1,2] <- cmat4[2,1] <- cmat4[-3, 3] <- 1
statefig(c(1,2), cmat4, offset=.03)

par(oldpar)
@

Survival data is often represented as
a pair $(t_i, \delta_i)$ where $t$ is the time until endpoint or last
follow-up, and $\delta$ is a 0/1 variable with 0= ``subject was censored at
$t$'' and 1 =``subject had an event at $t$'',
or in R code as \code{Surv(time, status)}.  
The status variable can be logical, e.g., \code{vtype=='death'} where 
\code{vtype} is the variable ``visit type''.  
An alternate view is to think of time to event data as a multi-state process
as is shown in the above figure. 
The upper left panel is simple survival with two states of alive and dead,
``classic'' survival analysis.
The other three panels show repeated events of the same type (upper right)
competing risks for subjects on a liver transplant waiting list(lower left) 
and the illness-death model (lower right).
In this approach interest normally centers on the transition rates or hazards
(arrows) from state to state (box to box).
For simple survival the two viewpoints are equivalent, and we will move
freely between them, i.e., use whichever viewpoint is handy at the moment,
either ``time to event'' or ``rate of events''.  
When there more than one transition the rate approach is particularly useful.

The figure also displays a 2 by 2 division of survival data sets, one that
will be used to organize many subsections of this document.
A: one event type (top row) versus multiple types of events 
(bottom row), and  B: one endpoint per subject (left column) versus multiple
events per subject (right column). 
The upper left is simple or ``classic'' survival while the lower right is
the most complex.

\chapter{Survival and cumulative hazard curves}
\section{Simple curves}
\index{function!survfit}%
\index{survival curves!one event}
The most common depiction of survival data is the Kaplan-Meier curve,
which is created with the \code{survfit} function.
The left-hand side of the formula will be a Surv object and the right hand
side contains one or more categorical variables that will divide the 
observations into groups.  For a single curve use \code{\textasciitilde 1}
as the right hand side.

<<survfit1>>=
fit1 <- survfit(Surv(time, status) ~ sex, data=lung)
print(fit1, rmean= 913)

summary(fit1, times= (0:4)*182.5)
@ 

The default printout is very brief, only one line per curve, showing the
number of observations, number of events, median survival, and
optionally the restricted mean survival time (RMST) in each of
the groups.  In the above case we used the value at 2.5 years = 913 days
as the upper threshold for the RMST, the value of 453 for females 
represents an average survival for 453 or the next 913 days after enrollment
in the study.
The summary function gives a more complete description of the curve,
in this case we chose to show the values every 6 months for the first two years.

Arguments for the survfit function include the usual
\code{data}, \code{weights}, \code{subset} and \code{na.action} 
arguments common to modeling formulas.
A further set of arguments have to do with standard errors and confidence
intervals, defaults are shown in parenthesis.
\begin{itemize}
  \item se.fit (TRUE): compute a standard error of the estimates.  
    In a few rare circumstances omitting the standard error  can save 
    computation time.
  \item conf.int (.95): the level of confidence interval, or FALSE if
    intervals are not desired.
  \item conf.type ('log'): transformation to be used in computing the
    confidence intervals. 
  \item conf.lower ('ususal'): optional modification of the lower interval.
\end{itemize}

\index{survfit!confidence intervals}
For the default \code{conf.type} the confidence intervals are computed as
$$
   e^{\log(p) \pm 1.96 {\rm se}(\log(p))}
$$
rather than the direct formula of $p \pm 1.96 {\rm(se)}(p)$, where 
$p = S(t)$ is the survival probability.
Many authors have investigated the behavior of transformed intervals, and a 
general conclusion is that the direct intervals do not behave well, particularly
near 0 and 1, while all the others are acceptable. 
Which of the choices of log, log-log, or logit is ``best'' depends on the 
details of the simulation study.
(The default corresponds to the most recent paper the author had read, at
the time the default was chosen; a current meta review might give a slight edge
to log-log option.)

The \code{conf.lower} option is mostly used for graphs.  If a study has a 
long string of censored observations, it is intuitive that the precision
of the estimated survival must be decreasing due to a smaller sample size,
but the formal standard error will not change until the next death.
This option widens the confidence interval between death times, proportional
to the number at risk, giving a visual clue of the decrease in $n$.
There is only a small (and decreasing) population of users who make use of this.

\index{function!plot.survfit}
The most common use of survival curves is to plot them, as shown below.
<<survfit2, fig=TRUE>>=
plot(fit1, col=2:1, xscale=365.25, lwd=2, conf.times=c(.5, 1, 1.5, 2)*365,  
     xlab="Years since study entry", ylab="Survival")
legend(730, .8, c("Female", "Male"), col=1:2, lwd=2, bty='n')
@ 

Curves will appear in the plot in the same order as they are listed by 
\code{print}; this is a quick way to remind ourselves of which subset maps
to each color or linetype in the graph.
Curves can also be labeled using the \code{pch} option to place marks on 
the curves.
The location of the marks is controlled by the \code{mark.time} option
which has a default value of FALSE (no marks).  A vector of numeric values
specifies the location of the marks, optionally a value of 
\code{mark.time=TRUE} will cause a 
mark to appear at each censoring time; this can result in far too many marks
if $n$ is large, however.
By default confidence intervals are included on the plot of there is a single
curve, and omitted if there is more than one curve.  

The result of a \code{survfit} call can be subscripted.  This is useful
when one wants to plot only a subset of the curves.
\index{survfit!subscript}
<<survfit3, fig=TRUE>>=
fit2 <- survfit(Surv(time, status) ~  sex + ph.ecog, data=lung)
fit2
plot(fit2[1:3], lty=1:3, lwd=2, xscale=365.25,
       xlab="Years after enrollment", ylab="Survival")
legend(550, .8, paste("Performance Score", 0:2, sep=' ='), 
       lty=1:3, lwd=2, bty='n')
text(400, .95, "Males", cex=2)
@ 

\section{Repeated events}
\index{survival curves!repeated events}
Repeated events of the same type is quite common in industrial reliability
data.
As an example consider a data set on the replacement times of
diesel engine valve seats.
The simple data set \code{valveSeats} contains an engine identifier, time, and
a status of 1 for a replacement and 0 for the end of the inspection interval
for that engine; sorted by time within engine.
To accomodate multiple events per subject each row needs to span a unique
time interval $(t1, t2]$, we do this by adding a new variable to the data
set.
Intervals of 0 are illegal for \code{Surv} objects.  There are 3 engines that
had 2 valves repaired on the same day, which will create such an interval.
To work around this so move the first repair back
in time by a tiny amount.  

<<survival4>>=
vdata <- valveSeat
first <- !duplicated(vdata$id)
vdata$t0 <- ifelse(first, 0,  c(0, vdata$time[-nrow(vdata)]))
double <- which(vdata$t0 == vdata$time)
vdata$time[double-1] <- vdata$t0[double] <- vdata$t0[double] -.01
vdata[1:7, c("id", "t0", "time", "status")]
survcheck(Surv(t0, time, status) ~ 1, id=id, data=vdata)
@ 

Creation of (start time, end time) intervals is a common data manipulation 
tasks when there are multiple events per subject. 
A later chapter will discuss the \code{tmerge} function, which is very often
useful for this task. 
The \emph{survcheck} function can be used as check for some of more common
errors that arise in creation, 
it aslo will be covered in more detail in a later section.
(The output will be also be less cryptic for later cases, where the states 
have been labeled.) 
In the above data the engines could only participate in 2 kinds of transitions:
from an unnamed initial state to a repair, (s0) $\rightarrow$ 1, or from one
repair to another one, 1 $\rightarrow$ 1, or reach end of follow-up.
The second table printed by \code{survcheck} tells us the 17 engines had 0
transitions to state 1, i.e., no valve repairs before the end of observation
for that engine, 9 had 1 repair, etc.
Perhaps the most important output is that the routine did not print any 
warnings about suspicious data.

We can now compute the survival estimate.  When there are multiple observations
per subject the \code{id} statement is necessary.
(It is a good idea if there \emph{could} be multiples, even if there are none,
as it lets the underlying routines check for doubles.)

<<survival5, fig=TRUE>>=
vfit <- survfit(Surv(t0, time, status) ~1, data=vdata, id=id)
plot(vfit, cumhaz=TRUE, xlab="Days", ylab="Cumulative hazard")
@ 

By default, the \code{survfit} routine computes both the survival and
the cumulative hazard functions,
to plot the cumulative hazard portion the \code{cumhaz} argument of
\code{survfit} is used.
\index{cumulative hazard function}%
\index{mean cumulative function|see cumulative hazard function}  
In multi-event data, the cumulative hazard is an estimate of the expected
\emph{number} of events for a unit that has been observed for the 
given amount of time, whereas the survival $S$ estimates the probability that
a unit has had 0 repairs.
The cumulative hazard is often the more natural quantity to plot in such 
studies; in reliability analysis it is also known as the 
\emph{mean cumulative function}.  
The estimate is also important in multi-state models.

\section{Competing risks}
In the classic case \code{status} is either a logical or 0/1 numeric variable
that represents censoring (0 or false) or an event (1 or true),
and the result is a survival curve for each group.
If \code{status} is a factor, however, the result is a multi-state
estimate.
In this case the first level of \code{status} is used to code censoring while
the remaining ones are possible states.
For competing risks data each subject has a most one transition, but there
are multiple transition types.

\subsection{Simple example}
Here is a simple competing risks example where the three endpoints are
labeled as a, b and c.
<<simple1>>=
crdata <- data.frame(time= c(1:8, 6:8),
                     endpoint=factor(c(1,1,2,0,1,1,3,0,2,3,0),
                                     labels=c("censor", "a", "b", "c")),
                     cstate=rep("entry", 11),
                     id= LETTERS[1:11])
tfit  <- survfit(Surv(time, endpoint) ~ 1, data=crdata, id=id, istate=cstate)
dim(tfit)
summary(tfit)
@
The resulting object \code{tfit} contains an estimate of $P$(state),
the probability of being in each state at each time $t$.
$P$ is a matrix with one row for each time and one column for
each of the four states a--c and ``still in the starting state''.
By definition each row of $P$ sums to 1. 
We will also use the notation $p(t)$ where $p$ is a vector with one element
per state and $p_j(t)$ is the fraction in state $j$ at time $t$.
The plot below shows all 4 curves.
(Since they sum to 1 one of the 4 curves is redundant, often the entry state
is omitted since it is the least interesting.)
<<fig=TRUE>>=
plot(tfit, col=1:4, lty=1:4, lwd=2, ylab="Probability in state")
@ 

The resulting \code{survfms} object appears as a matrix and can be
subscripted as such, with a column for each state and rows for each
group corresponding to variables on the right hand side of the formula.
This makes it simple to display a subset of the curves using plot
or lines commands.
The entry state in the above fit, for instance, can be displayed with
\code{plot(tfit[,1])}.

The curves are computed using the Aalen-Johansen estimator. 
This is an important concept, and so we work it out below.

1. The starting point is the column vector
      $p(0) = (1, 0, 0, 0)$, everyone starts in the first state.
    
2. At time 1, the first event time, form the 4 by 4 transtion matrix $T_1$
\begin{align*}
 T(1)  &= \left( \begin{array}{cccc}
             10/11 & 1/11 & 0/11 & 0/11 \\
              0    & 1    &  0   & 0    \\
              0    & 0    &  1   & 0    \\
              0    & 0    &  0   & 1 \end{array} \right )
 p(1) &= p(0)T_1
 \end{align*}

The first row of $T(1)$ desribes the disposition of everyone who is 
in state 1 and under observation at time 1: 10/11 stay in state 1 and 
1 subject transtions to state a.  
There is no one in the other 3 states, so rows 2--4 are technically
undefined; use a default ``stay in the same state'' row which has 1 on
the diagonal.
(Since no one ever leaves states a, b, or c, the bottom three rows of $T$ will 
continue to have this form.)

3. At time 2 the first row will be (9/10, 0, 1/10, 0), and
$p(2) = p(1)T(2) = p(0) T(1) T(2)$.

Continue this until the last event time.  
At a time point with only censoring, such as time 4, $T$ would be the identity
matrix.  

It is straightforward to show that when there are only two states of
alive -> dead, then $p_1(t)$ from the Aalen-Johansen estimate replicates 
the Kaplan-Meier computation.  
For competing risks data such as the simple example above, $p(t)$ replicates
the cumulative incidence (CI) estimator.
The KM and CI are both special cases.  
The AJ is more general, however; a given subject can have multiple 
transitions from state to state, including transitions to a state that was 
visited earlier.


\subsection{Monoclonal gammopathy}
\label{mgusplot}
The \code{mgus2} data set contains information of 1384 subjects who were
who were found to have a particular pattern on a laboratory test
(monoclongal gammopathy of undertermined significance or MGUS).
The genesis of the study was a suspicion that such a result might indicate a
predisposition to plasma cell malignancies such a multiple myeloma;
subjects were followed forward to assess whether an excess did occur.
The mean age at diagnosis is 63 years, so death from other causes will be
an important competing risk.
Here are a few observations of the data set, one of which experienced
progression to a plasma cell malignancy.
<<mgus1>>=
mgus2[55:59, -(4:7)]
@ 

To generate competing risk curves create a new (etime, event) pair.

<<mgus2, fig=TRUE>>=
event <- with(mgus2, ifelse(pstat==1, 1, 2*death))
event <- factor(event, 0:2, c("censored", "progression", "death"))
etime <- with(mgus2, ifelse(pstat==1, ptime, futime))
crfit <- survfit(Surv(etime, event) ~ sex, mgus2)
crfit

plot(crfit, col=1:2, lty=c(3,3,2,2,1,1), noplot="", xscale=12,
     xlab="Years post diagnsis", ylab="P(state)")
legend(240, .65, c("Female, death", "Male, death", "malignancy", "(s0)"),
       lty=c(1,1,2,3), col=c(1,2,1,1), bty='n')
@ 

There are 3 curves for females, one for each of the three states, and
3 for males. 
The three curves sum to 1 at any given time (everyone has to be somewhere),
and the default action for \code{plot.survfit} is to leave out the
``still in original state'' curve (s0) since it is usually the least
interesting, but in this case we have shown all 3.
We will return to this example when exploring models.

A common mistake with competing risks is to use the Kaplan-Meier
separately on each
event type while treating other event types as censored.
The next plot is an example of this for the PCM endpoint.
<<mgus3, fig=TRUE>>=
pcmbad <- survfit(Surv(etime, pstat) ~ sex, data=mgus2)
plot(pcmbad[2], mark.time=FALSE, lwd=2, fun="event", conf.int=FALSE, xscale=12,
     xlab="Years post diagnosis", ylab="Fraction with PCM")
lines(crfit[2,"progression"], lty=2, lwd=2, mark.time=FALSE, conf.int=FALSE)
legend(0, .25, c("Males, PCM, incorrect curve", "Males, PCM, competing risk"),
       col=1, lwd=2, lty=c(1,2), bty='n')
@ 

There are two problems with the \code{pcmbad} fit.  
The first is that it attempts to estimate the expected occurrence of
plasma cell malignancy (PCM)
if all other causes of death were to be disallowed.
In this hypothetical world it is indeed true that many more subjects would
progress to PCM (the incorrect curve is higher), but it is also 
not a world that any of us will ever inhabit.
This author views the result in much the same light as discussions of
survival after the zombie apocalypse.
The second problem is that the computation for this
hypothetical case is only correct if all of the competing endpoints
are independent, a situation which is almost never true.
We thus have an unreliable estimate of an uninteresting quantity.
The competing risks curve, on the other hand,
estimates the fraction of MGUS subjects who \emph{will experience} 
PCM, a quantity sometimes known as the lifetime risk,
and one which is actually observable.

The last example chose to plot only a subset of the curves, something that is
often desirable in competing risks problems to avoid a
``tangle of yarn'' plot that simply has too many elements.
This is done by subscripting the \code{survfit} object.
For subscripting, multi-state curves behave as a matrix
with the outcomes as the second subscript. 
The columns are in order of the levels of \code{event},
i.e., as displayed by our earlier call to \code{table(event)}.   
The first subscript indexes the groups formed by the right hand side of
the model formula, and will be in the same order as simple survival curves.
Thus \code{mfit2[2,1]} corresponds to males (2) and the PCM endpoint (1).
Curves are listed and plotted in the usual matrix order of R.

One surprising aspect of multi-state data is that hazards can be estimated
independently, while probabilities can not.
If you look at the cumulative hazard estimate from the \code{pcmbad}
fit above using for instance \code{plot(pcmbac, cumhaz=TRUE)} you will
find that it is identical to the estimate from the joint fit.
This is an important issue in Cox models.  

\section{Multi-state data}
The most general multi-state data will have multiple outcomes and
multiple endponts per subject.
In this case we will need to use (time1, time2) form for each subject.
The dataset structure is similar to that for time varying
covariates in a Cox model: the time variable will be intervals $(t_1, t_2]$
which are open on the left and closed on the right,
and a given subject will have multiple lines of data.
But instead of covariates changing from line to line, in this
case the status variable changes; it
contains the state that was entered at time $t_2$.
There are a few restrictions.
\begin{itemize} 
  \item An identifier variable is needed to indicate which rows of the
    data frame belong to each subject.  If the \code{id} argument is missing
    the code assumes that each row of data is a separate subject, which leads
    to a nonsense estimate when there are actually multiple rows for anyone. 
  \item Subjects do not have to enter at time 0 or all at the same time,
    but each must traverse a connected segment of time.  Disjoint intervals
    such as the pair $(0,5]$, $(8, 10]$ are illegal.
   \item A subject cannot change groups.  Any covariates on the right hand
     side of the formula must remain constant within subject.  (This 
     function is not
     a way to creat supposed `time-dependent' survival curves.)
   \item Subjects may have case weights, and these weights may change over
     time for a subject.
\end{itemize}

The \code{istate} argument can be used to designate a subject's state 
at the start of each $t_1, t_2$ time interval.
Like variables in the formula it is searched for in the
\code{data} argument.
If it is not present
every subject is assumed to start in a common entry state which is given
the name ``(s0)''.  The parenthesis are an echo of ``(Intercept)'' in a
linear model and show a label that was provided by the program rather than
the data.
The distribution of states just prior to the first event time is 
treated as the initial distribution of states.
In common with ordinary survival any observation which is censored before the 
first event time has no impact on the results.


\subsection{Myeloid data}
The \code{myeloid} data set contains data from a clinical trial
in subjects with  acute myeloid leukemia.  To protect patient confidentiality
the data set in the survival package has slightly perturbed, but 
results are essentially unchanged.
In this comparison of two conditioning regimens the
canonical path for a subject is initial therapy $\rightarrow$
complete response (CR) $\rightarrow$
hematologic stem cell transplant (HSCT) $\rightarrow$
sustained remission, followed by relapse or death.
Not everyone follows this ideal path, of course.

<<overall>>=
myeloid[1:5,]
@ 
The first few rows of data are shown above.
The data set contains the follow-up time and status at last follow-up 
for each subject, along with the time to transplant
(txtime),
complete response (crtime) or relapse after CR (rltime).
Subject 1 did not receive a transplant, as shown by the NA value,
and subject 2 did not achieve CR.

\begin{figure}
  \myfig{sfit0}
  \caption{Overall survival curves for the two treatments.}
  \label{sfit0}
\end{figure}

Overall survival curves for the data are shown in figure \ref{sfit0}.
The difference between the treatment arms A and B
is substantial.  A goal of this analysis is to better 
understand this difference.  Code to generate the 
two curves is below.

<<sfit0, echo=TRUE, fig=TRUE, include=FALSE>>=
sfit0 <- survfit(Surv(futime, death) ~ trt, myeloid)
plot(sfit0, xscale=365.25, xaxs='r', col=1:2, lwd=2,
     xlab="Years post enrollment", ylab="Survival")
legend(20, .4, c("Arm A", "Arm B"),
       col=1:2, lwd=2, bty='n')
@ 

The full multi-state data set can be created with the 
\code{tmerge} routine.
<<sfit0a, echo=TRUE>>=
mdata <- tmerge(myeloid[,1:2], myeloid,  id=id,  death= event(futime, death),
                sct = event(txtime), cr = event(crtime), 
                relapse = event(rltime))
temp <- with(mdata, cr + 2*sct  + 4*relapse + 8*death)
table(temp)
@ 

Our check shows that there is one subject who had CR and stem cell transplant
on the same day (temp=3).
To avoid length 0 intervals we break the tie so that complete response (CR)
happens first.
(Students may be surprised to see anomalies like this, since they never appear
in textbook data.  In real data such issues always appear.)

<<sfit0b, echo=TRUE>>=
tdata <- myeloid
tied <- with(tdata, (!is.na(crtime) & !is.na(txtime) & crtime==txtime))
tdata$crtime[tied] <- tdata$crtime[tied] -1
mdata <- tmerge(tdata[,1:2], tdata,  id=id,  death= event(futime, death),
                sct = event(txtime), cr = event(crtime), 
                relapse = event(rltime),
                priorcr = tdc(crtime), priortx = tdc(txtime))
temp <- with(mdata, cr + 2*sct  + 4*relapse + 8*death)
table(temp)
mdata$event <- factor(temp, c(0,1,2,4,8),
                       c("none", "CR", "SCT", "relapse", "death"))

mdata[1:7, c("id", "trt", "tstart", "tstop", "event", "priorcr", "priortx")]
@ 

Subject 1 has a CR on day 44, relapse on day 113, death on day 235 and
did not receive a stem cell transplant. 
The data for the first three subjects looks good.  
Check it out a little more thoroughly.

<<>>=
survcheck(Surv(tstart, tstop, event) ~1, mdata, id=id)
@ 

The second table shows that no single subject had more than one CR, SCT,
relapse, or death, which is the intention.  Several subjects visited all
four intermediate states.  
The transitions table shows 11 subject who achieved CR \emph{after} stem
cell transplant and another 106 who received a transplant before
achieving CR, both of which are deviations from the ``ideal'' pathway.
No subjects went from death to another state (which is good).

For investigating the data we would like to add a set of alternate endpoints.
\begin{enumerate}
  \item The competing risk of CR and death, ignoring other states.  This
    is used to estimate the fraction who ever acheive a complete response.
  \item The competing risk of SCT and death, ignoring other states.
  \item An endpoint that distinguished death after SCT from death 
    before SCT.
\end{enumerate}
Each of these can be accomplised by adding further outcome variables to 
the data set, we will not need to change the time intervals.

<<newevent>>=
levels(mdata$event)
temp1        <- with(mdata, ifelse(priorcr, 0, c(0,1,0,0,2)[event]))
mdata$crstat <- factor(temp1, 0:2, c("none", "CR", "death"))

temp2        <- with(mdata, ifelse(priortx, 0, c(0,0,1,0,2)[event]))
mdata$txstat <- factor(temp2, 0:2, c("censor", "SCT", "death"))

temp3     <- with(mdata, c(0,0,1,0,2)[event] + priortx)
mdata$tx2 <- factor(temp3, 0:3,
                    c("censor", "SCT", "death w/o SCT", "death after SCT"))
@ 

Notice the use of the \code{priorcr} variable in defining \code{crstat}.
This outcome variable treats complete response as a terminal state,
which in turn means that no further transtiontions are allowed after
reaching CR.  

\begin{figure}
  \myfig{curve1}
  \caption{Overall survival curves: time to death, to transplant (Tx), 
    and to complete response (CR).
    Each shows the estimated fraction of subjects who have ever reached the
    given state.  The vertical line at 2 months is for reference.
    The curves were limited to the first 48 months to more clearly show 
    early events. The right hand panel shows the state-space model for each
  pair of curves.}
  \label{curve1}
\end{figure}

This data set is the basis for our first set of curves, which are shown in
figure \ref{curve1}.
The plot overlays three separate \code{survfit} calls: standard survival
until death, complete response with death as a competing risk, and
transplant with death as a competing risk.
For each fit we have shown one selected state: the fraction
who have died, fraction ever in CR, and fraction ever to receive transplant,
respectively.
Most of the CR events happen before 2 months (the green
vertical line) and nearly all the additional CRs
conferred by treatment B occur between months 2 and 8.  
Most transplants happen after 2 months, which is consistent with the
clinical guide of transplant after CR.
The survival advantage for treatment B begins between 4 and 6 months, 
which argues that it could be at least partially a consequence of the
additional CR events.

The code to draw figure \ref{curve1} is below.  It can be separated into
5 parts:
\begin{enumerate}
  \item Fits for the 3 endpoints are simple and found in the first set of lines.
    The \code{crstat} and \code{txstat} variables are factors, which causes
    multi-state curves to be generated.
  \item The \code{layout} and \code{par} commands are used to create a
    multi-part plot with curves on the left and state space diagrams on 
    the right, and to reduce the amount of white space between them.
  \item Draw a subset of the curves via subscripting. A multi-state
    survfit object appears to the user as a matrix of curves, with one row for
    each group (treatment) and one column for each state.  The CR state is
    the second column in \code{sfit2}, for instance.  
    The CR fit was drawn first simply because it has the greatest y-axis
    range, then the other curves added using the lines command.
  \item Decoration of the plots. This includes the line types, colors,
    legend, choice of x-axis labels, etc.
  \item Add the state space diagrams.  The functions for this are
    described elsewhere in the vignette.
\end{enumerate}

<<curve1, fig=TRUE, include=FALSE>>=
# I want to have the plots in months, it is simpler to fix time
#  once rather than repeat xscale many times
tdata$futime <- tdata$futime * 12 /365.25
mdata$tstart <- mdata$tstart * 12 /365.25
mdata$tstop  <- mdata$tstop * 12 /365.25


sfit1 <- survfit(Surv(futime, death)  ~ trt, tdata) # survival
sfit2 <- survfit(Surv(tstart, tstop, crstat) ~ trt, 
                 data= mdata, id = id) # CR
sfit3 <- survfit(Surv(tstart, tstop, txstat) ~ trt, 
                 data= mdata, id =id) # SCT

layout(matrix(c(1,1,1,2,3,4), 3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))

mlim   <- c(0, 48) # and only show the first 4 years
plot(sfit2[,"CR"], xlim=mlim, 
         lty=3, lwd=2, col=1:2, xaxt='n',
     xlab="Months post enrollment", ylab="Fraction with the endpoint")
lines(sfit1, mark.time=FALSE, xlim=mlim,
      fun='event', col=1:2, lwd=2)

lines(sfit3[,"SCT"], xlim=mlim, col=1:2, 
          lty=2, lwd=2)

xtime <- c(0, 6, 12, 24, 36, 48)
axis(1, xtime, xtime) #axis marks every year rather than 10 months
temp <- outer(c("A", "B"), c("CR", "transplant", "death"),  paste)
temp[7] <- ""
legend(25, .3, temp[c(1,2,7,3,4,7,5,6,7)], lty=c(3,3,3, 2,2,2 ,1,1,1),
       col=c(1,2,0), bty='n', lwd=2)
abline(v=2, lty=2, col=3)

# add the state space diagrams
par(mar=c(4,.1,1,1))
crisk(c("Entry", "CR", "Death"), alty=3)
crisk(c("Entry", "Tx", "Death"), alty=2)
crisk(c("Entry","Death"))
par(oldpar)
layout(1)
@ 

The association between a particular curve and its corresponding state space
diagram is critical.  As we will see below, many different models are
possible and it is easy to get confused.  
Attachment of a diagram directly to each curve, as was done above,
will not necessarily be day-to-day practice, but the state space should
always be foremost.  If nothing else,  draw it on a scrap of paper and tape it 
to the side of the terminal when creating a data set and plots.

\begin{figure}
  \myfig{badfit}
 \caption{Correct (solid) and invalid (dashed) estimates of the number
  of subjects transplanted.}
 \label{badfit}
\end{figure}
 
Figure \ref{badfit} shows the transplant curves overlaid with the naive KM that
censors subjects at death.  There is no difference in the initial portion as
no deaths have yet intervened, but the final portion overstates the 
transplant outcome by more than 10\%. 
\begin{enumerate}
  \item The key problem with the naive estimate is that subjects who die can 
    never have a transplant.  The result of censoring them 
    is an estimate of the ``fraction who would
    be transplanted, if death before transplant were abolished''.  This is not
    a real world quantity.
  \item In order to estimate this fictional quantity one needs to assume that
    death is uninformative with respect to future disease progression.  The
    early deaths in months 0--2, before transplant begins, are however a very
    different class of patient.  Non-informative censoring is untenable.
\end{enumerate}
We are left with an unreliable estimate of an uninteresting quantity.
Mislabeling any true state as censoring is always a mistake, one that 
will not be repeated here.
Here is the code for figure \ref{badfit}.  The use of a logical (true/false)
as the status variable in the \code{Surv} call leads to ordinary survival
calculations.
<<badfit, fig=TRUE, include=FALSE>>=
badfit <- survfit(Surv(tstart, tstop, event=="SCT") ~ trt, 
                       id=id, mdata, subset=(priortx==0))

layout(matrix(c(1,1,1,2,3,4), 3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))
plot(badfit, fun="event", xmax=48, xaxt='n', col=1:2, lty=2, lwd=2,
     xlab="Months from enrollment", ylab="P(state)")
axis(1, xtime, xtime)
lines(sfit3[,2], xmax=48, col=1:2, lwd=2)
legend(24, .3, c("Arm A", "Arm B"), lty=1, lwd=2,
       col=1:2, bty='n', cex=1.2)

par(mar=c(4,.1,1,1))
crisk(c("Entry", "transplant"), alty=2, cex=1.2)
crisk(c("Entry","transplant", "Death"), cex=1.2)
par(oldpar)
layout(1)
@ 

\begin{figure}
  \myfig{cr2}
  \caption{Models for `ever in CR' and `currently in CR';
    the only difference is an additional transition.
    Both models ignore transplant.}
  \label{cr2}
\end{figure}

Complete response is a goal of the initial therapy; figure \ref{cr2}
looks more closely at this.
As was noted before arm B has an increased number of late responses.
The duration of response is also increased: 
the solid curves show the number of subjects still in response, and
we see that they spread farther apart than the dotted ``ever in response''
curves. 
The figure shows only the first eight months in order to better visualize
the details, but continuing the curves out to 48 months reveals a similar
pattern.
Here is the code to create the figure.

<<cr2, fig=TRUE, include=FALSE>>=
cr2 <- mdata$event
cr2[cr2=="SCT"] <- "none" # ignore transplants
crsurv <- survfit(Surv(tstart, tstop, cr2) ~ trt,
                  data= mdata, id=id, influence=TRUE)

layout(matrix(c(1,1,2,3), 2,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))
plot(sfit2[,2], lty=3, lwd=2, col=1:2, xmax=12, 
     xlab="Months", ylab="CR")
lines(crsurv[,2], lty=1, lwd=2, col=1:2)
par(mar=c(4, .1, 1, 1))
crisk( c("Entry","CR", "Death"), alty=3)
state3(c("Entry", "CR", "Death/Relapse"))

par(oldpar)
layout(1)
@ 

The above code created yet another event
variable so as to ignore transitions to the transplant state.
They become a non-event, in the same way that extra lines with
a status of zero are used to create time-dependent covariates for
a Cox model fit.

The \code{survfit} call above included the \code{influence=TRUE}
argument, which causes the influence array to be calculated and
returned.  
It contains, for each subject, that subject's influence on the
time by state matrix of results and allows for calculation of the
standard error of the restricted mean.  We will return to this
in a later section.
<<cr2b>>=
print(crsurv, rmean=48, digits=2)
@ 
<<cr2c, echo=FALSE>>=
temp <- summary(crsurv, rmean=48)$table
delta <- round(temp[4,3] - temp[3,3], 2)
@ 

@ 
The restricted mean time in the CR state is extended by 
\Sexpr{round(temp[4,3], 1)} - \Sexpr{round(temp[3,3], 1)} =
\Sexpr{delta} months.  
A question which immediately gets asked is whether this difference
is ``significant'', to which there are two answers. 
The first and more important is to ask whether 5 months is an important gain
from either a clinical or patient perspective. 
The overall restricted mean survival for the study is approximately
30 of the first 48 months post entry (use print(sfit1, rmean=48));
on this backdrop an extra 5 months in CR might or might not be an
meaningful advantage from a patient's point of view.
The less important answer is to test whether the apparent gain is sufficiently
rare from a mathematical point of view, i.e., ``statistical'' significance.
The standard errors of the two values are
\Sexpr{round(temp[3,4],1)} and \Sexpr{round(temp[4,4],1)},
and since they are based
on disjoint subjects the values are independent, leading to a standard error
for the difference of $\sqrt{1.1^2 + 1.2^2} = 1.6$.
The 5 month difference is over 3 standard errors.

\begin{figure}
  \myfig{txsurv}
  \caption{Transplant status of the subjects, broken down by whether it
    occurred before or after CR.}
  \label{txsurv}
\end{figure}

In summary
  \begin{itemize}
    \item Arm B adds late complete responses (about 4\%); there are 
      212/310 in arm B vs. 244/338 in arm B.
    \item The difference in 4 year survival is about 6\%.
    \item There is approximately 2 months longer average duration of CR (of 48).
  \end{itemize}

CR $\rightarrow$ transplant is the target treatment path for a
patient; given the improvements listed above
why does figure \ref{curve1} show no change in the number transplanted?
Figure \ref{txsurv} shows the transplants broken down by whether this
happened before or after complete response.
Most of the non-CR transplants happen by 10 months.
One possible explanation is that once it is apparent to the
patient/physician pair that CR is not going to occur, they proceed forward with
other treatment options.  
The extra CR events on arm B, which occur between 2 and 8 months, lead to 
a consequent increase in transplant as well, but at a later time of 12--24 
months: for a subject in CR we can perhaps afford to defer the transplant date.

Computation is again based on a manipulation of the event variable: in this
case dividing the transplant state into two sub-states based on the presence
of a prior CR.  The code makes use of the time-dependent covariate 
\code{priorcr}.
(Because of scheduling constraints within a hospital it is unlikely that
a CR that is within a few days prior to transplant could have effected the
decision to schedule a transplant, however.  An alternate breakdown that
might be useful would be ``transplant without CR or within 7 days after CR''
versus those that are more than a week later. 
There are many sensible questions that can be asked.)

<<txsurv, fig=TRUE, include=FALSE>>=
event2 <- with(mdata, ifelse(event=="transplant" & priorcr==1, 6,
               as.numeric(event)))
event2 <- factor(event2, 1:6, c(levels(mdata$event), "tx after CR"))
txsurv <- survfit(Surv(tstart, tstop, event2) ~ trt, mdata, id=id,
                  subset=(priortx ==0))

layout(matrix(c(1,1,1,2,2,0),3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1,.1))
plot(txsurv[,c(3,5)], col=1:2, lty=c(1,1,2,2), lwd=2, xmax=48,
     xaxt='n', xlab="Months", ylab="Transplanted")
axis(1, xtime, xtime)
legend(15, .13, c("A, transplant without CR", "B, transplant without CR",
                 "A, transplant after CR", "B, transplant after CR"),
       col=1:2, lty=c(1,1,2,2), lwd=2, bty='n')
state4()  # add the state figure
par(oldpar)
@ 

\begin{figure}
  \myfig{sfit4}
  \caption{The full multi-state curves for the two treatment arms.}
  \label{sfit4}
\end{figure}

Figure \ref{sfit4} shows the full set of state occupancy probabilities for the
cohort over the first 4 years.  At each point in time the curves
estimate the fraction of subjects currently in that state.
 The total who are in the transplant state peaks at
about 9 months and then decreases as subjects relapse or die; 
the curve rises
whenever someone receives a transplant and goes down whenever someone
leaves the state.
At 36 months treatment arm B (dashed) has a lower fraction who have died,
the survivors are about evenly split between those who have received a
transplant and those whose last state is a complete response
(only a few of the latter are post transplant). 
The fraction currently in relapse -- a transient state -- is about 5\% for
each arm.
The figure omits the curve for ``still in the entry state''.
The reason is that 
at any point in time the sum of the 5 possible states is 1 ---
everyone has to be somewhere.  Thus one of the curves
is redundant, and the fraction still in the entry state is the least 
interesting of them.
(A multi-state \code{survfit} call that does not include the \code{istate}
argument will assume that everyone starts in an unnamed entry state.
The default plot behavior is to omit the curves for any unnamed states.)


<<sfit4, fig=TRUE, include=FALSE>>=
sfit4 <- survfit(Surv(tstart, tstop, event) ~ trt, mdata, id=id)
sfit4$transitions
layout(matrix(1:2,1,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1,.1))
plot(sfit4, col=rep(1:4,each=2), lwd=2, lty=1:2, xmax=48, xaxt='n',
     xlab="Months", ylab="Current state")
axis(1, xtime, xtime)
text(c(40, 40, 40, 40), c(.51, .13, .32, .01),
     c("Death", "CR", "Transplant", "Recurrence"), col=c(4,1,2,3))

par(mar=c(5.1, .1, 1, .1))
state5()
par(oldpar)
@ 

The transitions table above shows \Sexpr{sfit4$transitions[1,4]} %$ 
direct transitions from entry to death, i.e., 
subjects who die without experiencing any of the other intermediate points,
\Sexpr{sfit4$transitions[2,3]} who go from CR to transplant (as expected),
\Sexpr{sfit4$transitions[3,2]} who go from transplant to CR, etc. %$
No one was observed to go from relapse to CR in the data set, this
serves as a data check since it should not be possible per the data entry plan.

\section{Influence matrix}

For one of the curves above we returned the influence array.
For each value in the matrix $P$ = probability in state and each subject
$i$ in the data set, this contains the effect of that subject on each
value in $P$.  Formally,
\begin{equation*}
  D_{ij}(t) = \left . \frac{\partial p_j(t)}{\partial w_i} \right|_w
\end{equation*}
where $D_{ij}(t)$ is the influence of subject $i$ on $p_j(t)$, and
$p_j(t)$ is the estimated probability for state $j$ at time $t$.
This is known as the infinitesimal jackknife (among other labels).
<<reprise>>=
crsurv <- survfit(Surv(tstart, tstop, cr2) ~ trt,
                  data= mdata, id=id, influence=TRUE)
curveA <- crsurv[1,]  # select treatment A

dim(curveA)    # P matrix for treatement A
curveA$states
dim(curveA$pstate)  # 426 time points, 5 states
dim(curveA$influence) # influence matrix for treatment A
table(myeloid$trt)
@

For treatment arm A there are \Sexpr{table(myeloid$trt)[1]} subjects and
\Sexpr{dim(curveA$pstate)[1]} time points in the $P$ matrix.
The influence array has subject as the first dimension, and for each
subject it has an image of the $P$ matrix containing that subject's
influence on each value in $P$, i.e.,
\code{influence[1, ,]} is the influence of subject 1 on $P$.
For this data set everyone starts in the entry state, so $p(0)$ = the
first row of \code{pstate} will be (1, 0, 0, 0, 0) and the influence of
each subject on this row is 0;
this does not hold if not all subjects start in the same state.

As an exercise we will calculate the mean time in state out to 48 weeks.
This is the area under the individual curves from time 0 to 48.  Since
the curves are step functions this is simple sum of rectangles, treating
any intervals after 48 months as having 0 width.
<<meantime>>=
t48 <- pmin(48, curveA$time)   
delta <- diff(c(t48, 48))  # width of intervals
rfun <- function(pmat, delta) colSums(pmat * delta)  #area under the curve
rmean <- rfun(curveA$pstate, delta)

# Apply the same calculation to each subject's influence slice
inf <- apply(curveA$influence, 1, rfun, delta=delta)
# inf is now a 5 state by 310 subject matrix, containing the IJ estimates
#  on the AUC or mean time.  The sum of squares is a variance.
se.rmean <- sqrt(rowSums(inf^2))
round(rbind(rmean, se.rmean), 2)

print(curveA, rmean=48, digits=2)
@ 

The last lines verify that this is exacly the cacluation done by the
\code{print.survfitms} function; the results can also be found in
the \code{table} component returned by \code{summary.survfitms}.

In general, let $U_i$ be the influence of subject $i$.
For some function $f(P)$ of the probability in state matrix \code{pstate}, 
the influence of subject
$i$ will be $\delta_i = f(P + U_i) - f(P)$ and the infinitesimal jackknife
estimate of variance will be $\sum_i \delta^2$.
For the simple case of adding up rectangles $f(P +U_i) - f(P) = f(U_i)$ leading
to particularly simple code, but this will not always be the case.  

\section{State space figures}
label{sect:statefig}
The state space figures in the above example were drawn with a simple
utility function \code{statefig}.  It has two primary arguments along with
standard graphical options of color, line type, etc.
\begin{enumerate}
  \item A layout vector or matrix.  A vector with values of (1, 3, 1)
    for instance will allocate one state, then a column with 3 states, then
    one more state, proceeding from left to right.  A matrix with a single
    row will do the same, whereas a matrix with one column will proceed
    from top to bottom.
  \item A $k$ by $k$ connection matrix $C$ where $k$ is the number of states.
    If $C_{ij} \ne 0$ then an arrow is drawn from state $i$ to state $j$.
    The row or column names of the matrix are used to label the states.
    The lines connecting the states can be straight or curved, see the
    help file for an example.
\end{enumerate}
 
The first few state space diagrams were competing risk models, which use
the following helper function.  It accepts a vector of state names,
where the first name is the starting state and the remainder are the
possible outcomes.
<<crisk>>=
crisk <- function(what, horizontal = TRUE, ...) {
    nstate <- length(what)
    connect <- matrix(0, nstate, nstate,
                      dimnames=list(what, what))
    connect[1,-1] <- 1  # an arrow from state 1 to each of the others
    if (horizontal) statefig(c(1, nstate-1),  connect, ...)
    else statefig(matrix(c(1, nstate-1), ncol=1), connect, ...)
}
@ 

This next function draws a variation of the illness-death model.
It has an initial state,  
an absorbing state (normally death), and an optional intermediate state.
<<state3>>=
state3 <- function(what, horizontal=TRUE, ...) {
    if (length(what) != 3) stop("Should be 3 states")
    connect <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3,3,
                      dimnames=list(what, what))
    if (horizontal) statefig(1:2, connect, ...)
    else statefig(matrix(1:2, ncol=1), connect, ...)
}
@ 

The most complex of the state space figures has all 5 states.
<<state5>>=
state5 <- function(what, ...) {
    sname <- c("Entry", "CR", "Tx", "Rel", "Death")
    connect <- matrix(0, 5, 5, dimnames=list(sname, sname))
    connect[1, -1] <- c(1,1,1, 1.4)
    connect[2, 3:5] <- c(1, 1.4, 1)
    connect[3, c(2,4,5)] <- 1
    connect[4, c(3,5)]  <- 1
    statefig(matrix(c(1,3,1)), connect, cex=.8, ...)
}
@ 

For figure \ref{txsurv} I want a third row with a single
state, but don't want that state centered.
For this I need to create my own (x,y) coordinate list as
the layout parameter.  Coordinates must be between 0 and 1.
<<state4>>=
state4 <- function() {
    sname <- c("Entry", "CR", "Transplant", "Transplant")
    layout <- cbind(x =c(1/2, 3/4, 1/4, 3/4),
                    y =c(5/6, 1/2, 1/2, 1/6))
    connect <- matrix(0,4,4, dimnames=list(sname, sname))
    connect[1, 2:3] <- 1
    connect[2,4] <- 1
    statefig(layout, connect)
}
@

The statefig function was written to do ``good enough'' state space figures
quickly and easily, in the hope that users will find it simple enough that
diagrams are drawn early and often.
Packages designed for directed acylic graphs (DAG) such as diagram, DiagrammeR,
 or dagR are far more flexible
and can create more nuanced and well decorated results.

\subsection{Further notes}
The Aalen-Johansen method used by \code{survfit} does not account for 
interval censoring, also known as panel data, 
where a subject's current state is recorded at some fixed time such as a
medical center visit but the actual times of transitions are unknown.
Such data requires further assumptions about the transition process in
order to model the outcomes and has a more complex likelihood. 
The \code{msm} package, for instance, deals with data of this type.
If subjects reliably come in at regular intervals then the 
difference between the two results can be small, e.g., the 
\code{msm} routine estimates time until progression \emph{occurred}
whereas \code{survfit} estimates time until progression was \emph{observed}.

\begin{itemize}
  \item When using multi-state data to create Aalen-Johansen estimates, 
    individuals
    are not allowed to have gaps in the middle of their time line.
    An example of this would be a data set with 
    (0, 30, pcm] and (50,70, death] as the two observations
    for a subject where the time from 30-70 is not accounted for.
  \item Subjects must stay in the same group over their entire observation
    time, i.e., variables on the right hand side of the equation cannot be
    time-dependent. 
  \item A transition to the same state is allowed, e.g., observations of
    (0,50, 1], (50, 75, 3], (75, 89, 4], (89, 93, 4] and (93, 100, 4] 
    for a subject who goes
    from entry to state 1, then to state 3, and finally to state 4.
    However, a warning message is issued for the data set in this case, since
    stuttering may instead be the result of a coding mistake.
    The same result is obtained if 
    the last three observations were collapsed to a single row of 
    (75, 100, 4].
\end{itemize}

%--------------------------------------------------------

\chapter{A menagerie of models}
For modeling survival data the package includes several choices, which can 
be broken up into \emph{hazard} and \emph{direct} models for the data.
Let $x_1, x_2, \ldots$ be a set of covariates or predictors.

Direct models model the survival time directly as
\begin{equation*}
  E(t) = f(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots)
\end{equation*}
for some link function $f$.
These models are fit using the \code{survreg} function, which will be covered
in chapter \ref{chap:aft}.

Hazard models attempt to summarized the rate or hazard of transition between
states and include 3 models.

Exponential (or poisson) models
\begin{equation*}
 \lambda(t) = \exp(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots) 
\end{equation*}
These can be fit using the \code{glm} command in base R, after proper data
set up.  
For example, here is a simple fit to the aml data set.
<<lungglim>>=
gfit <- glm(status ~ x + offset(log(time)), family=poisson, data=aml)
summary(gfit)
@ 
 
The subjects who did not recieve maintainance therapy have a 2.5 fold
higher death rate.
In this model the response is the number of events for a subject, so it can
be applied to multiple outcome data as well.
The \code{offset} term is based on the fact that for a poisson response
E(number of events) = rate * time = exp(log(rate) + log(time)).
We are using $\beta x$ to model the log rate and so log(time) appears in the
model as an \emph{offset}, a covariate with known coefficient of 1.

The proportional hazards or Cox model allows an semi-parametric intercept
\begin{align*}
  \lambda(t) &= \exp(\beta_0(t) + \beta_1 x_1 + \beta_2 x_2 + \ldots) \\
             &= \lambda_0(t) \exp(\beta_1 x_1 + \beta_2 x_2 + \ldots)
\end{align*}
where $\lambda_0$ is referred to as the baseline hazard.
The literature, by the way, is about evenly split between using
$\lambda$, $h$ and $\alpha$ as the symbol.
This model will be covered in chapter \ref{chap:PH}.

The Aalen additive regresson model is 
\begin{align*}
   \lambda(t) = \beta_0(t) + \beta_1(t) x_1 + \beta_2(t) x_2 + \ldots
\end{align*}
The model is more complex than the Cox model --- all of the coefficients
are time dependent --- but it also has important advantages.
These models can be fit using the \code{aareg} function in the survival
package.
The \code{timereg} package has superseded the \code{aareg} function in every
way, however, and users of the Aalen model should direct their 
attention there.  

% -----------------------------------------

\chapter{Cox proportional hazard model}
\label{chap:PH}
The Cox model is the single most popular model for time to event data.
Part of this is certainly historical.  It has been said that the
correlation coefficient rose to prominence because R. A. Fisher worked out
the statistical theory at about the same time that desk calculators could
first handle a running sum $\sum x_i y_i$; it was both a simple statistic
and the most complex thing one could do.
The Cox model's relationship to 1970's computing power was much the same. 

The fact that it continues to be used is partially due to inertia, but 
only partly.  There are, I think, three keys to a successful statistical
model, and the proportional hazards model seems to strike the right balance
between them.  A good model
\begin{enumerate}
  \item provides a simplified summary of the effects
  \item executes reliably without ``hand holding''
  \item is a \emph{good enough} summary of the biology
\end{enumerate}

The first of these usually boils down to using a linear predictor 
$\beta_1 x_1 + \beta_2 x_2 + \ldots$ for the covariates, since it allows us
to say that ``the effect of treatment is a \underline{\phantom{abc}}'' 
(or age, sex, blood pressure, \ldots), i.e., to make simple statements about
any given covariate of interest.  
The second is practical --- programs that sometimes fail, or that require 
starting estimates or per dataset tuning do not get used in day to day work.
The last is that the results need to be correct to act as a basis for 
action.  This is well captured by three quotations
\begin{quotation}
 A model is a lie that helps us see the truth''.\\  H. Skipper in The Emporer
of all Maladies.

  All models are approximations. Assumptions, whether implied or clearly 
stated, are never exactly true. All models are wrong, but some models are 
useful. So the question you need to ask is not ``Is the model true?" (it never 
is) but ``Is the model good enough for this particular application?''\\
G.E.P Box, Statistical Control By Monitoring and Adjustment, 2009.

Ce qui est simple est toujours faux. Ce qui ne l'est pas est inutilisable.
(What is simple is always wrong. What is not is unusable.)\\
Paul Val\'{e}ry, 1949

\end{quotation}

We will show the model in four situations
\begin{centering}
 \begin{tabular}{ccc}
 & One outcome per subject & Multiple outcomes per subject \\
One type of outcome & 1 & 2 \\
Multiple types of outcome & 3 & 4
\end{tabular}
\end{centering}
Type 1 is simple or classic survival, 2 is repeated events per subject,
3 is exemplified by competing risks, and 4 is the most general.

\section{Single Event}
An example of the classic Cox model can be illustrated using the
lung cancer data set.
This involves subjects with advanced lung cancer, recruited in a set
of multi-institutional trials.

<<lung1>>=
fit1 <- coxph(Surv(time, status) ~ age + sex + ph.ecog, data=lung)
print(fit1, digits=2)   # fewer digits to fit on the page
@ 

The Eastern Cooperative Oncology Group's performance status is a measure
of subject's functional ability ranging from 0= asymptomatic to 4=bedbound,
and is the most powerful predictor of outcome for these patients.

The simplifiying aspects of the Cox model that make is so useful are
exactly those that should be verified, namely proportional hazards,
additivity, linearity, and lack of any high leverage points.
The first can be checked with the \code{cox.zph} function.

<<lung2, fig=TRUE>>=
zp1 <- cox.zph(fit1)
zp1
plot(zp1[2], resid=FALSE)
abline(coef(fit1)[2] ,0, lty=3)
@ 
None of the test statistics for PH are remarkable.  

\section{Repeating Events}

% -------------------------------------

\section{Competing risks}
Our third category is models where there is more than one event type, but
each subject can have only one transition.
This is the setup of competing risks.

\subsection{MGUS}
As an simple multi-state example consider the monoclonal gammopathy data
 set \code{mgus2},
which contains the time to a plasma cell malignancy (PCM), usually
multiple myleoma,  and the 
time to death for 1384 subjects found to have a condition known as
monoclonal gammopathy of undetermined significance (MGUS), based on
a particular test.  
This data set has already appeared in \ref{mgusplot}.
The time values in the data set are from detection of the condition.
Here are a subset of the observations along with a simple state figure
for the data.

<<survfit-mgus1, fig=TRUE>>=
mgus2[56:59,]

sname <- c("MGUS", "Malignancy", "Death")
smat <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3, 3, 
               dimnames = list(sname, sname))
statefig(c(1,2), smat)
@ 

In this data set 
subject 56 was diagnosed with a PCM 29 months after detection of MGUS and
died at 44 months. 
This subject passes through all three states.
The other three listed individuals died without a plasma cell malignancy
and traverse one of the arrows;
103 subjects (not shown) are censored before experiencing either event
and spend their entire tenure in the leftmost state.
The competing risks model will ignore the transition from malignacy to death:
the two ending states are ``malignancy before death'' and ``death without
malignancy''.  

The \code{statefig} function is designed to create simple state diagrams,
with an emphasis on ease rather than elegance. 
See more information in section \ref{sect:statefig}.
 
To compute the multi-state survival, we first create a data set with
(begin, end) time intervals using \code{tmerge}.
As is often the case, a closer look at the data uncovered some special
issues: there are 9 subjects whose time to progression is identical to
the death time.
It turns out that these are subjects whose disease was discovered at
autopsy.
The survival code does not allow for time intervals of length zero, 
so a modification needs to be made to the data.
Clearly, these autopsied subjects will have had their 
malignancy for some period of time before death, below we arbitrarily
move the PCM date 1 month back.

<<survfit-mgus2>>=
# modified progression time, = -1 month if tied with death
temp <- with(mgus2, ifelse(pstat==0, NA,
                           ifelse(ptime==futime, ptime-1, ptime)))
mdata <- tmerge(mgus2[,1:7], mgus2, id=id, event= event(futime, 2*death),
                event= event(temp))
mdata$event <- factor(mdata$event, 0:2, c("censor", "PCM", "Death"))
mdata[56:59,]
survcheck(Surv(tstart, tstop, event) ~ 1, mdata, id=id)
@ 
 
The short dataset printout shows that subject 56 is represented as two rows,
the first from entry to PCM, with a length of 29 months, and second 
spanning from 29 to 44 months and ending with death.
The transition table from the \code{survcheck} output shows transitions
from the entry state ``()'' to PCM and Death, and from PCM to Death.
\index{function!survcheck}
Importantly, it does not show any transitions from PCM to PCM, which by
the study definition can only occur once, or from Death to some other state.
The table of per subject counts shows 103 subjects who make 2 transitions,
but no one who has multiple PCM or death events.
We are now ready to compute an estimate.

The competing risks data consists of only the first event for each subject,
so we subset the data when fitting the model.
It is good practice to summarize covariates before a fit.
<<cfit1>>=
crdata <- subset(mdata, tstart==0)
quantile(crdata$age, na.rm=TRUE)
table(crdata$sex)
quantile(crdata$mspike, na.rm=TRUE)

cfit <- coxph(Surv(tstart, tstop, event) ~ I(age/10) + sex + mspike, 
              id = id, crdata)
print(cfit, digits=1)  # narrow the printout a bit
@ 
The effect of age and sex on non-PCM mortality is profound, which is not
a surprise given the median starting age of \Sexpr{median(mgus2$age)}. %$
Death rates rise \Sexpr{round(exp(10*coef(cfit)[4]),1)} fold per decade 
of age and
the death rate for males is \Sexpr{round(exp(coef(cfit)[5]),1)} times as great
as that for females.  
The size of the serum monoclonal spike has almost no impact on non-PCM 
mortality.
A 1 unit increase changes mortality by only 2\%.

The mspike size has a major impact on progression, however; each 1 gram
change increases risk by \Sexpr{round(exp(coef(cfit)[3]) ,1)} fold.
The interquartile range of \code{mspike} is 0.9 grams so this risk increase
is clinically important.
The effect of age on the progression rate is much less pronounced,
with a coefficient only 1/4 that for mortality, while the effect of sex
on progression is completely negligible.

Estimates of the probability in state can be simply computed using 
\code{survfit}.
As with any model, estimates are always for a particular set of
covariates.  We will use 4 hypothetical subjects, male and female
with ages of 60 and 80.
<<PCMcurve, fig=TRUE>>=
dummy <- expand.grid(sex=c("F", "M"), age=c(60, 80), mspike=1.2)
csurv  <- survfit(cfit, newdata=dummy)
plot(csurv[,2], xmax=20*12, xscale=12,
     xlab="Years after MGUS diagnosis", ylab="Pr(has entered PCM state)",
     col=1:2, lty=c(1,1,2,2), lwd=2)
legend(100, .04, outer(c("female,", "male,  "), 
                     c("diagnosis at age 60", "diagnosis at age 80"), 
                      paste),
       col=1:2, lty=c(1,1,2,2), bty='n', lwd=2)
@ 

Although sex has no effect on the \emph{rate} of plasma cell malignancy,
its effect on the \emph{lifetime probability} of PCM is not zero,
however.  
As shown by the simple Poisson model below, the rate of PCM is about 1\%
per year.  Other work reveals that said rate is almost constant over
follow-up time (not shown). 
Because women in the study have an average lifetime that is 2 years
longer than men, their lifetime risk of PCM is higher as well.
Very few subjects acquire PCM more than 15 years after a MGUS diagnosis at
age 80 for the obvious reason tha very few of them will still 
be alive.

<<mrate>>=
mpfit <- glm(pstat ~ sex -1 + offset(log(ptime)), data=mgus2, poisson)
exp(coef(mpfit)) * 12   # rate per year
@ 

A single outcome fit using only time to progression is instructive:
we obtain exactly the same coefficients but different absolute risks.
This is a basic property of multi-state models: hazards can be explored
separately for each transition, but absolute risk must be computed globally.
(The estimated cumulative hazards from the two models are also identical).
The incorrect curve is a vain attempt to estimate the progression rate which 
would occur if death could be abolished.  It not surprisingly ends up as about
1\% per year.  

<<msingle, fig=TRUE>>=
sfit <- coxph(Surv(tstop, event=="PCM") ~ I(age/10) + sex + mspike, crdata)
rbind(single = coef(sfit),
      multi  = coef(cfit)[1:3])
par(mfrow=c(1,2))
ssurv <- survfit(sfit, newdata=dummy)
plot(ssurv[3:4], col=1:2, lty=2, xscale=12, xmax=12*20, lwd=2, fun="event",
     xlab="Years from diagnosis", ylab= "Pr(has entered PCM state)")
lines(csurv[3:4, 2], col=1:2, lty=1, lwd=2)
legend(20, .22, outer(c("80 year old male,", "80 year old female,"),
                      c("incorrect", "correct"), paste),
                  col=1:2, lty=c(2,2,1,1), lwd=2, bty='n')
@ 


\section{Multiple event types per subject}

\chapter{Accelerated Failure Time models}
\label{chap:aft}





\appendix
\chapter{Changes from version 2.44 to 3.0}
Not all of these may be completed by 3.0, but this is the roadmap.

\section{Changes in version 3}
\label{sect:changes}
Version 3.0 of the package was released in conjunction with a book.  Writing
the book, and in particular the examples, revealed some shortcomings in 
the design.
In particular, there were some common concepts which had appeared piecemeal in
more than one function, but not using the same keywords.  Two particular areas
are survival curves and multiple observations per subject.

Survival and cumulative hazard curves are genereated by the 
\code{survfit} function, either from
raw data (survfit.formula), or a fitted Cox or parametric survival model
(survfit.coxph, survfit.survreg). 
Two choices that appear are
\begin{enumerate}
  \item If there are tied event times, to estimate the hazard using a 
    straightforward increment of (number of events)/(number at risk), or
    make a correction for the ties.  The simpler method is known variously
    as the Nelson, Aalen, Breslow, and Tsiatis estimate, along with hypenenated
    forms combining 2 or 3 of them.
    One of the simpler corrections for ties is known as the Fleming-Harrington
    approximation when used with raw data, and the Efron when used 
    in a Cox model.
  \item The survival curve $S(t)$ can be estimated directly or as the
    exponential of the cumulative hazard estimate.  The first of these is
    known as the Kaplan-Meier, cumulative incidence (CI), Aalen-Johansen,
    and Kalbfleisch-Prentice estimate, depending on context, 
    the second as a Fleming-Harringtion, Breslow, or Efron estimate, again
    depending on context.
\end{enumerate}

With respect to the two above, subtypes of the \code{survfit} routine have
had either a \code{type} or \code{method} argument over the years which tried
to capture both of these at the same time, 
and consequently have had a bewildering number of options,
for example ``fleming-harrington'' in \code{survfit.formula} 
stood for the simple cumulative hazard
estimate plus the exponential survival estimate, 
``fh2'' specified the tie-corrected cumulative hazard plus exponential survival,
while \code{survfit.coxph} used ``breslow'' and ``efron'' for the same two
combinations.
The updated routines now have separate \code{stype} and \code{ctype}
arguments.  For the first 1= direct and 2=exponent of the cumulative hazard
and for the second 1=simple and 2= corrected for ties. 

The Cox model is a special case in two ways: 
1. the the way in which ties are treated
in the likelihood should match the way they are treated in creating the hazard
and 2. the direct estimate of survival can be very difficult to compute.
The survival package's default is to use the \code{ctype} option 
which matches the ties option
of the \code{coxph} call along with an exponential estimate of survival.
This \code{ctype} choice preserves some useful properties of the martingale
residuals.

A second issue is multiple observations per subject, and how those impact
the computations.  This leads to 3 common arguments of
\begin{itemize}
  \item id: an identifier in each row of the data, which allows the routines
    to identify multiple rows for a subject
  \item cluster: identify correlated rows, which should be combined when
    creating the robust variance
  \item robust: TRUE or FALSE, to compute a robust variance.
\end{itemize}

These arguments have been inconsistent in the past, partly because of the
sequential appearance of multiple use cases.  The package started with
only the simplest data form: one observation per subject, one endpoint.
To this has been added
\begingroup
\renewcommand{\theenumi}{\alph{enumi}}
\begin{enumerate}
  \item Multiple observations per subject
  \item Multiple endpoints per subject
  \item Multiple types of endpoints
\end{enumerate}
\endgroup

Case (a) arises as a way to code time-dependent covariates, and in this
case an \code{id} statement is not needed, and in fact you will get the
same estimates and standard errors with or without it. 
(There will be a change in the counts of subjects who leave or enter an
interval, since an observation pair (0, 10), (10, 20) for the same subject
will not count as an exit (censor) at 10 along with an entry at 10.)
If (b) is true then the robust variance is called for, one will want to 
have either a \code{cluster} argument or the \code{robust=TRUE} argument.
In the coxph routine a \code{cluster(group)} term in the model statement
can be used instead of the cluster argument,
but this is no longer the preferred form. 
When (b) and (c) are true then the \code{id} statement is required in order
to obtain a correct \emph{estimate} of the result. 
This is also the case for (c) alone when subjects do not all start in the
same state.  
For competing risks data --- multiple endpoints, 
everyone starts in the same state, only one transition per subject --- 
the \code{id} statement is not necessary nor (I think) is a robust variance.

When there is an \code{id} statement but no \code{cluster} or \code{robust}
directive, then the programs will use (b) as a litmus test to decide
between model based or robust variance, if possible.
(There are edge cases where only one of the two variance estimates has 
been implemented, however).
If there is a \code{cluster} argument then \code{robust=TRUE} is assumed.
If only a \code{robust=TRUE} argument is given
then the code treats each line of data as independent.

\section{Survfit}
  The survfit object is changing.   The primary change has to do with the 
starting time.  When the package was first written in the late 1980s I made
the decision to \emph{not} include the initial point of the survival curve
(time=0, S=1) as a part of the \code{time} and \code{survival} parts of the
object; they could get tacked on by the plot function.
With the addition of delayed start (\code{start.time} option) and then
more importantly multi-state models, the starting point is not always a
simple (0,1) pair, which led to the addition of new components to the
objects to hold the additional information, and increasing if-then-else logic
in the downstream routines that process the curves.  In v3 the first point
is now bundled in as part of the time, surv, pstate, std.err, and etc 
components. 

Two functions survfit23 and survfit32 convert
between the version 2 \code{survfit} object  and new \code{survfit3} forms.  
This has allowed us make any changes incrementally.

Other changes are    
\begin{itemize}
  \item Common arguments of id, cluster, and influence
  \item The routines now produce both the estimated survival and the
    estimated cumulative hazard, along with their errors 
  \item Some code paths produced std(S) and some std(log(S)), the object now
    contains a \code{log.se} flag telling which.  (Before, downstream routines
    just ``had to know'').
  \item an explicit ``version'' flag in the object
  \item using a single subscript on a survfit object now behaves like the
    use of a single subscript on an array or matrix, in that the result has
    only one dimension.
\end{itemize}

\section{Coxph}
 The multi-state objects include a \code{states} vector, which is a simple
list of the state names.
The \code{cmap} component is an integer matrix  with one row for each term in the
model and one column for each transition. 
Each element indexes a position in the coefficient vector and variance matrix.
\begin{itemize}
  \item Column labels are of the form 1:2, which denotes a transition from
    \code{state[1]} to \code{state[2]}.
  \item If a particluar term in the data, ``age'' say, was not part of the model
    for a particular transition then a 0 will appear in that position 
    of \code{cmap}.
  \item If two transitions share a common coefficient, both those element of
    \code{cmap} will point to the same location.
  \item The first row of \code{cmap}, labeled ``stratum'', is numbered separately
    and partitions the transtions into disjoint strata.
\end{itemize}

\end{document}


