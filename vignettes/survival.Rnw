\documentclass{report}[11pt]
\usepackage{Sweave}
\usepackage{amsmath}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-.5in}
\setlength{\evensidemargin}{\oddsidemargin}
%\VignetteIndexEntry{The survival package}

\SweaveOpts{keep.source=TRUE, fig=FALSE}
% Ross Ihaka suggestions
\DefineVerbatimEnvironment{Sinput}{Verbatim} {xleftmargin=2em}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=2em}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}

% I had been putting figures in the figures/ directory, but the standard
%  R build script does not copy it and then R CMD check fails
\SweaveOpts{prefix.string=compete,width=6,height=4}

\newcommand{\myfig}[1]{\includegraphics[height=!, width=\textwidth]
                        {compete-#1.pdf}}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\Lhat}{\hat\Lambda}

\setkeys{Gin}{width=\textwidth}
<<echo=FALSE>>=
options(continue="  ", width=60)
options(SweaveHooks=list(fig=function() par(mar=c(4.1, 4.1, .3, 1.1))))
pdf.options(pointsize=10) #text in graph about the same as regular text
options(contrasts=c("contr.treatment", "contr.poly")) #ensure default
library("survival")
palette(c("#000000", "#D95F02", "#1B9E77", "#7570B3", "#E7298A", "#66A61E"))

# These functions are used in the document, but not discussed until the end
crisk <- function(what, horizontal = TRUE, ...) {
    nstate <- length(what)
    connect <- matrix(0, nstate, nstate,
                      dimnames=list(what, what))
    connect[1,-1] <- 1  # an arrow from state 1 to each of the others
    if (horizontal) statefig(c(1, nstate-1),  connect, ...)
    else statefig(matrix(c(1, nstate-1), ncol=1), connect, ...)
}

state3 <- function(what, horizontal=TRUE, ...) {
    if (length(what) != 3) stop("Should be 3 states")
    connect <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3,3,
                      dimnames=list(what, what))
    if (horizontal) statefig(1:2, connect, ...)
    else statefig(matrix(1:2, ncol=1), connect, ...)
}

state4 <- function() {
    sname <- c("Entry", "CR", "Transplant", "Transplant")
    layout <- cbind(c(1/2, 3/4, 1/4, 3/4),
                    c(5/6, 1/2, 1/2, 1/6))
    connect <- matrix(0,4,4, dimnames=list(sname, sname))
    connect[1, 2:3] <- 1
    connect[2,4] <- 1
    statefig(layout, connect)
}

state5 <- function(what, ...) {
    sname <- c("Entry", "CR", "Tx", "Rel", "Death")
    connect <- matrix(0, 5, 5, dimnames=list(sname, sname))
    connect[1, -1] <- c(1,1,1, 1.4)
    connect[2, 3:5] <- c(1, 1.4, 1)
    connect[3, c(2,4,5)] <- 1
    connect[4, c(3,5)]  <- 1
    statefig(matrix(c(1,3,1)), connect, cex=.8,...)
}
@

\title{The survival package}
\author{Terry Therneau}
\begin{document}
\maketitle
\clearpage
\tableofcontents

\chapter{Introduction}
\section{History}
Work on the survival package began in 1985 in connection with the analysis
of medical research data, without any realization at the time that the
work would become a package.
Eventually, the software was placed on the Statlib repository hosted by
Carnegie Mellon University. 
Multiple version were released in this fashion but I don't have a list of
the dates --- version 2 was the first to
make use of the \code{print} method that was introduced in `New S' in 1988,
which places that release somewhere in 1989.
The library was eventually incorporated directly in S-Plus, and from there it
became a standard part of R.

I suspect that 
one of the primary reasons for the package's success is that all of the
functions have been written to solve real analysis questions that arose from
real data sets; theoretical issues were explored when necessary but they 
have never played a leading role.  
As a statistician in a major medical center, the central focus of my department
is to advance medicine; statistics is a tool to that end.
This also highlights one of the deficiencies of the package: if a particular
analysis question has not yet arisen in one of my studies then the survival 
package will also have nothing to say on the topic. 
Luckily, there are many other R packages that build on or extend
the survival package, and anyone working in the field (the author included) 
can expect to use more packages than just this one.
The author certainly never foresaw that the library would become as popular 
as it has.

This vignette is an introduction to version 3.x of the survival package. 
We can think of versions 1.x as the S-Plus era and 2.1 -- 2.44 as maturation of
the package in R.
Version 3 had 4 major goals.
\begin{itemize} 
  \item Make multi-state curves and models as easy to use as an ordinary
    Kaplan-Meier and Cox model.
  \item Deeper support for absolute risk estimates.
  \item Consistent use of robust variance estimates.
  \item Clean up various naming inconsistencies that have arisen over time.
\end{itemize}

With over 600 dependent packages in 2019, not counting Bioconductor, other
guiding lights of the change are
\begin{itemize}
  \item We can't do everything (so don't try).
  \item Allow other packages to build on this one.  That means clear 
    documentation of all of the results that are produced, the use of simple
    S3 objects that are easy to manipulate, and setting up many 
    of the routines as a pair.  For example, \code{concordance} and 
    \code{concordancefit}; the former is the user front end and the latter does 
    the actual work.  Other package authors might want to access the lower level
    interface, while accepting the penalty of fewer error checks. 
  \item Don't mess it up!
\end{itemize}

This meant preserving the current argument names as much as possible.
Appendix \ref{sect:changes} summarizes changes that were made which are not
backwards compatible.

The two other major changes are to collapse many of vignettes into this single
large one, and the parallel creation of an actual book.  
We've recognized that the package needs more than a vignette.  
With the book's appearance this vignette can also
be more brief, essentially leaving out a lot of the theory.

Version 3 will not appear all at once, however; it will take some time to get 
all of the documentation sorted out in the way that we like.

\section{Survival data}
The survival package is concerned with time-to-event analysis.
Such outcomes arise very often in the analysis of medical data:
time from chemotherapy to tumor recurrence, the durability of a joint
replacement, recurrent lung infections in subjects with cystic fibrosis,
the appearance of hypertension, hyperlipidemia and other comorbidities 
of age, and of course death itself, from which the overall label of
``survival'' analysis derives.  
A key principle of all such studies is that ``it takes time to observe
time'', which in turn leads to two of the primary challenges.
\begin{enumerate}
  \item Incomplete information.  At the time of an analysis, not everyone
    will have yet had the event.  This is a form of partial information
    known as \emph{censoring}: if a particular subject was enrolled in a
    study 2 years ago, and has not yet had an event at the time of
    analysis, we only know that their time to event is $>2$ years.
  \item Dated results.  In order to report 5 year survival, say, from a 
    treatment, patients need to be enrolled and then followed for 5+ years.
    By the time recruitment and follow-up is finished, analysis done, 
    the report finally published the treatment in question might be 8
    years old and considered to be out of date.  This leads to a tension
    between early reporting and long term outcomes.
\end{enumerate}

<<states, fig=TRUE>>=
oldpar <- par(mar=c(.1, .1, .1, .1), mfrow=c(2,2))
sname1 <- c("Alive", "Dead")
cmat1 <- matrix(c(0,0,1,0), nrow=2, 
                dimnames=list(sname1, sname1))
statefig(c(1,1), cmat1)

sname2 <- c("0", "1", "2", "...")
cmat2 <- matrix(0, 4,4, dimnames= list(sname2, sname2))
cmat2[1,2] <- cmat2[2,3] <- cmat2[3,4] <- 1
statefig(c(1,1,1,1), cmat2, bcol=c(1,1,1,0))

sname3 <- c("Entry", "Transplant", "Withdrawal", "Death")
cmat3 <- matrix(0, 4,4, dimnames=list(sname3, sname3))
cmat3[1, -1] <- 1
statefig(c(1,3), cmat3)

sname4 <- c("Health", "Illness", "Death")
cmat4 <- matrix(0, 3, 3, dimnames = list(sname4, sname4))
cmat4[1,2] <- cmat4[2,1] <- cmat4[-3, 3] <- 1
statefig(c(1,2), cmat4, offset=.03)

par(oldpar)
@

Survival data is often represented as
a pair $(t_i, \delta_i)$ where $t$ is the time until endpoint or last
follow-up, and $\delta$ is a 0/1 variable with 0= ``subject was censored at
$t$'' and 1 =``subject had an event at $t$'',
or in R code as \code{Surv(time, status)}.  
The status variable can be logical, e.g., \code{vtype=='death'} where 
\code{vtype} is the variable ``visit type''.  
An alternate view is to think of time to event data as a multi-state process
as is shown in the above figure. 
The upper left panel is simple survival with two states of alive and dead,
``classic'' survival analysis.
The other three panels show repeated events of the same type (upper right)
competing risks for subjects on a liver transplant waiting list(lower left) 
and the illness-death model (lower right).
In this approach interest normally centers on the transition rates or hazards
(arrows) from state to state (box to box).
For simple survival the two viewpoints are equivalent, and we will move
freely between them, i.e., use whichever viewpoint is handy at the moment,
either ``time to event'' or ``rate of events''.  
When there more than one transition the rate approach is particularly useful.

The figure also displays a 2 by 2 division of survival data sets, one that
will be used to organize many subsections of this document.
A: one event type (top row) versus multiple types of events 
(bottom row), and  B: one endpoint per subject (left column) versus multiple
events per subject (right column). 
The upper left is simple or ``classic'' survival while the lower right is
the most complex.

\chapter{Survival and cumulative hazard curves}
\section{Simple curves}
\index{function!survfit}%
\index{survival curves!one event}
The most common depiction of survival data is the Kaplan-Meier curve,
which is created with the \code{survfit} function.
The left-hand side of the formula will be a Surv object and the right hand
side contains one or more categorical variables that will divide the 
observations into groups.  For a single curve use \code{\textasciitilde 1}
as the right hand side.

<<survfit1>>=
fit1 <- survfit(Surv(time, status) ~ sex, data=lung)
print(fit1, rmean= 913)

summary(fit1, times= (0:4)*182.5)
@ 

The default printout is very brief, only one line per curve, showing the
number of observations, number of events, median survival, and
optionally the restricted mean survival time (RMST) in each of
the groups.  In the above case we used the value at 2.5 years = 913 days
as the upper threshold for the RMST, the value of 453 for females 
represents an average survival for 453 or the next 913 days after enrollment
in the study.
The summary function gives a more complete description of the curve,
in this case we chose to show the values every 6 months for the first two years.

Arguments for the survfit function include the usual
\code{data}, \code{weights}, \code{subset} and \code{na.action} 
arguments common to modeling formulas.
A further set of arguments have to do with standard errors and confidence
intervals, defaults are shown in parenthesis.
\begin{itemize}
  \item se.fit (TRUE): compute a standard error of the estimates.  
    In a few rare circumstances omitting the standard error  can save 
    computation time.
  \item conf.int (.95): the level of confidence interval, or FALSE if
    intervals are not desired.
  \item conf.type ('log'): transformation to be used in computing the
    confidence intervals. 
  \item conf.lower ('usual'): optional modification of the lower interval.
\end{itemize}

\index{survfit!confidence intervals}
For the default \code{conf.type} the confidence intervals are computed as
$$
   e^{\log(p) \pm 1.96 {\rm se}(\log(p))}
$$
rather than the direct formula of $p \pm 1.96 {\rm(se)}(p)$, where 
$p = S(t)$ is the survival probability.
Many authors have investigated the behavior of transformed intervals, and a 
general conclusion is that the direct intervals do not behave well, particularly
near 0 and 1, while all the others are acceptable. 
Which of the choices of log, log-log, or logit is ``best'' depends on the 
details of the simulation study.
(The default corresponds to the most recent paper the author had read, at
the time the default was chosen; a current meta review might give a slight edge
to log-log option.)

The \code{conf.lower} option is mostly used for graphs.  If a study has a 
long string of censored observations, it is intuitive that the precision
of the estimated survival must be decreasing due to a smaller sample size,
but the formal standard error will not change until the next death.
This option widens the confidence interval between death times, proportional
to the number at risk, giving a visual clue of the decrease in $n$.
There is only a small (and decreasing) population of users who make use of this.

\index{function!plot.survfit}
The most common use of survival curves is to plot them, as shown below.
<<survfit2, fig=TRUE>>=
plot(fit1, col=2:1, xscale=365.25, lwd=2, conf.times=c(.5, 1, 1.5, 2)*365,  
     xlab="Years since study entry", ylab="Survival")
legend(730, .8, c("Female", "Male"), col=1:2, lwd=2, bty='n')
@ 

Curves will appear in the plot in the same order as they are listed by 
\code{print}; this is a quick way to remind ourselves of which subset maps
to each color or linetype in the graph.
Curves can also be labeled using the \code{pch} option to place marks on 
the curves.
The location of the marks is controlled by the \code{mark.time} option
which has a default value of FALSE (no marks).  A vector of numeric values
specifies the location of the marks, optionally a value of 
\code{mark.time=TRUE} will cause a 
mark to appear at each censoring time; this can result in far too many marks
if $n$ is large, however.
By default confidence intervals are included on the plot of there is a single
curve, and omitted if there is more than one curve.  

The result of a \code{survfit} call can be subscripted.  This is useful
when one wants to plot only a subset of the curves.
\index{survfit!subscript}
<<survfit3, fig=TRUE>>=
fit2 <- survfit(Surv(time, status) ~  sex + ph.ecog, data=lung)
fit2
plot(fit2[1:3], lty=1:3, lwd=2, xscale=365.25,
       xlab="Years after enrollment", ylab="Survival")
legend(550, .8, paste("Performance Score", 0:2, sep=' ='), 
       lty=1:3, lwd=2, bty='n')
text(400, .95, "Males", cex=2)
@ 

\section{Repeated events}
\index{survival curves!repeated events}
Repeated events of the same type is quite common in industrial reliability
data.
As an example, consider a data set on the replacement times of
diesel engine valve seats.
The simple data set \code{valveSeats} contains an engine identifier, time, and
a status of 1 for a replacement and 0 for the end of the inspection interval
for that engine; sorted by time within engine.
To accommodate multiple events per subject each row needs to span a unique
time interval $(t1, t2]$, we do this by adding a new variable to the data
set.
Intervals of 0 are illegal for \code{Surv} objects.  There are 3 engines that
had 2 valves repaired on the same day, which will create such an interval.
To work around this so move the first repair back
in time by a tiny amount.  

<<survival4>>=
vdata <- valveSeat
first <- !duplicated(vdata$id)
vdata$t0 <- ifelse(first, 0,  c(0, vdata$time[-nrow(vdata)]))
double <- which(vdata$t0 == vdata$time)
vdata$time[double-1] <- vdata$t0[double] <- vdata$t0[double] -.01
vdata[1:7, c("id", "t0", "time", "status")]
survcheck(Surv(t0, time, status) ~ 1, id=id, data=vdata)
@ 

Creation of (start time, end time) intervals is a common data manipulation 
tasks when there are multiple events per subject. 
A later chapter will discuss the \code{tmerge} function, which is very often
useful for this task. 
The \emph{survcheck} function can be used as check for some of more common
errors that arise in creation; 
it also will be covered in more detail in a later section.
(The output will be also be less cryptic for later cases, where the states 
have been labeled.) 
In the above data, the engines could only participate in 2 kinds of transitions:
from an unnamed initial state to a repair, (s0) $\rightarrow$ 1, or from one
repair to another one, 1 $\rightarrow$ 1, or reach end of follow-up.
The second table printed by \code{survcheck} tells us the 17 engines had 0
transitions to state 1, i.e., no valve repairs before the end of observation
for that engine, 9 had 1 repair, etc.
Perhaps the most important output is that the routine did not print any 
warnings about suspicious data.

We can now compute the survival estimate.  When there are multiple observations
per subject the \code{id} statement is necessary.
(It is a good idea if there \emph{could} be multiples, even if there are none,
as it lets the underlying routines check for doubles.)

<<survival5, fig=TRUE>>=
vfit <- survfit(Surv(t0, time, status) ~1, data=vdata, id=id)
plot(vfit, cumhaz=TRUE, xlab="Days", ylab="Cumulative hazard")
@ 

By default, the \code{survfit} routine computes both the survival and
the cumulative hazard functions,
to plot the cumulative hazard portion the \code{cumhaz} argument of
\code{survfit} is used.
\index{cumulative hazard function}%
\index{mean cumulative function|see cumulative hazard function}  
In multi-event data, the cumulative hazard is an estimate of the expected
\emph{number} of events for a unit that has been observed for the 
given amount of time, whereas the survival $S$ estimates the probability that
a unit has had 0 repairs.
The cumulative hazard is often the more natural quantity to plot in such 
studies; in reliability analysis it is also known as the 
\emph{mean cumulative function}.  
The estimate is also important in multi-state models.

\section{Competing risks}
In the classic case, \code{status} is either a logical or 0/1 numeric variable
that represents censoring (0 or false) or an event (1 or true),
and the result is a survival curve for each group.
If \code{status} is a factor, however, the result is a multi-state
estimate.
In this case the first level of \code{status} is used to code censoring while
the remaining ones are possible states.
For competing risks data each subject has aT most one transition, but there
are multiple transition types.

\subsection{Simple example}
Here is a simple competing risks example where the three endpoints are
labeled as a, b and c.
<<simple1>>=
crdata <- data.frame(time= c(1:8, 6:8),
                     endpoint=factor(c(1,1,2,0,1,1,3,0,2,3,0),
                                     labels=c("censor", "a", "b", "c")),
                     istate=rep("entry", 11),
                     id= LETTERS[1:11])
tfit  <- survfit(Surv(time, endpoint) ~ 1, data=crdata, id=id, istate=istate)
dim(tfit)
summary(tfit)
@
The resulting object \code{tfit} contains an estimate of $P$(state),
the probability of being in each state at each time $t$.
$P$ is a matrix with one row for each time and one column for
each of the four states a--c and ``still in the starting state''.
By definition each row of $P$ sums to 1. 
We will also use the notation $p(t)$ where $p$ is a vector with one element
per state and $p_j(t)$ is the fraction in state $j$ at time $t$.
The plot below shows all 4 curves.
(Since they sum to 1 one of the 4 curves is redundant, often the entry state
is omitted since it is the least interesting.)  In the \code{plot.survfit} function there is the argument \code{noplot="(s0)"} which indicates that labels with this curve will not be plotted.  If we had not specified \code{istate} in the call to \code{survfit}, the default label for the initial state would have been ``s0'' and the first curve would not have been plotted.

<<fig=TRUE>>=
plot(tfit, col=1:4, lty=:4, lwd=2, ylab="Probability in state")
@ 

The resulting \code{survfms} object appears as a matrix and can be
subscripted as such, with a column for each state and rows for each
group corresponding to variables on the right hand side of the formula.
This makes it simple to display a subset of the curves using plot
or lines commands.
The entry state in the above fit, for instance, can be displayed with
\code{plot(tfit[,1])}.

<<>>=
dim(tfit)
tfit$states
@

The curves are computed using the Aalen-Johansen estimator. 
This is an important concept, and so we work it out below.

1. The starting point is the column vector
      $p(0) = (1, 0, 0, 0)$, everyone starts in the first state.
    
2. At time 1, the first event time, form the 4 by 4 transition matrix $T_1$
\begin{align*}
 T(1)  &= \left( \begin{array}{cccc}
             10/11 & 1/11 & 0/11 & 0/11 \\
              0    & 1    &  0   & 0    \\
              0    & 0    &  1   & 0    \\
              0    & 0    &  0   & 1 \end{array} \right )
 p(1) &= p(0)T_1
 \end{align*}

The first row of $T(1)$ describes the disposition of everyone who is 
in state 1 and under observation at time 1: 10/11 stay in state 1 and 
1 subject transitions to state a.  
There is no one in the other 3 states, so rows 2--4 are technically
undefined; use a default ``stay in the same state'' row which has 1 on
the diagonal.
(Since no one ever leaves states a, b, or c, the bottom three rows of $T$ will 
continue to have this form.)

3. At time 2 the first row will be (9/10, 0, 1/10, 0), and
$p(2) = p(1)T(2) = p(0) T(1) T(2)$.

Continue this until the last event time.  
At a time point with only censoring, such as time 4, $T$ would be the identity
matrix.  

It is straightforward to show that when there are only two states of
alive -> dead, then $p_1(t)$ from the Aalen-Johansen estimate replicates 
the Kaplan-Meier computation.  
For competing risks data such as the simple example above, $p(t)$ replicates
the cumulative incidence (CI) estimator.
The KM and CI are both special cases.  
The AJ is more general, however; a given subject can have multiple 
transitions from state to state, including transitions to a state that was 
visited earlier.


\subsection{Monoclonal gammopathy}
\label{mgusplot}
The \code{mgus2} data set contains information of 1384 subjects who were
who were found to have a particular pattern on a laboratory test
(monoclonal gammopathy of undetermined significance or MGUS).
The genesis of the study was a suspicion that such a result might indicate a
predisposition to plasma cell malignancies such a multiple myeloma;
subjects were followed forward to assess whether an excess did occur.
The mean age at diagnosis is 63 years, so death from other causes will be
an important competing risk.
Here are a few observations of the data set, one of which experienced
progression to a plasma cell malignancy.
<<mgus1>>=
mgus2[55:59, -(4:7)]
@ 

To generate competing risk curves create a new (etime, event) pair.

<<mgus2, fig=TRUE>>=
event <- with(mgus2, ifelse(pstat==1, 1, 2*death))
event <- factor(event, 0:2, c("censored", "progression", "death"))
etime <- with(mgus2, ifelse(pstat==1, ptime, futime))
crfit <- survfit(Surv(etime, event) ~ sex, mgus2)
crfit

plot(crfit, col=1:2, lty=c(3,3,2,2,1,1), lwd=2,noplot="", xscale=12,
     xlab="Years post diagnosis", ylab="P(state)")
legend(240, .65, c("Female, death", "Male, death", "malignancy", "(s0)"),
       lty=c(1,1,2,3), col=c(1,2,1,1), bty='n', lwd=2)
@ 

There are 3 curves for females, one for each of the three states, and
3 for males. 
The three curves sum to 1 at any given time (everyone has to be somewhere),
and the default action for \code{plot.survfit} is to leave out the
``still in original state'' curve (s0) since it is usually the least
interesting, but in this case we have shown all 3.
We will return to this example when exploring models.

A common mistake with competing risks is to use the Kaplan-Meier
separately on each
event type while treating other event types as censored.
The next plot is an example of this for the PCM endpoint.
<<mgus3, fig=TRUE>>=
pcmbad <- survfit(Surv(etime, pstat) ~ sex, data=mgus2)
plot(pcmbad[2], mark.time=FALSE, lwd=2, fun="event", conf.int=FALSE, xscale=12,
     xlab="Years post diagnosis", ylab="Fraction with PCM")
lines(crfit[2,2], lty=2, lwd=2, mark.time=FALSE, conf.int=FALSE)
legend(0, .25, c("Males, PCM, incorrect curve", "Males, PCM, competing risk"),
       col=1, lwd=2, lty=c(1,2), bty='n')
@ 

There are two problems with the \code{pcmbad} fit.  
The first is that it attempts to estimate the expected occurrence of
plasma cell malignancy (PCM)
if all other causes of death were to be disallowed.
In this hypothetical world it is indeed true that many more subjects would
progress to PCM (the incorrect curve is higher), but it is also 
not a world that any of us will ever inhabit.
This author views the result in much the same light as  a discussion of
survival after the zombie apocalypse.
The second problem is that the computation for this
hypothetical case is only correct if all of the competing endpoints
are independent, a situation which is almost never true.
We thus have an unreliable estimate of an uninteresting quantity.
The competing risks curve, on the other hand,
estimates the fraction of MGUS subjects who \emph{will experience} 
PCM, a quantity sometimes known as the lifetime risk,
and one which is actually observable.

The last example chose to plot only a subset of the curves, something that is
often desirable in competing risks problems to avoid a
``tangle of yarn'' plot that simply has too many elements.
This is done by subscripting the \code{survfit} object.
For subscripting, multi-state curves behave as a matrix
with the outcomes as the second subscript. 
The columns are in order of the levels of \code{event},
i.e., as displayed by our earlier call to \code{table(event)}.   
The first subscript indexes the groups formed by the right hand side of
the model formula, and will be in the same order as simple survival curves.
Thus \code{mfit2[2,2]} corresponds to males (2) and the PCM endpoint (2).
Curves are listed and plotted in the usual matrix order of R.

<<>>=
dim(crfit)
crfit$strata
crfit$states
@

One surprising aspect of multi-state data is that hazards can be estimated
independently although probabilities cannot.
If you look at the cumulative hazard estimate from the \code{pcmbad}
fit above using, for instance, \code{plot(pcmbac, cumhaz=TRUE)} you will
find that it is identical to the estimate from the joint fit.
This will arise again with Cox models.  

\section{Multi-state data}
The most general multi-state data will have multiple outcomes and
multiple endpoints per subject.
In this case, we will need to use the (time1, time2) form for each subject.
The dataset structure is similar to that for time varying
covariates in a Cox model: the time variable will be intervals $(t_1, t_2]$
which are open on the left and closed on the right,
and a given subject will have multiple lines of data.
But instead of covariates changing from line to line, in this
case the status variable changes; it
contains the state that was entered at time $t_2$.
There are a few restrictions.
\begin{itemize} 
  \item An identifier variable is needed to indicate which rows of the
    dataframe belong to each subject.  If the \code{id} argument is missing,
    the code assumes that each row of data is a separate subject, which leads
    to a nonsense estimate when there are actually multiple rows per subject. 
  \item Subjects do not have to enter at time 0 or all at the same time,
    but each must traverse a connected segment of time.  Disjoint intervals
    such as the pair $(0,5]$, $(8, 10]$ are illegal.
   \item A subject cannot change groups.  Any covariates on the right hand
     side of the formula must remain constant within subject.  (This 
     function is not
     a way to create supposed `time-dependent' survival curves.)
   \item Subjects may have case weights, and these weights may change over
     time for a subject.
\end{itemize}

The \code{istate} argument can be used to designate a subject's state 
at the start of each $t_1, t_2$ time interval.
Like variables in the formula, it is searched for in the
\code{data} argument.
If it is not present,
every subject is assumed to start in a common entry state which is given
the name ``(s0)''.  The parentheses are an echo of ``(Intercept)'' in a
linear model and show a label that was provided by the program rather than
the data.
The distribution of states just prior to the first event time is 
treated as the initial distribution of states.
In common with ordinary survival, any observation which is censored before the 
first event time has no impact on the results.


\subsection{Myeloid data}
The \code{myeloid} data set contains data from a clinical trial
in subjects with  acute myeloid leukemia.  To protect patient confidentiality
the data set in the survival package has slightly perturbed, but 
results are essentially unchanged.
In this comparison of two conditioning regimens, the
canonical path for a subject is initial therapy $\rightarrow$
complete response (CR) $\rightarrow$
hematologic stem cell transplant (SCT) $\rightarrow$
sustained remission, followed by relapse or death.
Not everyone follows this ideal path, of course.

<<overall>>=
myeloid[1:5,]
@ 
The first few rows of data are shown above.
The data set contains the follow-up time and status at last follow-up 
for each subject, along with the time to transplant
(txtime),
complete response (crtime) or relapse after CR (rltime).
Subject 1 did not receive a transplant, as shown by the NA value,
and subject 2 did not achieve CR.

\begin{figure}
  \myfig{sfit0}
  \caption{Overall survival curves for the two treatments.}
  \label{sfit0}
\end{figure}

Overall survival curves for the data are shown in figure \ref{sfit0}.
The difference between the treatment arms A and B
is substantial.  A goal of this analysis is to better 
understand this difference.  Code to generate the 
two curves is below.

<<sfit0, echo=TRUE, fig=TRUE, include=FALSE>>=
sfit0 <- survfit(Surv(futime, death) ~ trt, myeloid)
plot(sfit0, xscale=365.25, xaxs='r', col=1:2, lwd=2,
     xlab="Years post enrollment", ylab="Survival")
legend(20, .4, c("Arm A", "Arm B"),
       col=1:2, lwd=2, bty='n')
@ 

The full multi-state data set can be created with the 
\code{tmerge} routine.
<<sfit0a, echo=TRUE>>=
mdata <- tmerge(myeloid[,1:2], myeloid,  id=id,  death= event(futime, death),
                sct = event(txtime), cr = event(crtime), 
                relapse = event(rltime))
temp <- with(mdata, cr + 2*sct  + 4*relapse + 8*death)
table(temp)
@ 

Our check shows that there is one subject who had CR and stem cell transplant
on the same day (temp=3).
To avoid length 0 intervals, we break the tie so that complete response (CR)
happens first.
(Students may be surprised to see anomalies like this, since they never appear
in textbook data.  In real data such issues always appear.)

<<sfit0b, echo=TRUE>>=
tdata <- myeloid
tied <- with(tdata, (!is.na(crtime) & !is.na(txtime) & crtime==txtime))
tdata$crtime[tied] <- tdata$crtime[tied] -1
mdata <- tmerge(tdata[,1:2], tdata,  id=id,  death= event(futime, death),
                sct = event(txtime), cr = event(crtime), 
                relapse = event(rltime),
                priorcr = tdc(crtime), priortx = tdc(txtime))
temp <- with(mdata, cr + 2*sct  + 4*relapse + 8*death)
table(temp)
mdata$event <- factor(temp, c(0,1,2,4,8),
                       c("none", "CR", "SCT", "relapse", "death"))

mdata[1:7, c("id", "trt", "tstart", "tstop", "event", "priorcr", "priortx")]
@ 

Subject 1 has a CR on day 44, relapse on day 113, death on day 235 and
did not receive a stem cell transplant. 
The data for the first three subjects looks good.  
Check it out a little more thoroughly.

<<>>=
survcheck(Surv(tstart, tstop, event) ~1, mdata, id=id)
@ 

The second table shows that no single subject had more than one CR, SCT,
relapse, or death, which is the intention.  Several subjects visited all
four intermediate states.  
The transitions table shows 11 subject who achieved CR \emph{after} stem
cell transplant and another 106 who received a transplant before
achieving CR, both of which are deviations from the ``ideal'' pathway.
No subjects went from death to another state (which is good).

For investigating the data we would like to add a set of alternate endpoints.
\begin{enumerate}
  \item The competing risk of CR and death, ignoring other states.  This
    is used to estimate the fraction who ever achieved a complete response.
  \item The competing risk of SCT and death, ignoring other states.
  \item An endpoint that distinguishes death after SCT from death 
    before SCT.
\end{enumerate}
Each of these can be accomplished by adding further outcome variables to 
the data set, we will not need to change the time intervals.

<<newevent>>=
levels(mdata$event)
temp1        <- with(mdata, ifelse(priorcr, 0, c(0,1,0,0,2)[event]))
mdata$crstat <- factor(temp1, 0:2, c("none", "CR", "death"))

temp2        <- with(mdata, ifelse(priortx, 0, c(0,0,1,0,2)[event]))
mdata$txstat <- factor(temp2, 0:2, c("censor", "SCT", "death"))

temp3     <- with(mdata, c(0,0,1,0,2)[event] + priortx)
mdata$tx2 <- factor(temp3, 0:3,
                    c("censor", "SCT", "death w/o SCT", "death after SCT"))
@ 

Notice the use of the \code{priorcr} variable in defining \code{crstat}.
This outcome variable treats complete response as a terminal state,
which in turn means that no further transitions are allowed after
reaching CR.  

\begin{figure}
  \myfig{curve1}
  \caption{Overall survival curves: time to death, to transplant (Tx), 
    and to complete response (CR).
    Each shows the estimated fraction of subjects who have ever reached the
    given state.  The vertical line at 2 months is for reference.
    The curves were limited to the first 48 months to more clearly show 
    early events. The right hand panel shows the state-space model for each
  pair of curves.}
  \label{curve1}
\end{figure}

This data set is the basis for our first set of curves, which are shown in
figure \ref{curve1}.
The plot overlays three separate \code{survfit} calls: standard survival
until death, complete response with death as a competing risk, and
transplant with death as a competing risk.
For each fit we have shown one selected state: the fraction
who have died, fraction ever in CR, and fraction ever to receive transplant,
respectively.
Most of the CR events happen before 2 months (the green
vertical line) and nearly all the additional CRs
conferred by treatment B occur between months 2 and 8.  
Most transplants happen after 2 months, which is consistent with the
clinical guide of transplant after CR.
The survival advantage for treatment B begins between 4 and 6 months, 
which argues that it could be at least partially a consequence of the
additional CR events.

The code to draw figure \ref{curve1} is below.  It can be separated into
5 parts:
\begin{enumerate}
  \item Fits for the 3 endpoints are simple and found in the first set of lines.
    The \code{crstat} and \code{txstat} variables are factors, which causes
    multi-state curves to be generated.
  \item The \code{layout} and \code{par} commands are used to create a
    multi-part plot with curves on the left and state space diagrams on 
    the right, and to reduce the amount of white space between them.
  \item Draw a subset of the curves via subscripting. A multi-state
    survfit object appears to the user as a matrix of curves, with one row for
    each group (treatment) and one column for each state.  The CR state is
    the second column in \code{sfit2}, for instance.  
    The CR fit was drawn first simply because it has the greatest y-axis
    range, then the other curves added using the lines command.
  \item Decoration of the plots. This includes the line types, colors,
    legend, choice of x-axis labels, etc.
  \item Add the state space diagrams.  The functions for this are
    described elsewhere in the vignette.
\end{enumerate}

<<curve1, fig=TRUE, include=FALSE>>=
# I want to have the plots in months, it is simpler to fix time
#  once rather than repeat xscale many times
tdata$futime <- tdata$futime * 12 /365.25
mdata$tstart <- mdata$tstart * 12 /365.25
mdata$tstop  <- mdata$tstop * 12 /365.25


sfit1 <- survfit(Surv(futime, death)  ~ trt, tdata) # survival
sfit2 <- survfit(Surv(tstart, tstop, crstat) ~ trt, 
                 data= mdata, id = id) # CR
sfit3 <- survfit(Surv(tstart, tstop, txstat) ~ trt, 
                 data= mdata, id =id) # SCT

layout(matrix(c(1,1,1,2,3,4), 3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))

mlim   <- c(0, 48) # and only show the first 4 years
plot(sfit2[,"CR"], xlim=mlim, 
         lty=3, lwd=2, col=1:2, xaxt='n',
     xlab="Months post enrollment", ylab="Fraction with the endpoint")
lines(sfit1, mark.time=FALSE, xlim=mlim,
      fun='event', col=1:2, lwd=2)

lines(sfit3[,"SCT"], xlim=mlim, col=1:2, 
          lty=2, lwd=2)

xtime <- c(0, 6, 12, 24, 36, 48)
axis(1, xtime, xtime) #axis marks every year rather than 10 months
temp <- outer(c("A", "B"), c("CR", "transplant", "death"),  paste)
temp[7] <- ""
legend(25, .3, temp[c(1,2,7,3,4,7,5,6,7)], lty=c(3,3,3, 2,2,2 ,1,1,1),
       col=c(1,2,0), bty='n', lwd=2)
abline(v=2, lty=2, col=3)

# add the state space diagrams
par(mar=c(4,.1,1,1))
crisk(c("Entry", "CR", "Death"), alty=3)
crisk(c("Entry", "Tx", "Death"), alty=2)
crisk(c("Entry","Death"))
par(oldpar)
layout(1)
@ 

The association between a particular curve and its corresponding state space
diagram is critical.  As we will see below, many different models are
possible and it is easy to get confused.  
Attachment of a diagram directly to each curve, as was done above,
will not necessarily be day-to-day practice, but the state space should
always be foremost.  If nothing else,  draw it on a scrap of paper and tape it 
to the side of the terminal when creating a data set and plots.

\begin{figure}
  \myfig{badfit}
 \caption{Correct (solid) and invalid (dashed) estimates of the number
  of subjects transplanted.}
 \label{badfit}
\end{figure}
 
Figure \ref{badfit} shows the transplant curves overlaid with the naive KM that
censors subjects at death.  There is no difference in the initial portion as
no deaths have yet intervened, but the final portion overstates the 
transplant outcome by more than 10\%. 
\begin{enumerate}
  \item The key problem with the naive estimate is that subjects who die can 
    never have a transplant.  The result of censoring them 
    is an estimate of the ``fraction who would
    be transplanted, if death before transplant were abolished''.  This is not
    a real world quantity.
  \item In order to estimate this fictional quantity one needs to assume that
    death is uninformative with respect to future disease progression.  The
    early deaths in months 0--2, before transplant begins, are however a very
    different class of patient.  Non-informative censoring is untenable.
\end{enumerate}
We are left with an unreliable estimate of an uninteresting quantity.
Mislabeling any true state as censoring is always a mistake, one that 
will not be repeated here.
Here is the code for figure \ref{badfit}.  The use of a logical (true/false)
as the status variable in the \code{Surv} call leads to ordinary survival
calculations.
<<badfit, fig=TRUE, include=FALSE>>=
badfit <- survfit(Surv(tstart, tstop, event=="SCT") ~ trt, 
                       id=id, mdata, subset=(priortx==0))

layout(matrix(c(1,1,1,2,3,4), 3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))
plot(badfit, fun="event", xmax=48, xaxt='n', col=1:2, lty=2, lwd=2,
     xlab="Months from enrollment", ylab="P(state)")
axis(1, xtime, xtime)
lines(sfit3[,2], xmax=48, col=1:2, lwd=2)
legend(24, .3, c("Arm A", "Arm B"), lty=1, lwd=2,
       col=1:2, bty='n', cex=1.2)

par(mar=c(4,.1,1,1))
crisk(c("Entry", "transplant"), alty=2, cex=1.2)
crisk(c("Entry","transplant", "Death"), cex=1.2)
par(oldpar)
layout(1)
@ 

\begin{figure}
  \myfig{cr2}
  \caption{Models for `ever in CR' and `currently in CR';
    the only difference is an additional transition.
    Both models ignore transplant.}
  \label{cr2}
\end{figure}

Complete response is a goal of the initial therapy; figure \ref{cr2}
looks more closely at this.
As was noted before arm B has an increased number of late responses.
The duration of response is also increased: 
the solid curves show the number of subjects still in response, and
we see that they spread farther apart than the dotted ``ever in response''
curves. 
The figure shows only the first eight months in order to better visualize
the details, but continuing the curves out to 48 months reveals a similar
pattern.
Here is the code to create the figure.

<<cr2, fig=TRUE, include=FALSE>>=
cr2 <- mdata$event
cr2[cr2=="SCT"] <- "none" # ignore transplants
crsurv <- survfit(Surv(tstart, tstop, cr2) ~ trt,
                  data= mdata, id=id, influence=TRUE)

layout(matrix(c(1,1,2,3), 2,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1.1, .1))
plot(sfit2[,2], lty=3, lwd=2, col=1:2, xmax=12, 
     xlab="Months", ylab="CR")
lines(crsurv[,2], lty=1, lwd=2, col=1:2)
par(mar=c(4, .1, 1, 1))
crisk( c("Entry","CR", "Death"), alty=3)
state3(c("Entry", "CR", "Death/Relapse"))

par(oldpar)
layout(1)
@ 

The above code created yet another event
variable so as to ignore transitions to the transplant state.
They become a non-event, in the same way that extra lines with
a status of zero are used to create time-dependent covariates for
a Cox model fit.

The \code{survfit} call above included the \code{influence=TRUE}
argument, which causes the influence array to be calculated and
returned.  
It contains, for each subject, that subject's influence on the
time by state matrix of results and allows for calculation of the
standard error of the restricted mean.  We will return to this
in a later section.
<<cr2b>>=
print(crsurv, rmean=48, digits=2)
@ 

<<cr2c, echo=FALSE>>=
temp <- summary(crsurv, rmean=48)$table
delta <- round(temp[4,3] - temp[3,3], 2)
@ 

@ 
The restricted mean time in the CR state is extended by 
\Sexpr{round(temp[4,3], 1)} - \Sexpr{round(temp[3,3], 1)} =
\Sexpr{delta} months.  
A question which immediately gets asked is whether this difference
is ``significant'', to which there are two answers. 
The first and more important is to ask whether 5 months is an important gain
from either a clinical or patient perspective. 
The overall restricted mean survival for the study is approximately
30 of the first 48 months post entry (use \code{print(sfit1, rmean=48)});
on this backdrop an extra 5 months in CR might or might not be an
meaningful advantage from a patient's point of view.
The less important answer is to test whether the apparent gain is sufficiently
rare from a mathematical point of view, i.e., ``statistical'' significance.
The standard errors of the two values are
\Sexpr{round(temp[3,4],1)} and \Sexpr{round(temp[4,4],1)},
and since they are based
on disjoint subjects the values are independent, leading to a standard error
for the difference of $\sqrt{1.1^2 + 1.2^2} = 1.6$.
The 5 month difference is over 3 standard errors.

\begin{figure}
  \myfig{txsurv}
  \caption{Transplant status of the subjects, broken down by whether it
    occurred before or after CR.}
  \label{txsurv}
\end{figure}

In summary
  \begin{itemize}
    \item Arm B adds late complete responses (about 4\%); there are 
      206/317 in arm B vs. 248/329 in arm B.
    \item The difference in 4 year survival is about 6\%.
    \item There is approximately 2 months longer average duration of CR (of 48).
  \end{itemize}

CR $\rightarrow$ transplant is the target treatment path for a
patient; given the improvements listed above
why does figure \ref{curve1} show no change in the number transplanted?
Figure \ref{txsurv} shows the transplants broken down by whether this
happened before or after complete response.
Most of the non-CR transplants happen by 10 months.
One possible explanation is that once it is apparent to the
patient/physician pair that CR is not going to occur, they proceed forward with
other treatment options.  
The extra CR events on arm B, which occur between 2 and 8 months, lead to 
a consequent increase in transplant as well, but at a later time of 12--24 
months: for a subject in CR we can perhaps afford to defer the transplant date.

Computation is again based on a manipulation of the event variable: in this
case dividing the transplant state into two sub-states based on the presence
of a prior CR.  The code makes use of the time-dependent covariate 
\code{priorcr}.
(Because of scheduling constraints within a hospital it is unlikely that
a CR that is within a few days prior to transplant could have effected the
decision to schedule a transplant, however.  An alternate breakdown that
might be useful would be ``transplant without CR or within 7 days after CR''
versus those that are more than a week later. 
There are many sensible questions that can be asked.)

<<txsurv, fig=TRUE, include=FALSE>>=
event2 <- with(mdata, ifelse(event=="SCT" & priorcr==1, 6,
               as.numeric(event)))
event2 <- factor(event2, 1:6, c(levels(mdata$event), "SCT after CR"))
txsurv <- survfit(Surv(tstart, tstop, event2) ~ trt, mdata, id=id,
                  subset=(priortx ==0))
dim(txsurv) # number of strata by number of states
txsurv$states # Names of states

layout(matrix(c(1,1,1,2,2,0),3,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1,.1))
plot(txsurv[,c(3,6)], col=1:2, lty=c(1,1,2,2), lwd=2, xmax=48,
     xaxt='n', xlab="Months", ylab="Transplanted")
axis(1, xtime, xtime)
legend(15, .13, c("A, transplant without CR", "B, transplant without CR",
                 "A, transplant after CR", "B, transplant after CR"),
       col=1:2, lty=c(1,1,2,2), lwd=2, bty='n')
state4()  # add the state figure
par(oldpar)
@ 

\begin{figure}
  \myfig{sfit4}
  \caption{The full multi-state curves for the two treatment arms.}
  \label{sfit4}
\end{figure}

Figure \ref{sfit4} shows the full set of state occupancy probabilities for the
cohort over the first 4 years.  At each point in time the curves
estimate the fraction of subjects currently in that state.
 The total who are in the transplant state peaks at
about 9 months and then decreases as subjects relapse or die; 
the curve rises
whenever someone receives a transplant and goes down whenever someone
leaves the state.
At 36 months treatment arm B (dashed) has a lower fraction who have died,
the survivors are about evenly split between those who have received a
transplant and those whose last state is a complete response
(only a few of the latter are post transplant). 
The fraction currently in relapse -- a transient state -- is about 5\% for
each arm.
The figure omits the curve for ``still in the entry state''.
The reason is that 
at any point in time the sum of the 5 possible states is 1 ---
everyone has to be somewhere.  Thus one of the curves
is redundant, and the fraction still in the entry state is the least 
interesting of them.
(A multi-state \code{survfit} call that does not include the \code{istate}
argument will assume that everyone starts in an unnamed entry state.
The default plot behavior is to omit the curves for any unnamed states.)


<<sfit4, fig=TRUE, include=FALSE>>=
sfit4 <- survfit(Surv(tstart, tstop, event) ~ trt, mdata, id=id)
sfit4$transitions
layout(matrix(1:2,1,2), widths=2:1)
oldpar <- par(mar=c(5.1, 4.1, 1,.1))
plot(sfit4, col=rep(1:4,each=2), lwd=2, lty=1:2, xmax=48, xaxt='n',
     xlab="Months", ylab="Current state")
axis(1, xtime, xtime)
text(c(40, 40, 40, 40), c(.51, .13, .32, .01),
     c("Death", "CR", "Transplant", "Recurrence"), col=c(4,1,2,3))

par(mar=c(5.1, .1, 1, .1))
state5()
par(oldpar)
@ 

The transitions table above shows \Sexpr{sfit4$transitions[1,4]} %$ 
direct transitions from entry to death, i.e., 
subjects who die without experiencing any of the other intermediate points,
\Sexpr{sfit4$transitions[2,2]} who go from CR to transplant (as expected),
\Sexpr{sfit4$transitions[3,1]} who go from transplant to CR, etc. %$
No one was observed to go from relapse to CR in the data set, this
serves as a data check since it should not be possible per the data entry plan.

\section{Influence matrix}

For one of the curves above we returned the influence array.
For each value in the matrix $P$ = probability in state and each subject
$i$ in the data set, this contains the effect of that subject on each
value in $P$.  Formally,
\begin{equation*}
  D_{ij}(t) = \left . \frac{\partial p_j(t)}{\partial w_i} \right|_w
\end{equation*}
where $D_{ij}(t)$ is the influence of subject $i$ on $p_j(t)$, and
$p_j(t)$ is the estimated probability for state $j$ at time $t$.
This is known as the infinitesimal jackknife (among other labels).
<<reprise>>=
crsurv <- survfit(Surv(tstart, tstop, cr2) ~ trt,
                  data= mdata, id=id, influence=TRUE)
curveA <- crsurv[1,]  # select treatment A

dim(curveA)    # P matrix for treatement A
curveA$states
dim(curveA$pstate)  # 426 time points, 5 states
dim(curveA$influence) # influence matrix for treatment A
table(myeloid$trt)
@

For treatment arm A there are \Sexpr{table(myeloid$trt)[1]} subjects and
\Sexpr{dim(curveA$pstate)[1]} time points in the $P$ matrix.
The influence array has subject as the first dimension, and for each
subject it has an image of the $P$ matrix containing that subject's
influence on each value in $P$, i.e.,
\code{influence[1, ,]} is the influence of subject 1 on $P$.
For this data set everyone starts in the entry state, so $p(0)$ = the
first row of \code{pstate} will be (1, 0, 0, 0, 0) and the influence of
each subject on this row is 0;
this does not hold if not all subjects start in the same state.

As an exercise we will calculate the mean time in state out to 48 weeks.
This is the area under the individual curves from time 0 to 48.  Since
the curves are step functions this is simple sum of rectangles, treating
any intervals after 48 months as having 0 width.
<<meantime>>=
t48 <- pmin(48, curveA$time)   
delta <- diff(c(t48, 48))  # width of intervals
rfun <- function(pmat, delta) colSums(pmat * delta)  #area under the curve
rmean <- rfun(curveA$pstate, delta)

# Apply the same calculation to each subject's influence slice
inf <- apply(curveA$influence, 1, rfun, delta=delta)
# inf is now a 5 state by 310 subject matrix, containing the IJ estimates
#  on the AUC or mean time.  The sum of squares is a variance.
se.rmean <- sqrt(rowSums(inf^2))
round(rbind(rmean, se.rmean), 2)

print(curveA, rmean=48, digits=2)
@ 

The last lines verify that this is exactly the calculation done by the
\code{print.survfitms} function; the results can also be found in
the \code{table} component returned by \code{summary.survfitms}.

In general, let $U_i$ be the influence of subject $i$.
For some function $f(P)$ of the probability in state matrix \code{pstate}, 
the influence of subject
$i$ will be $\delta_i = f(P + U_i) - f(P)$ and the infinitesimal jackknife
estimate of variance will be $\sum_i \delta^2$.
For the simple case of adding up rectangles $f(P +U_i) - f(P) = f(U_i)$ leading
to particularly simple code, but this will not always be the case.  

\section{State space figures}
\label{sect:statefig}
The state space figures in the above example were drawn with a simple
utility function \code{statefig}.  It has two primary arguments along with
standard graphical options of color, line type, etc.
\begin{enumerate}
  \item A layout vector or matrix.  A vector with values of (1, 3, 1)
    for instance will allocate one state, then a column with 3 states, then
    one more state, proceeding from left to right.  A matrix with a single
    row will do the same, whereas a matrix with one column will proceed
    from top to bottom.
  \item A $k$ by $k$ connection matrix $C$ where $k$ is the number of states.
    If $C_{ij} \ne 0$ then an arrow is drawn from state $i$ to state $j$.
    The row or column names of the matrix are used to label the states.
    The lines connecting the states can be straight or curved, see the
    help file for an example.
\end{enumerate}
 
The first few state space diagrams were competing risk models, which use
the following helper function.  It accepts a vector of state names,
where the first name is the starting state and the remainder are the
possible outcomes.
<<crisk>>=
crisk <- function(what, horizontal = TRUE, ...) {
    nstate <- length(what)
    connect <- matrix(0, nstate, nstate,
                      dimnames=list(what, what))
    connect[1,-1] <- 1  # an arrow from state 1 to each of the others
    if (horizontal) statefig(c(1, nstate-1),  connect, ...)
    else statefig(matrix(c(1, nstate-1), ncol=1), connect, ...)
}
@ 

This next function draws a variation of the illness-death model.
It has an initial state,  
an absorbing state (normally death), and an optional intermediate state.
<<state3>>=
state3 <- function(what, horizontal=TRUE, ...) {
    if (length(what) != 3) stop("Should be 3 states")
    connect <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3,3,
                      dimnames=list(what, what))
    if (horizontal) statefig(1:2, connect, ...)
    else statefig(matrix(1:2, ncol=1), connect, ...)
}
@ 

The most complex of the state space figures has all 5 states.
<<state5>>=
state5 <- function(what, ...) {
    sname <- c("Entry", "CR", "Tx", "Rel", "Death")
    connect <- matrix(0, 5, 5, dimnames=list(sname, sname))
    connect[1, -1] <- c(1,1,1, 1.4)
    connect[2, 3:5] <- c(1, 1.4, 1)
    connect[3, c(2,4,5)] <- 1
    connect[4, c(3,5)]  <- 1
    statefig(matrix(c(1,3,1)), connect, cex=.8, ...)
}
@ 

For figure \ref{txsurv} I want a third row with a single
state, but don't want that state centered.
For this I need to create my own (x,y) coordinate list as
the layout parameter.  Coordinates must be between 0 and 1.
<<state4>>=
state4 <- function() {
    sname <- c("Entry", "CR", "Transplant", "Transplant")
    layout <- cbind(x =c(1/2, 3/4, 1/4, 3/4),
                    y =c(5/6, 1/2, 1/2, 1/6))
    connect <- matrix(0,4,4, dimnames=list(sname, sname))
    connect[1, 2:3] <- 1
    connect[2,4] <- 1
    statefig(layout, connect)
}
@

The statefig function was written to do ``good enough'' state space figures
quickly and easily, in the hope that users will find it simple enough that
diagrams are drawn early and often.
Packages designed for directed acyclic graphs (DAG) such as diagram, DiagrammeR,
 or dagR are far more flexible
and can create more nuanced and well decorated results.

\subsection{Further notes}
The Aalen-Johansen method used by \code{survfit} does not account for 
interval censoring, also known as panel data, 
where a subject's current state is recorded at some fixed time such as a
medical center visit but the actual times of transitions are unknown.
Such data requires further assumptions about the transition process in
order to model the outcomes and has a more complex likelihood. 
The \code{msm} package, for instance, deals with data of this type.
If subjects reliably come in at regular intervals then the 
difference between the two results can be small, e.g., the 
\code{msm} routine estimates time until progression \emph{occurred}
whereas \code{survfit} estimates time until progression was \emph{observed}.

\begin{itemize}
  \item When using multi-state data to create Aalen-Johansen estimates, 
    individuals
    are not allowed to have gaps in the middle of their time line.
    An example of this would be a data set with 
    (0, 30, pcm] and (50,70, death] as the two observations
    for a subject where the time from 30-70 is not accounted for.
  \item Subjects must stay in the same group over their entire observation
    time, i.e., variables on the right hand side of the equation cannot be
    time-dependent. 
  \item A transition to the same state is allowed, e.g., observations of
    (0,50, 1], (50, 75, 3], (75, 89, 4], (89, 93, 4] and (93, 100, 4] 
    for a subject who goes
    from entry to state 1, then to state 3, and finally to state 4.
    However, a warning message is issued for the data set in this case, since
    stuttering may instead be the result of a coding mistake.
    The same result is obtained if 
    the last three observations were collapsed to a single row of 
    (75, 100, 4].
\end{itemize}

%--------------------------------------------------------

\chapter{A menagerie of models}
For modeling survival data the package includes several choices, which can 
be broken up into \emph{hazard} and \emph{direct} models for the data.
Let $x_1, x_2, \ldots$ be a set of covariates or predictors.

Direct models model the survival time directly as
\begin{equation*}
  E(t) = f(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots)
\end{equation*}
for some link function $f$.
These models are fit using the \code{survreg} function, which will be covered
in chapter \ref{chap:aft}.

Hazard models model the rate or hazard of transition between
states and include 3 models.

Exponential (or Poisson) models
\begin{equation*}
 \lambda(t) = \exp(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots) 
\end{equation*}
These can be fit using the \code{glm} command in base R, after proper data
set up.  
For example, here is a simple fit to the aml data set.
<<lungglim>>=
gfit <- glm(status ~ x + offset(log(time)), family=poisson, data=aml)
summary(gfit)
@ 
 
The subjects who did not receive maintenance therapy have a 2.5 fold
higher death rate.
In this model the response is the number of events for a subject, so the
model can
be applied to multiple outcome data as well.
The \code{offset} term is based on the fact that for a Poisson response
E(number of events) = rate * time = exp(log(rate) + log(time)).
We are using $\beta x$ to model the log rate and so log(time) appears in the
model as an \emph{offset}, a covariate with known coefficient of 1.

The proportional hazards or Cox model allows an semi-parametric intercept
\begin{align*}
  \lambda(t) &= \exp(\beta_0(t) + \beta_1 x_1 + \beta_2 x_2 + \ldots) \\
             &= \lambda_0(t) \exp(\beta_1 x_1 + \beta_2 x_2 + \ldots)
\end{align*}
where $\lambda_0$ is referred to as the baseline hazard.
The literature is about evenly split between using
$\lambda$, $h$ and $\alpha$ as the symbol for the baseline hazard;
we will use $\lambda$ but there is no compelling argument for one versus
another.
The Cox model will be covered in chapter \ref{chap:PH}.

The Aalen additive regression model is 
\begin{align*}
   \lambda(t) = \beta_0(t) + \beta_1(t) x_1 + \beta_2(t) x_2 + \ldots
\end{align*}
The model is more complex than the Cox model --- all of the coefficients
are time dependent --- but it also has important advantages.
These models can be fit using the \code{aareg} function in the survival
package.
The \code{timereg} package has surpassed the \code{aareg} function in every
way, however, and users of the Aalen model should direct their 
attention there.  

There are, I think, three keys to a successful statistical
model, and each of the above attempts to strike a balance
between them.  A good model
\begin{enumerate}
  \item provides a simplified summary of the effects
  \item executes reliably
  \item is a \emph{good enough} summary of the biology
\end{enumerate}

For all of the above, the first of these is addressed by using 
a linear predictor $\beta_1 x_1 + \beta_2 x_2 + \ldots$ for the covariates.
This allows us make statements about the covariate effects singly, e.g.
``the effect of treatment is a \underline{\phantom{abc}}'', ignoring the
others.
The second criterion is practical --- programs that sometimes fail, 
or that require 
starting estimates or per dataset tuning do not get used in day to day work.
The last criterion is that the model needs to capture the true biology
sufficiently well that the result can act as a basis for 
action.   
The joint action of the first and third are well captured by three quotations:

\begin{quotation}
Ce qui est simple est toujours faux. Ce qui ne l'est pas est inutilisable.
(What is simple is always wrong. What is not is unusable.)\\
Paul Val\'{e}ry, 1949

All models are approximations. Assumptions, whether implied or clearly 
stated, are never exactly true. All models are wrong, but some models are 
useful. So the question you need to ask is not ``Is the model true?" (it never 
is) but ``Is the model good enough for this particular application?''\\
G.E.P Box, Statistical Control By Monitoring and Adjustment, 2009.


A model is a lie that helps us see the truth.\\  H. Skipper in The Emperor
of all Maladies, 2011.
\end{quotation}

Box's statement is often compressed down to the third of its 4 sentences, but
is best viewed in full.  


% -----------------------------------------

\chapter{Cox proportional hazard model}
\label{chap:PH}
The Cox model is the single most popular model for time to event data.
Part of this is certainly historical.  It has been said that the
correlation coefficient rose to prominence because R. A. Fisher worked out
the statistical theory at about the same time that desk calculators could
first handle a running sum $\sum x_i y_i$; it was both a simple statistic
and the most complex thing one could do.
The Cox model's relationship to 1970's computing power was much the same. 
The fact that it continues to be used is due, however, to the fact that the
model often provides a very good summary.

We will show the model in four situations
\begin{centering}
 \begin{tabular}{ccc}
 & One outcome per subject & Multiple outcomes per subject \\
One type of outcome & 1 & 2 \\
Multiple types of outcome & 3 & 4
\end{tabular}
\end{centering}
Type 1 is simple or `classic' survival, 2 is repeated events per subject,
3 is exemplified by competing risks, and 4 is the most general.

\section{Single Event}
An example of the classic Cox model can be illustrated using the
lung cancer data set.
This involves subjects with advanced lung cancer, recruited in a set
of multi-institutional trials.

<<lung1>>=
fit1 <- coxph(Surv(time, status) ~ age + sex + ph.ecog, data=lung)
print(fit1, digits=2)   # fewer digits to fit on the page
@ 

The Eastern Cooperative Oncology Group's performance status is a measure
of subject's functional ability ranging from 0= asymptomatic to 4=bedbound,
and is the most powerful predictor of outcome for these patients.

The simplifying aspects of the Cox model that make is so useful are
exactly those that should be verified, namely proportional hazards,
additivity, linearity, and lack of any high leverage points.
The first can be checked with the \code{cox.zph} function.

<<lung2, fig=TRUE>>=
zp1 <- cox.zph(fit1)
zp1
plot(zp1[2], resid=FALSE)
abline(coef(fit1)[2] ,0, lty=3)
@ 

None of the test statistics for PH are remarkable. 
A simple check for linearity of age is to replace the term with a smoothing
spline. 
<<lung3>>=
fit2 <- coxph(Surv(time, status) ~ pspline(age) + sex + ph.ecog, lung)
print(fit2, digits=2)
@ 

ECOG performance score only has 4 levels, one of which occurs for only one 
subject.  A linearity check for this variable is most effectively done
by using a factor.  The resulting coefficients of 0, .4, .9 for the three
categories are again reasonably close to linear.
<<lung3>>=
table(lung$ph.ecog)
fit3 <- coxph(Surv(time, status) ~ age + sex + factor(pmin(ph.ecog,2)),
              data=lung)
print(fit3, digits=2)
@ 

\section{Repeating Events}
Children with chronic granulotomous disease (CGD) are subject to repeated 
infections due to a compromised immune system.  
The \code{cgd0} data set contains results of a clinical trial of gamma
interferon as a treatment, the data set \code{cdg} contains the data
reformatted into a (tstart, tstop, status) form:
each child can have multiple rows which describe an interval of time,
and status=1 if that interval ends with an infection and 0 otherwise.
A model with a single baseline hazard, known as the Andersen-Gill model,
can be fit very simply.
The study recruited subjects from four types of institutions, and there is
an a priori belief that the four classes might recruit a different type
of subject.  Adding the hospital category as a strata allows each group
to have a different shape of baseline hazard.
<<cgd1>>=
cfit1 <- coxph(Surv(tstart, tstop, status) ~ treat + inherit + steroids +
                   age + strata(hos.cat), data=cgd)
print(cfit1, digits=2)
@ 
 
Predicted survival and/or cumulative hazard curves can then be obtained from
the fitted model.  
Prediction requires the user to specifiy \emph{who} to predict; in this case
we will use 4 hypothetical subjects on control/interferon treatment, with and
without prior steroids.  The other two covariates are set to age 12 
(the median age in the study) and X-linked disease.  This creates a data
frame with 4 rows.

<<cgd2, fig=TRUE>>=
dummy <- expand.grid(age=12, inherit='X-linked', 
                     treat=levels(cgd$treat), steroids=0:1)
dummy
csurv <- survfit(cfit1, newdata=dummy)
dim(csurv)

plot(csurv[1,], fun="event", col=1:2, lty=c(1,1,2,2), 
     xlab="Days on study", ylab="Pr( any infection )")
@ 

If the strata variable is included in the \code{newdata} dataframe 
curves will be produced for the selected strata, otherwise the default
is to produce separate curves for each stratum.  
The resulting object was subscripted in order to make a plot with fewer
curves. 
We see that the sterod subjects have a higher risk, and that treatment is
effective.

Perhaps more interesting in this situation is the expected number of
infections, rather than the probability of having at least 1.
The former is estimated by the cumulative hazard, which is also returned
by the \code{survfit} routine.

<<cfit3, fig=TRUE>>=
plot(csurv[1,], cumhaz=TRUE, col=1:2, lty=c(1,1,2,2), lwd=2,
     xlab="Days on study", ylab="E( number of infections )")
legend(20, 5, c("Steroid subject, control", "Steroid subject, gamma interferon",
                "non-steroid, control", "non-steroid, gamma interferon"),
       lty=c(2,2,1,1), col=c(1,2,1,2), lwd=2, bty='n')
@  

\section{Competing risks}
Our third category is models where there is more than one event type, but
each subject can have only one transition.
This is the setup of competing risks.

\subsection{MGUS}
As an simple multi-state example consider the monoclonal gammopathy data
 set \code{mgus2},
which contains the time to a plasma cell malignancy (PCM), usually
multiple myleoma,  and the 
time to death for 1384 subjects found to have a condition known as
monoclonal gammopathy of undetermined significance (MGUS), based on
a particular test.  
This data set has already appeared in \ref{mgusplot}.
The time values in the data set are from detection of the condition.
Here are a subset of the observations along with a simple state figure
for the data.

<<survfit-mgus1, fig=TRUE>>=
mgus2[56:59,]

sname <- c("MGUS", "Malignancy", "Death")
smat <- matrix(c(0,0,0, 1,0,0, 1,1,0), 3, 3, 
               dimnames = list(sname, sname))
statefig(c(1,2), smat)
@ 

In this data set 
subject 56 was diagnosed with a PCM 29 months after detection of MGUS and
died at 44 months. 
This subject passes through all three states.
The other three listed individuals died without a plasma cell malignancy
and traverse one of the arrows;
103 subjects (not shown) are censored before experiencing either event
and spend their entire tenure in the leftmost state.
The competing risks model will ignore the transition from malignacy to death:
the two ending states are ``malignancy before death'' and ``death without
malignancy''.  

The \code{statefig} function is designed to create simple state diagrams,
with an emphasis on ease rather than elegance. 
See more information in section \ref{sect:statefig}.
 
To compute the multi-state survival, we first create a data set with
(begin, end) time intervals using \code{tmerge}.
As is often the case, a closer look at the data uncovered some special
issues: there are 9 subjects whose time to progression is identical to
the death time.
It turns out that these are subjects whose disease was discovered at
autopsy.
The survival code does not allow for time intervals of length zero, 
so a modification needs to be made to the data.
Clearly, these autopsied subjects will have had their 
malignancy for some period of time before death, below we arbitrarily
move the PCM date back by one month.

<<survfit-mgus2>>=
# modified progression time, = -1 month if tied with death
temp <- with(mgus2, ifelse(pstat==0, NA,
                           ifelse(ptime==futime, ptime-1, ptime)))
mdata <- tmerge(mgus2[,1:7], mgus2, id=id, event= event(futime, 2*death),
                event= event(temp))
mdata$event <- factor(mdata$event, 0:2, c("censor", "PCM", "Death"))
mdata[56:59,]
survcheck(Surv(tstart, tstop, event) ~ 1, mdata, id=id)
@ 
 
The short dataset printout shows that subject 56 is represented as two rows,
the first from entry to PCM, with a length of 29 months, and second 
spanning from 29 to 44 months and ending with death.
The transition table from the \code{survcheck} output shows transitions
from the entry state ``()'' to PCM and Death, and from PCM to Death.
\index{function!survcheck}
Importantly, it does not show any transitions from PCM to PCM, which by
the study definition can only occur once, or from Death to some other state.
The table of per subject counts shows 103 subjects who make 2 transitions,
but no one who has multiple PCM or death events.
We are now ready to compute an estimate.

A competing risks analysis will only consider the first event for each
subject, so we first subset the data.
Second, it is good practice to summarize covariates before a fit.
<<cfit1>>=
crdata <- subset(mdata, tstart==0)
quantile(crdata$age, na.rm=TRUE)
table(crdata$sex)
quantile(crdata$mspike, na.rm=TRUE)

cfit <- coxph(Surv(tstart, tstop, event) ~ I(age/10) + sex + mspike, 
              id = id, crdata)
print(cfit, digits=1)  # narrow the printout a bit
@ 
The effect of age and sex on non-PCM mortality is profound, which is not
a surprise given the median starting age of \Sexpr{median(mgus2$age)}. %$
Death rates rise \Sexpr{round(exp(10*coef(cfit)[4]),1)} fold per decade 
of age and
the death rate for males is \Sexpr{round(exp(coef(cfit)[5]),1)} times as great
as that for females.  
The size of the serum monoclonal spike has almost no impact on non-PCM 
mortality.
A 1 unit increase changes mortality by only 2\%.

The mspike size has a major impact on progression, however; each 1 gram
change increases risk by \Sexpr{round(exp(coef(cfit)[3]) ,1)} fold.
The interquartile range of \code{mspike} is 0.9 grams so this risk increase
is clinically important.
The effect of age on the progression rate is much less pronounced,
with a coefficient only 1/4 that for mortality, while the effect of sex
on progression is completely negligible.

Estimates of the probability in state can be simply computed using 
\code{survfit}.
As with any model, estimates are always for a particular set of
covariates.  We will use 4 hypothetical subjects, male and female
with ages of 60 and 80.
<<PCMcurve, fig=TRUE>>=
dummy <- expand.grid(sex=c("F", "M"), age=c(60, 80), mspike=1.2)
csurv  <- survfit(cfit, newdata=dummy)
plot(csurv[,,2], xmax=20*12, xscale=12,
     xlab="Years after MGUS diagnosis", ylab="Pr(has entered PCM state)",
     col=1:2, lty=c(1,1,2,2), lwd=2)
legend(100, .04, outer(c("female,", "male,  "), 
                     c("diagnosis at age 60", "diagnosis at age 80"), 
                      paste),
       col=1:2, lty=c(1,1,2,2), bty='n', lwd=2)
@ 

Although sex has no effect on the \emph{rate} of plasma cell malignancy,
its effect on the \emph{lifetime probability} of PCM is not zero,
however.  
As shown by the simple Poisson model below, the rate of PCM is about 1\%
per year.  Other work reveals that said rate is almost constant over
follow-up time (not shown). 
Because women in the study have an average lifetime that is 2 years
longer than men, their lifetime risk of PCM is higher as well.
Very few subjects acquire PCM more than 15 years after a MGUS diagnosis at
age 80 for the obvious reason that very few of them will still 
be alive.

<<mrate>>=
mpfit <- glm(pstat ~ sex -1 + offset(log(ptime)), data=mgus2, poisson)
exp(coef(mpfit)) * 12   # rate per year
@ 

A single outcome fit using only time to progression is instructive:
we obtain exactly the same coefficients but different absolute risks.
This is a basic property of multi-state models: hazards can be explored
separately for each transition, but absolute risk must be computed globally.
(The estimated cumulative hazards from the two models are also identical).
The incorrect curve is a vain attempt to estimate the progression rate which 
would occur if death could be abolished.  It not surprisingly ends up as about
1\% per year.  

<<msingle, fig=TRUE>>=
sfit <- coxph(Surv(tstop, event=="PCM") ~ I(age/10) + sex + mspike, crdata)
rbind(single = coef(sfit),
      multi  = coef(cfit)[1:3])
#par(mfrow=c(1,2))
ssurv <- survfit(sfit, newdata=dummy)
plot(ssurv[3:4], col=1:2, lty=2, xscale=12, xmax=12*20, lwd=2, fun="event",
     xlab="Years from diagnosis", ylab= "Pr(has entered PCM state)")
lines(csurv[3:4, 2], col=1:2, lty=1, lwd=2)
legend(20, .22, outer(c("80 year old male,", "80 year old female,"),
                      c("incorrect", "correct"), paste),
                  col=1:2, lty=c(2,2,1,1), lwd=2, bty='n')
@ 


\section{Multiple event types per subject}

\section{Testing proportional hazards}
The usual Cox model with $p$ covariates has the form
\begin{align*}
  \lambda(t) &= \lambda_0(t) e^{\beta_1 x_1 + \beta_2 x_2 + \ldots + \beta_p x_p} \\
             &= e^{\beta_0(t) + \beta_1 x_1 + \beta_2 x_2 + \ldots + \beta_p x_p}
\end{align*}
A key simplifying assumption of the model is that all of the coefficients
except $\beta_0$ (the baseline hazard) are constant over time,
which is referred to as the \emph{proportional hazards} assumption.
Numerous approaches to verifying or testing this assumption have been
proposed, of which the three most enduring have been the addition of
an additional constructed covariate, score tests, and tests based on
cumulative martingale sums.  Each of these is normally applied to one
covariate at a time.

\subsection{Constructed variables}
For the constructed variable approach, assume that the true form of the
model for variable $x_1$ is $\beta_1(t) x_1$, with the coefficient having
the simple linear form $\beta_1(t) = a + bt$.
Then 
\begin{align}
  \beta_1(t)x_1 &=  ax_1 + b(x_1t) \nonumber \\
               & = ax_1 + b z  \label{ph1}
\end{align}
that is, we can create a special time-dependent covariate $z = x_1t$, add
add it to the data set, and then use an ordinary \code{coxph} fit.

Consider the veterans lung cancer data set, which has often been used to
illustrate non-proportional hazards.
Adding this special covariate is not quite as simple as writing
<<echo=TRUE, eval=FALSE>>=
fit2 <- coxph(Surv(time, status) ~ trt + trt*time + celltype + karno,
                data = veteran)
@ 
The problem is that \code{time} is trying to play two roles in the above 
equation,
the \emph{final} follow-up time for each subject and the
\emph{continuous} time scale $t$ of equation \eqref{ph1}.
The solution to to create the special variable explicitly
before calling the regression function.
Since the Cox model adds a term to the likelihood at each unique death
time, it is sufficient to create a data set with the same granularity.

<<zphcheck1>>=
dtime <- unique(veteran$time[veteran$status==1]) # unique times
newdata <- survSplit(Surv(time, status) ~ trt + celltype + karno,
                     data=veteran, cut=dtime)
nrow(veteran)
nrow(newdata)
fit0 <- coxph(Surv(time, status) ~ trt + celltype + karno, veteran)
fit1 <- coxph(Surv(tstart, time, status) ~ trt + celltype + karno, 
              data=newdata)
fit2 <- coxph(Surv(tstart, time, status) ~ trt + celltype + karno +
              time:karno, newdata)
fit2

fit2b <- coxph(Surv(tstart, time, status) ~ trt + celltype + karno +
              rank(time):karno, newdata)
@ 

The fits give a warning message about the use of the \code{time} variable
on both sides of the equation 
(two most common cases where time appears on both sides are the naive model
shown further above and frank typing mistakes).
In this particular case we can ignore the warning since the data set was 
carefully constructed for this special purpose, but it should never be treated
casually.

Alternatively, \code{coxph} has built-in functionality that will build
the expanded data set for us, behind the scenes, and then use that 
expanded data for the fit.
Here is eqivalent code to test the Karnofsky variable:
<<zph2>>=
fit2 <- coxph(Surv(tstart, time, status) ~ trt + celltype + karno +
              tt(karno), data =newdata,
              tt = function(x, t,...) x*t)
@ 
 
There are 4 issues with the constructed variable approach.
\begin{enumerate}
  \item The choice $\beta(t) \approx a + bt$ was arbitrary.  Perhaps the true
    form is $a + b\log(t)$ (fit2b above), or some other function.
  \item The intermediate data set can become huge. 
    It will be of order $O(nd)$ where $d$ is the number of unique
    event times, and $d$ grows along with $n$.
  \item The coefficients for a factor variable such as celltype can be
    confusing, since the results depend on how the 0/1 indicators
    for the variable are chosen.
  \item Outliers in time are an issue. 
    The veteran cancer data set, for instance, contains 
    a time of 999 days (a particularly
    suspicious value in any data set).
    The Cox model itself depends only on the rank order of the event times,
    so such outliers are not an issue for the base model,
    but as a covariate these values can have undue influence.
    The time-dependent coeffient for Karnofsky has $p<.01$ in fit2b
    above, which uses rank(time),
    a change that is largely due to dampening the leverage of outliers.
\end{enumerate}

\subsection{Score tests}
The \code{cox.zph} function checks proportional hazards for a fitted Cox model
directly, and tries to address the four issues discussed above.
\begin{itemize}
  \item It is easy to specify alternate time transforms such as x*log(t).  
    More importantly, the code produces both a diagnostic plot that suggests
    the shape of any non-proportionality, along with a test of the chosen
    time-transform.
  \item The test statistic is based on a score test, which does not require
    creating the expanded data set.
  \item Multi-covariate terms such as a factor or splines are by default treated
    as a single effect.
  \item The default time transform is designed to minimize outliers in time.
\end{itemize}

Shown below are results for the veterans data using \code{fit0} from above.
The score statistic for the simple term x*time (\code{zp1}) closely matches the
Wald test for the full time dependent fit found in \code{fit2} above,
which is what we would expect; score, Wald and likelihood ratio tests usually
agree quite closely for Cox models.

<<zph2, fig=TRUE>>=
zp0 <- cox.zph(fit0, transform='identity')
zp0
zp1 <- cox.zph(fit0, transform='log')
zp1
oldpar <- par(mfrow=c(2,2))
for (i in 1:3) {plot(zp1[i]); abline(0,0, lty=3)}
plot(zp0[3])
par(oldpar)
@ 

A test for zero slope, from a least squares regression using data in the 
matching plot approximates the score test.
(In versions of the package prior to survival3.0, the approximate test was
used for the formal printout and test as well.)
If proporitional hazard holds we would expect the fitted line to be
horizontal, i.e., $\beta(t)$ is constant.
Rather than show a fitted line the plot add a general smooth curve, which
can help reveal the \emph{form} of non-proportional hazards, if it exists. 
The first three panels of the plot show curves for the three covariates on
a log(time) scale.
Since \code{celltype} is a factor, the plot shows the time dependent effect
of the portion of the linear predictor associated with cell type; 
if proportional hazards is true wrt that term a fitted line should be
horizontal with a coefficient of 1.
The effect of Karnofsky score appears become essentially 0 after
approximately 6 months; for this cohort of subjects with advanced lung cancer,
a 6 month old assessment is no longer relevant.
The corresponding plot in the lower right panel, however, shows that the outlier
time of 999 days has an undue influence on any such regression. 
A test of proportional hazards on that scale must also be treated with
caution.
The plot using log scale lacks these outliers and is more interpretable.

The default time transform is based on a Kaplan-Meier transform, i.e., that
monotone transform of the time axis that will cause the KM plot to be a 
straight line.
This is a good default for the score tests, since it essentially 
guarrantees that there wil be no outliers in the constructed $x g(time)$, 
while dealing with censoring in a defensible way. 
The code has opted for a safe default. 
It is not as easily interpreted as other scales for the plots, however.

The \code{cox.zph} function does not attempt a score test for random effects 
(frailty) terms, 
in fact is not clear what the computation for such a test should be.
The function will check other covariates in a model that
contains a random effect, however; 
the estimated random effect per subject is essentially treated as a fixed 
offset.


\chapter{Accelerated Failure Time models}
\label{chap:aft}

\chapter{Tied event times}
\label{chap:tied}
\section{Cox model estimates}
The theory for the Cox model has always been worked out for the case of
continuous time, which implies that there will be no tied event or censoring
times in the data set.
With respect to censoring times, all of the survival library commands treat
censoring as occuring ``just after'' the recorded time point.
The rationale is that if a subject was last observed alive on day 231, say, 
then their death time, whatever it is, must be strictly greater than 231.  
For formally, a subject who was censored at time $t$ is considered to have
been at risk for any events that occured at time $t$.

The issue with tied event times is more complex, and the software supports 
three different algorithms for dealing with this.
The Cox partial likelihood is a sum of terms, one for each event time, each
of which compares the subject who had the event to the set of subjects who 
``could have had the event": the \emph{risk set}.
The overall view is essentially a lottery model: at each event time there
was a drawing to select one subject for the event,
the risk score for each subject $\exp(X_i\beta)$ tells how many ``tickets'' 
each subject had in the drawing.
The software implements three different algorithms for dealing with tie
event times.

The Breslow approximation (\code{ties='breslow'}) in essence ignores the ties.
If two subjects A and B died on day 100, say, 
the partial likelihood will have separate terms for the two deaths.
Subject A will be at risk for the death that happened to B, and B will be at 
risk for the death that happened to A.
In life this is not technically possible of course: whoever died first will
not be at risk for the second death.

The Efron approximation can be motivated by the idea of \emph{coarsening}:
time is on a continuous scale but we only observe a less precise version of
it.  For example consider the acute myelogenous leukemia data set that is
part of the package, which was a clinical trial to test if extendend
chemotherapy (``Maintained'') was superior to standard.
The time to failure was recorded in months, and in the non-maintained arm
there are two pairs of failures, at 5 and at 8 months.
It might be reasonable to assume that if the data had been recored in days
these ties might not have occured.
<<>>=
with(subset(aml, x=="Nonmaintained"), Surv(time, status))
@ 

Let the risk scores $\exp(X\beta)$ for the 12 subjects be $r_1$--$r_{12}$,
and assume that the two failures actually at month 5 are not tied on a finer
time scale. 
For the first event, whichever it is, the risk set with be all subjects 1--12
and the denominator of the partial likelihood term is $\sum r_i$.
For the second event, the denominator is either
$r_1 + r_3 + \ldots r_{12}$ or $r_2 + r_3 + \ldots r_{12}$;
the Efron approximation is to use the average of the two as the denominator
term.
In the software this is easily done by using temporary case weights:
if there were $k$ tied events then one of the denomiators gives each of those
$k$ subjects a weight of 1, then next gives each a weight of $(k-1)/k$, then
next a weight of $(k-2)/k$, etc.  
The Efron approximation imposes a tiny bit more bookkeeping, but
the the computational burden is no different that for case weights; 
i.e., it effectively takes no more computational time than the Breslow
approximation.

The third possiblility is the exact partial likelihood due to Cox, which treats
the underlying time scale as discrete rather than continuous.
When taking this view the denominator of the partial likelihood term is
again an average, but over a much larger subset.
If there are $k$ events and $n$ subjects at risk, the EPL sum is over all
$k$ choose $n$ possible choices.  
In the AML example above, the event at time 5 will be a sum over 12(11)/2= 33
terms.  If the number of ties is large this quickly grows unreasonable:
for 20 ties out of 1000 the sum has over 39 billion terms.
A clever algorithm by Gail makes this sum barely possible, but it does not
extend to the case of (tstart, tstop) style data.

An important aside is that the log-likelihood for matched logistic
regression is identical to the Cox partial likelihood for a particular
data set, when the EPL is used.
Namely, set time=1 (or any other constant), status = 0 for controls and 1 for 
cases, and fit a coxph model with each matched set as a separate stratum.
In most instances a matched set will consist of a single case along with one
or more controls, however, which is the case where the Breslow, Efron, and EPL
are identical.  (The EPL will still take slightly longer to run due to 
setting up the
necessary structure for all those sums.)

How important are the ties, actually?
Below we show a small computation in which a larger data set is successively
coarsened and compare the results.
The colon cancer data set has 929 subjects with stage B/C colon cancer
who were randomized to three treatment arms and then followed for 5
years; the time to death or progression is in days.
In the example below we successively coarsen the time scale to be
monthly, bimonthly, \ldots, bi-annual; the last of which generates an
very large number of ties. 
What we see is that
\begin{itemize}
  \item The Efron approximation is quite good at dealing with the
    coarsened data, producing nearly the same coefficient as the
    original data even when the coarsening is extreme.
  \item The Breslow approximation is biased somewhat towards 0,
    the exact paritial likelihood somewhat away from 0.
  \item The differences are very small. With monthly coarsening,
    which is itself fairly large, the 3 estimates differ by about .01
    while the standard error of the original coefficient is 0.96;
    i.e. a shift that is statistically immaterial.
\end{itemize}
    
<<coarsen,fig=TRUE>>=
tdata <- subset(colon, etype==1)   # progression or death
cmat <- matrix(0, 7, 6)
for( i in 1:7) {
    if (i==1) scale <-1 else scale <- (i-1)*365/12
    temp <- floor(tdata$time/scale)
    tfit <-  coxph(Surv(temp, status) ~ node4 + extent, tdata)
    tfit2 <- coxph(Surv(temp, status) ~ node4 + extent, tdata,
                   ties='breslow')
    tfit3 <- coxph(Surv(temp, status) ~ node4 + extent, tdata,
                   ties='exact')
    cmat[i,] <- c(coef(tfit2), coef(tfit), coef(tfit3))
}
matplot(1:7, cmat[,c(1,3,5)], xaxt='n', pch='bec',
        xlab="Time divisor", ylab="Coefficient for node4")
axis(1, 1:7, c(1, floor(1:6 *365/12)))
@ 

Early on in the package the decision was made to make the Efron approximation
the default. 
The reasoning was simply that is \emph{is} more accurate, even if only a little,
and the author's early background in numerical analysis argued strongly to
always use the best approximation available.
The second reason is that the computational cost is low. 
Most of us would pick up a 1 Euro coin on the sidewalk, even though
it will not make any real change in our income.
One downside is that no other package did this, leading to a very common
complaint/question that R ``gives different results''.
A second is that it leads to further downstream programming as discussed in 
following sections.

\section{Cumulative hazard and survival}
The coarsening argument can also be applied to the cumulative hazard
$\Lambda(t)$.
Say that there were 3 deaths with 10 subjects at risk.
The increment to the Nelson-Aalen cumulative hazard estimate would
then be 3/10.
If the data had been observed in continuous time, however, there would have
been 3 increments of 1/10 + 1/9 + 1/8.
This estimate was explored by Fleming and Harrington \cite{Fleming84}.
In the \code{survfit} function the \code{ctype} option selects for
1=Nelson-Aalen and 2= Fleming-Harrington.

The Kaplan-Meier estimate is not subject to the coarsening phenominon.
In our example, the observed data will lead to a multipilicative increment
of 7/10 and the continuous data to one of (9/10)(8/9)(7/8), which are the 
same.
An alternate estimate of the survival is $S(t) = \exp(-\Lambda(t))$.
Basing this on the FH estimate of hazard will more closely track the KM 
when there are tied event times.
The direct (KM) vs. exponential estimates of survival are obtained with
the \code{ctype=1} and \code{ctype=2} arguments; however, the
exponential estimate is quite uncommon outside of the Cox model.

\section{Predicted cumulative hazard and surival from a Cox model}

Predictions from a coxph model must always be for \emph{someone}, i.e.,
some particular set of covariate values.
Let $r_i = \exp(X_i\hat\beta -c)$ be the recentered risk scores for each
subject $i$, where the recentering constant $c = X_n\hat\beta$,
$X_n$ being the covariates of the ``new'' subject for which prediction
is desired.  
(We don't want to create a prediction for a baseline subject with
X=0, what textbooks often call a ``baseline hazard'', since if 0 is too
far from the center of the data the exp function can easily overflow.)
The estimated cumulative hazard at any event time is then
\begin{equation}
  \Lhat(t) = \int_0^t \frac{\sum_i dN_i(t)}{\sum_i Y_i(t) r_i} 
  \label{haz:breslow}
\end{equation}
Equation \eqref{haz:breslow} is known as the Breslow estimate;
if $\hat\beta=0$ then $r_i=1$ and it becomes equal to
the Nelson-Aalen estimator.

If the Efron estimate is used for ties, then the software uses an Efron
estimate of the cumulative hazard; which reduces to the Fleming-Harrington
if $\hat\beta =0$.  
Using the hazard estimate that matches the parial likelihood estimate causes
an important property of the vector of martingale residuals $m$ to hold, 
namely that $mX$ is equal to the first derivative of the partial likelihood.
residuals hold for both

The Cox model is a case where the default estimate of survival is based on
the exponent of the cumulative hazard, rather than a 'direct' one such as
the Kaplan-Meier.  There are three reasons for this.
\begin{enumerate}
  \item The most obvious 'direct' estimate is to use 
    $(\sum dN_i(t) -\sum Y_i(t)r_i)/ (\sum Y_i(t)r_i)$ as a multiplicative
    update at each event time $t$.  This expression in not guarranteed to
    be between 0 and 1, however, particular for new subjects who are near
    or past the boundaries of the original data set.  This leads to using
    some sort of ad hoc correction to avoid failure.
  \item The direct estimate of Kalbfleisch and Prentice avoids this, but it
    does not extend to delayed entry, multi-state models or other extensions
    of the basic model.
  \item The KP estimate reqires iteration so the code is more complex.
\end{enumerate}

\section{Multi-state models}
Multi-state hazards models have a very interesting (and useful)
property,
which is that hazards can be estimated singly (without reference to any
other transition) but probability-in-state estimators must be computed 
globally.
Thus, one can estimate non-parametric cumulative hazard estimates 
(Nelson-Aalen), the hazard ratios for any given transtion (Cox model)
or the predicted cumulative hazard function based on a per transition
Cox model without incurring any issues with respect to competing risks.
(If there is informative censoring the overall and individual estimates
still agree, but they will both be wrong.
An example of informative censoring would be subjects who are removed from
the data because of an impending event, e.g., censoring subjects who enter
hospice care would underestimate death rates.)

Now say that we had a simple competing risks problem, 10 subjects are
alive and in the initial state on day 100, at which time two of them
transition to
two different endpoints.  
A coarsening argument would say that on the underlying continuous time
scale these two subjects would not be tied, and then would use  9.5 
as the denominator for
each of the two cumulative hazard increments.
Such an estimate would however then be at variance with the two indiviually 
computed hazards: global coarsening removes the separability.
The survival package takes a moderated view and will apply the coarsening
argument separately to each hazard, i.e., it chose to retain the separation
policy.


\appendix
\chapter{Changes from version 2.44 to 3.0}
Not all of these may be completed by 3.0, but this is the roadmap.

\section{Changes in version 3}
\label{sect:changes}
Version 3.0 of the package was released in conjunction with a book.  Writing
the book, and in particular the examples, revealed some shortcomings in 
the design.
In particular, there were some common concepts which had appeared piecemeal in
more than one function, but not using the same keywords.  Two particular areas
are survival curves and multiple observations per subject.

Survival and cumulative hazard curves are generated by the 
\code{survfit} function, either from
raw data (survfit.formula), or a fitted Cox or parametric survival model
(survfit.coxph, survfit.survreg). 
Two choices that appear are:
\begin{enumerate}
  \item If there are tied event times, to estimate the hazard using a 
    straightforward increment of (number of events)/(number at risk), or
    make a correction for the ties.  The simpler method is known variously
    as the Nelson, Aalen, Breslow, and Tsiatis estimate, along with hyphenated
    forms combining 2 or 3 of them.
    One of the simpler corrections for ties is known as the Fleming-Harrington
    approximation when used with raw data, and the Efron when used 
    in a Cox model.
  \item The survival curve $S(t)$ can be estimated directly or as the
    exponential of the cumulative hazard estimate.  The first of these is
    known as the Kaplan-Meier, cumulative incidence (CI), Aalen-Johansen,
    and Kalbfleisch-Prentice estimate, depending on context, 
    the second as a Fleming-Harrington, Breslow, or Efron estimate, again
    depending on context.
\end{enumerate}

With respect to the two above, subtypes of the \code{survfit} routine have
had either a \code{type} or \code{method} argument over the years which tried
to capture both of these at the same time, 
and consequently have had a bewildering number of options,
for example ``fleming-harrington'' in \code{survfit.formula} 
stood for the simple cumulative hazard
estimate plus the exponential survival estimate, 
``fh2'' specified the tie-corrected cumulative hazard plus exponential survival,
while \code{survfit.coxph} used ``breslow'' and ``efron'' for the same two
combinations.
The updated routines now have separate \code{stype} and \code{ctype}
arguments.  For the first, 1= direct and 2=exponent of the cumulative hazard
and for the second, 1=simple and 2= corrected for ties. 

The Cox model is a special case in two ways: 
1. the the way in which ties are treated
in the likelihood should match the way they are treated in creating the hazard
and 2. the direct estimate of survival can be very difficult to compute.
The survival package's default is to use the \code{ctype} option 
which matches the ties option
of the \code{coxph} call along with an exponential estimate of survival.
This \code{ctype} choice preserves some useful properties of the martingale
residuals.

A second issue is multiple observations per subject, and how those impact
the computations.  This leads to 3 common arguments:
\begin{itemize}
  \item id: an identifier in each row of the data, which allows the routines
    to identify multiple rows for a subject
  \item cluster: identify correlated rows, which should be combined when
    creating the robust variance
  \item robust: TRUE or FALSE, to compute a robust variance.
\end{itemize}

These arguments have been inconsistent in the past, partly because of the
sequential appearance of multiple use cases.  The package started with
only the simplest data form: one observation per subject, one endpoint.
To this has been added:
\begingroup
\renewcommand{\theenumi}{\alph{enumi}}
\begin{enumerate}
  \item Multiple observations per subject
  \item Multiple endpoints per subject
  \item Multiple types of endpoints
\end{enumerate}
\endgroup

Case (a) arises as a way to code time-dependent covariates, and in this
case an \code{id} statement is not needed, and in fact you will get the
same estimates and standard errors with or without it. 
(There will be a change in the counts of subjects who leave or enter an
interval, since an observation pair (0, 10), (10, 20) for the same subject
will not count as an exit (censor) at 10 along with an entry at 10.)
If (b) is true then the robust variance is called for and one will want to 
have either a \code{cluster} argument or the \code{robust=TRUE} argument.
In the coxph routine, a \code{cluster(group)} term in the model statement
can be used instead of the cluster argument,
but this is no longer the preferred form. 
When (b) and (c) are true then the \code{id} statement is required in order
to obtain a correct \emph{estimate} of the result. 
This is also the case for (c) alone when subjects do not all start in the
same state.  
For competing risks data --- multiple endpoints, 
everyone starts in the same state, only one transition per subject --- 
the \code{id} statement is not necessary nor (I think) is a robust variance.

When there is an \code{id} statement but no \code{cluster} or \code{robust}
directive, then the programs will use (b) as a litmus test to decide
between model based or robust variance, if possible.
(There are edge cases where only one of the two variance estimates has 
been implemented, however).
If there is a \code{cluster} argument then \code{robust=TRUE} is assumed.
If only a \code{robust=TRUE} argument is given
then the code treats each line of data as independent.

\section{Survfit}
  There has been a serious effort to harmonize the various survfit methods.
Not all paths had the same options or produced the same outputs.

\begin{itemize}
  \item Common arguments of id, cluster, influence, stype and ctype.
    \begin{itemize} 
      \item If stype=1 then the survival curve S(t) is produced directly,
        if stype=2 it is created as the exp(-H) where H is the cumulative hazard.
      \item If ctype=1 the Nelson-Aalen formula is used, and for ctype=2 there
        is a correction for ties.
      \item The usual curve for a Cox model using the Efron approximate is
        (2,2), for instance, which the ordinary KM is (1, 1).
    \end{itemize}
  \item The routines now produce both the estimated survival and the
    estimated cumulative hazard, along with their errors 
  \item Some code paths produce std(S) and some std(log(S)), the object now
    contains a \code{log.se} flag telling which.  (Before, downstream routines
    just ``had to know'').
  \item using a single subscript on a survfit object now behaves like the
    use of a single subscript on an array or matrix, in that the result has
    only one dimension.
\end{itemize}

A utility function \code{survfit0} is used by the print and plot methods to add
a starting ``time 0'' value of x=0, y=1 the survival curve(s).  It also aligns
all the matrices so that they correspond to the time vector, inserts the
correct standard errors, etc.  
This may be useful to other programs.

\section{Coxph}
 The multi-state objects include a \code{states} vector, which is a simple
list of the state names.
The \code{cmap} component is an integer matrix  with one row for each term in the
model and one column for each transition. 
Each element indexes a position in the coefficient vector and variance matrix.
\begin{itemize}
  \item Column labels are of the form 1:2, which denotes a transition from
    \code{state[1]} to \code{state[2]}.
  \item If a particular term in the data, ``age'' say, was not part of the model
    for a particular transition then a 0 will appear in that position 
    of \code{cmap}.
z  \item If two transitions share a common coefficient, both those element of
    \code{cmap} will point to the same location.
  \item The first row of \code{cmap}, labeled ``stratum'', is numbered separately
    and partitions the transitions into disjoint strata.
\end{itemize}

\bibliographystyle{plain}
\bibliography{refer}

\end{document}


