\section{Plotting survival curves}
This version of the curves uses the newer form of the survfit object, which
fixes an original design decision that I now consider to have been a mistake.
That is, an ordinary survival curve did not store the intial (time=0, S=1)
point in the survfit object, leaving it up to plotting and/or printing routines
to glue it back on.  
Later additions of delayed starting time and multi-state curves meant that I
had to store those values anyway, sticking them into appended objects.
The version3 survfit object puts the intial time back where it belongs, and
makes this routine easier to write.

<<plot.survfit>>=
plot.survfit<- function(x, conf.int,  mark.time=FALSE,
			pch=3,  col=1,lty=1, lwd=1, 
                        cex=1, log=FALSE,
			xscale=1, yscale=1, 
			xlim, ylim, 
			fun, xlab="", ylab="", xaxs='r', 
                        conf.times, conf.cap=.005, conf.offset=.012, 
                        conf.type=c('log',  'log-log',  'plain', 
                                  'logit', "arcsin"),
                        mark, noplot="(0)", cumhaz=FALSE,
                        firstx, xmax, ymin, ...) {

    dotnames <- names(list(...))
    if (any(dotnames=='type'))
        stop("The graphical argument 'type' is not allowed")
    if (missing(mark.time) & !missing(mark)) mark.time <- TRUE

    x <- survfit23(x)   # convert to version 3, if it wasn't already
    <<plot-plot-setup1>>
    <<plot-common-args>>
    <<plot-xfix>>
    <<plot-firstx>>
    <<plot-plot-setup2>> 
    <<plot-functions>>
    plot.surv <- TRUE
    type <- 's'
    <<plot-draw>>    
}

lines.survfit <- function(x, type='s', 
                          pch=3, col=1, lty=1, lwd=1,
                          cex=1,
                          mark.time=FALSE, xscale=1, 
			  xmax,
                          fun,  conf.int=FALSE,  
                          conf.times, conf.cap=.005, conf.offset=.012, mark, 
                          noplot="()", cumhaz=FALSE, ...) {
    x <- survfit23(x)
    xlog <- par("xlog")
    if (missing(mark.time) & !missing(mark)) mark.time <- TRUE
 
    <<plot-common-args>>
    if (missing(pch) && !missing(mark)) pch <- mark
    if (length(pch)==1 && is.character(pch)) pch <- strsplit(pch, "")[[1]]
    <<plot-firstx>>
    <<plot-functions>>
    <<plot-draw>>
}

points.survfit <- function(x, xscale, xmax, fun, censor=FALSE,
                           col=1, pch, noplot="()", cumhaz=FALSE, ...) {
    # this function is used rarely
    conf.int <- FALSE  # never draw these with 'points'

    x <- survfit23(x)
    <<plot-common-args>>
    <<plot-xfix>>
    if (ncurve==1 || (length(col)==1 && missing(pch))) {
        if (censor) points(stime, ssurv, ...)
        else points(stime[x$n.event>0], ssurv[x$n.event>0], ...)
    }
    else {
        c2 <- 1  #cycles through the colors and characters
        col <- rep(col, length=ncurve)
        if (!missing(pch)) {
            if (length(pch)==1)
                pch2 <- rep(strsplit(pch, '')[[1]], length=ncurve)
            else pch2 <- rep(pch, length=ncurve)
        }
        for (j in 1:ncol(ssurv)) {
            for (i in unique(stemp)) {
                if (censor) who <- which(stemp==i)
                else who <- which(stemp==i & x$n.event >0)
                if (missing(pch))
                    points(stime[who], ssurv[who,j], col=col[c2], ...)
                else
                    points(stime[who], ssurv[who,j], col=col[c2], 
                           pch=pch2[c2], ...) 
                c2 <- c2+1
            }
        }
    }
}
@ 

<<plot-common-args>>=
# The default for plot and lines is to add confidence limits
#  if there is only one curve
if (missing(conf.int) && missing(conf.times))  
    conf.int <- (is.null(x$strata) && !is.matrix(x$surv) 
        && !is.matrix(x$pstate))  # a NULL is FALSE 

if (missing(conf.times)) conf.times <- NULL   
else {
    if (!is.numeric(conf.times)) stop('conf.times must be numeric')
    if (missing(conf.int)) conf.int <- TRUE
}
if (!conf.int) supper <- NULL

if (!missing(conf.int)) {
    if (is.numeric(conf.int)) {
        conf.level <- conf.int
        if (conf.level<0 || conf.level > 1)
            stop("invalid value for conf.int")
        if (conf.level ==0) conf.int <- FALSE
    }
    else conf.level = 0.95
}

stime <- x$time
std   <- NULL
yzero <- FALSE   # a marker that we have an "ordinary survival curve" with min 0
if (cumhaz) {  # plot the cumulative hazard instead
    if (is.null(x$cumhaz)) stop("survfit object does not contain a cumulative hazard")
    if (is.numeric(cumhaz)) {
        nhazard <- sum(x$transitions > 0)  # number of transitions
        if (cumhaz != floor(cumhaz)) stop("cumhaz argument is not integer")
        if (any(cumhaz < 1 | cumhaz > nhazard)) stop("subscript out of range")
        ssurv <- x$cumhaz[,cumhaz, drop=FALSE]
        if (!is.null(x$std.chaz)) std <- x$std.chaz[,cumhaz, drop=FALSE]
    }
    else if (is.logical(cumhaz)) {
        ssurv <- as.matrix(x$cumhaz)
        if (!is.null(x$std.chaz)) std <-   as.matrix(x$std.chaz)
    }
    else stop("invalid cumhaz argument")
}
else if (inherits(x, "survfitms")) {
    i <- (x$states != noplot)
    if (!any(i))  i <- seq(along=x$states)  # don't throw away everything
    ssurv <- (as.matrix(x$pstate))[,i, drop=FALSE]
    if (!is.null(x$std.err))  std <-   (as.matrix(x$std.err))[,i, drop=FALSE]
}
else {
    yzero <- TRUE
    ssurv <- as.matrix(x$surv)
    if (!is.null(x$std.err)) std <- as.matrix(x$std.err)
    # The fun argument only applies to single state survfit objects
    #  First deal with the special case of fun='cumhaz', which is here for
    #  backwards compatability; people should use the cumhaz argument
    if (!missing(fun) && is.character(fun) && fun=="cumhaz") {
        cumhaz <- TRUE
        if (!is.null(x$cumhaz)) {
            ssurv <- as.matrix(x$cumhaz)
            if (!is.null(x$std.chaz)) std <- as.matrix(x$std.chaz)
        } 
        else {
            ssurv <- as.matrix(-log(x$surv))
            if (!is.null(xstd.err)) {
                if (x$logse) std <- as.matrix(x$std.err)
                else std <- as.matrix(x$std.err/x$surv)
            }
         }
    }
}

# set up strata
if (is.null(x$strata)) {
    nstrat <- 1
    stemp <- rep(1, length(x$time)) # same length as stime
}
else {
    nstrat <- length(x$strata)
    stemp <- rep(1:nstrat, x$strata) # same length as stime
}
ncurve <- nstrat * ncol(ssurv)
@ 

If confidence limits are to be plotted, and they were not part of the
data that is passed in, create them.  Confidence limits for the 
cumulative hazard must always be created, and don't use transforms.
<<plot-common-args>>=
if (conf.int) {
    if (is.null(std)) stop("object does not have standard errors, CI not possible")
    if (cumhaz) {
        if (missing(conf.type)) conf.type="plain"
        temp <- survfit_confint(ssurv, std, logse=FALSE,
                                conf.type, conf.level, ulimit=FALSE)
        supper <- as.matrix(temp$upper)
        slower <- as.matrix(temp$lower)
    }
    else if (is.null(x$upper)) {
        if (missing(conf.type) && !is.null(x$conf.type))
            conf.type <- x$conf.type
        temp <- survfit_confint(ssurv, x$std, logse= x$logse,
                                conf.type, conf.level, ulimit=FALSE)
        supper <- as.matrix(temp$supper)
        slower <- as.matrix(temp$slower)
    }
    else {
        supper <- as.matrix(x$upper)
        slower <- as.matrix(x$lower)
    }
}
@ 

The xlim argument can be used to prune back the curve to a
subset.  To make for a prettier plot, we prune the data ourselves before
calling the plot function, that way lines don't touch the borders.
A special case is when we are drawing lines and a curve got
pruned so severely that only a horizontal segment from the curve start
remains. 

<<plot-xfix>>= 
if (!missing(firstx) && !missing(xlim))
    stop("cannot have both xlim and firstx arguments")
if (!missing(xmax)) {
    if (!missing(xlim)) stop("cannot have both xlim and xmax arguments")
    xlim <- c(x$time[1], xmax)
} else if (missing(xlim))  xlim <- range(x$time)
if (!missing(firstx)) xlim[1] <- firstx

if (!missing(xlim) || !missing(xmax) && any(x$time < xlim[1] | x$time>xlim[2])){
    if (all(x$time < xlim[1])) stop("all time points are < xlim[1]")
    if (all(x$time > xlim[2])) stop("all time points are > xlim[2]")

    # prune back the survival curves
    #  We want a horizontal line to continue to the x limits, which is done
    #  by modifying x, and repeating y
    xlfun <- function(time, indx, xmin, xmax) {
        yindx <- xindx <- indx
        n <- length(indx)
        # lower limit
        if (any(time < xmin)) {
            k1 <- max(which(time < xmin))
            xindx <- xindx[k1:n]
            yindx <- yindx[k1:n]
        } else k1 <- NULL
        
        # upper limit
        if (any(time > xmax)) {
            k2 <- min(which(time > xmax))
            xindx <- xindx[1:k2]
            yindx <- yindx[1:k2]
            if (k2 > 1) yindx[k2]<- yindx[k2-1]
        }
        else k2 <- NULL
        list(xindex = xindx, yindex=yindx, k1=indx[k1], k2=indx[k2])
    }
    
    temp <- vector("list", nstrat)
    for (i in 1:nstrat) 
        temp[[i]] <- xlfun(x$time[stemp==i], which(stemp==i), xlim[1], xlim[2])
    k1 <- unlist(lapply(temp, function(x) x$k1))
    if (length(k1)) x$time[k1] <- xlim[1]
    k2 <- unlist(lapply(temp, function(x) x$k2))
    if (length(k2)) x$time[k2] <- xlim[2]
    if (length(k1) || length(k2)) {  # some points were removed
        keepx <- unlist(lapply(temp, function(x) x$xindex))
        keepy <- unlist(lapply(temp, function(x) x$yindex))
        stime <- stime[keepx]
        stemp <- stemp[keepx]
        x$n.event <- x$n.event[keepx]
        if (!is.null(x$n.censor)) x$n.censor <- x$n.censor[keepx]
        ssurv <- ssurv[keepy,,drop=FALSE]
        if (!is.null(std)) std <- std[keepy,,drop=FALSE]
        if (!is.null(supper)) {
            supper <- supper[keepy,,drop=FALSE]
            slower <- slower[keepy,,drop=FALSE]
        }
    }
}
@ 


<<plot-common-args>>=
if (!inherits(x, "survfitms") && !cumhaz & !missing(fun)) {
    yzero <- FALSE
    if (is.character(fun)) {
        tfun <- switch(tolower(fun),
    		   'log' = function(x) x,
    		   'event'=function(x) 1-x,
    		   'cumhaz'=function(x) -log(x),
    		   'cloglog'=function(x) log(-log(x)),
    		   'pct' = function(x) x*100,
    		   'logpct'= function(x) 100*x,  #special case further below
                   'identity'= function(x) x,
                   'f' = function(x) 1-x,
                   's' = function(x) x,
                   'surv' = function(x) x,
    		   stop("Unrecognized function argument")
    		   )
        if (tolower(fun) %in% c("identity", "s")) yzero <- TRUE
    }
    else if (is.function(fun)) tfun <- fun
    else stop("Invalid 'fun' argument")
    
    ssurv <- tfun(ssurv )
    if (!is.null(supper)) {
        supper <- tfun(supper)
        slower <- tfun(slower)
    }
}
@ 

The \code{mark} argument is a holdover from S, when pch could not have
numeric values; mark has since disappeared from the manual page for
\code{par}.  We honor it for backwards compatability.
To be consistent with matplot and others, we allow pch to be a character
string or a vector of characters.
The firstx, xmax, firsty, and ymin arguments are all depricated, and
now appear in xlim and ylim (which should have been the design from the start).

<<plot-plot-setup1>>=
if (missing(pch) && !missing(mark)) pch <- mark
if (length(pch)==1 && is.character(pch)) pch <- strsplit(pch, "")[[1]]
@ 

<<plot-firstx>>=
if (is.logical(conf.int)) plot.surv <- TRUE
else {
    temp <- match.arg(conf.int, c("both", "only", "none"))
    if (is.na(temp)) stop("invalid value for conf.int")
    if (temp=="none") conf.int <- FALSE  else conf.int <- TRUE
    if (temp=="only") plot.surv <- FALSE  else plot.surv <- TRUE
}
<<plot-setup-marks>>
@

<<plot-setup-marks>>=
# Marks are not placed on confidence bands
pch  <- rep(pch, length.out=ncurve)
mcol <- rep(col, length.out=ncurve)
if (is.numeric(mark.time)) mark.time <- sort(mark.time)

# The actual number of curves is ncurve*3 if there are confidence bands,
#  unless conf.times has been given.  Colors and line types in the latter
#  match the curves
# If the number of line types is 1 and lty is an integer, then use lty 
#    for the curve and lty+1 for the CI
# If the length(lty) <= length(ncurve), use the same color for curve and CI
#   otherwise assume the user knows what they are about and has given a full
#   vector of line types.
# Colors and line widths work like line types, excluding the +1 rule.
if (conf.int & is.null(conf.times)) {
    if (length(lty)==1 && is.numeric(lty))
        lty <- rep(c(lty, lty+1, lty+1), ncurve)
    else if (length(lty) <= ncurve)
        lty <- rep(rep(lty, each=3), length.out=(ncurve*3))
    else lty <- rep(lty, length.out= ncurve*3)
    
    if (length(col) <= ncurve) col <- rep(rep(col, each=3), length.out=3*ncurve)
    else col <- rep(col, length.out=3*ncurve)
    
    if (length(lwd) <= ncurve) lwd <- rep(rep(lwd, each=3), length.out=3*ncurve)
    else lwd <- rep(lwd, length.out=3*ncurve)
}
else {
    col  <- rep(col, length.out=ncurve)
    lty  <- rep(lty, length.out=ncurve)
    lwd  <- rep(lwd, length.out=ncurve)
}
@ 

Here is the rest of the setup for the plot routine, mostly having to do with
setting up axes.  The [[xlog]] and [[ylog]] variables are internal reminders
of the choice, and [[logax]] is what will be passed to the plot function
<<plot-plot-setup1>>= 
if (is.logical(log)) {
    ylog <- log
    xlog <- FALSE
    if (ylog) logax <- 'y'
    else      logax <- ""
}
else {
    ylog <- (log=='y' || log=='xy')
    xlog <- (log=='x' || log=='xy')
    logax  <- log
}

if (!missing(fun)) {
    if (is.character(fun)) {
        if (fun=='log'|| fun=='logpct') ylog <- TRUE
        if (fun=='cloglog') {
            xlog <- TRUE
            if (ylog) logax <- 'xy'
            else logax <- 'x'
        }
    }
}
@ 

<<plot-plot-setup2>>=
# Do axis range computations
if (xaxs=='S') {
    #special x- axis style for survival curves
    xaxs <- 'i'  #what S thinks
    tempx <- max(stime) * 1.04
}
else tempx <- max(stime)
tempx <- c(min(stime), tempx)

if (!missing(ylim)) {
    tempy <- ylim
    if (!missing(ymin)) stop("cannot have both ylim and ymin arguments")
}
else {
    if (ylog) {
        tempy <-  range(ssurv[is.finite(ssurv)& ssurv>0])
        if (tempy[2]==1) tempy[2] <- .99   # makes for a prettier axis
        if (any(ssurv==0)) {
            tempy[1] <- tempy[1]*.8
            ssurv[ssurv==0] <- tempy[1]
            if (!is.null(supper)) {
                supper[supper==0] <- tempy[1]
                slower[slower==0] <- tempy[1]
            }
        }
    }
    else {
        if (!is.null(supper)) 
            tempy <- range(c(supper, slower), finite=TRUE, na.rm=TRUE)
        else tempy <- range(ssurv, finite=TRUE, na.rm= TRUE)
        if (!missing(ymin)) tempy <- range(c(ymin, tempy))
        else if (yzero) tempy <- range(c(0, tempy))
    }
}
    
#
# Draw the basic box
#
plot(range(tempx, finite=TRUE, na.rm=TRUE)/xscale, 
     range(tempy, finite=TRUE, na.rm=TRUE)*yscale, 
     type='n', log=logax, xlab=xlab, ylab=ylab, xaxs=xaxs,...)

if(yscale != 1) {
    if (ylog) par(usr =par("usr") -c(0, 0, log10(yscale), log10(yscale))) 
    else par(usr =par("usr")/c(1, 1, yscale, yscale))   
}
if (xscale !=1) {
    if (xlog) par(usr =par("usr") -c(log10(xscale), log10(xscale), 0,0)) 
    else par(usr =par("usr")*c(xscale, xscale, 1, 1))   
}  
@ 
The use of [[par(usr)]] just above is a bit sneaky.  I want the
lines and points routines to be able to add to the plot, \emph{without}
passing them a global parameter that determines the y-scale or forcing
the user to repeat it.
The xscale argument was added before yscale, and before I saw this
trick.  
By then there were hundreds of lines of code that have an xscale
argument to lines() so the other change was to ignore the argument in the
lines function.

The next functions do the actual drawing.
<<plot-functions>>=
# Create a step function, removing redundancies that sometimes occur in
#  curves with lots of censoring.
dostep <- function(x,y) {
    keep <- is.finite(x) & is.finite(y) 
    if (!any(keep)) return()  #all points were infinite or NA
    if (!all(keep)) {
        # these won't plot anyway, so simplify (CI values are often NA)
        x <- x[keep]
        y <- y[keep]
    }
    n <- length(x)
    if (n==1)       list(x=x, y=y)
    else if (n==2)  list(x=x[c(1,2,2)], y=y[c(1,1,2)])
    else {
        # replace verbose horizonal sequences like
        # (1, .2), (1.4, .2), (1.8, .2), (2.3, .2), (2.9, .2), (3, .1)
        # with (1, .2), (.3, .2),(3, .1).  
        #  They are slow, and can smear the looks of the line type.
        temp <- rle(y)$lengths
        drops <- 1 + cumsum(temp[-length(temp)])  # points where the curve drops

        #create a step function
        if (n %in% drops) {  #the last point is a drop
            xrep <- c(x[1], rep(x[drops], each=2))
            yrep <- rep(y[c(1,drops)], c(rep(2, length(drops)), 1))
        }
        else {
            xrep <- c(x[1], rep(x[drops], each=2), x[n])
            yrep <- c(rep(y[c(1,drops)], each=2))
        }
        list(x=xrep, y=yrep)
    }
}

drawmark <- function(x, y, mark.time, censor, cex, ...) {
    if (!is.numeric(mark.time)) {
        xx <- x[censor>0]
        yy <- y[censor>0]
        if (any(censor >1)) {  # tied death and censor, put it on the midpoint
            j <- pmax(1, which(censor>1) -1)
            i <- censor[censor>0]
            yy[i>1] <- (yy[i>1] + y[j])/2
        }
    }
    else { #interpolate
        xx <- mark.time
        yy <- approx(x, y, xx, method="constant", f=0)$y
    }
    points(xx, yy, cex=cex, ...)
}
@ 

The code to actually draw curves for the plot.

The code to draw the lines and confidence bands.
<<plot-draw>>=
c1 <- 1  # keeps track of the curve number
c2 <- 1  # keeps track of the lty, col, etc
xend <- yend <- double(ncurve)
if (length(conf.offset) ==1) 
    temp.offset <- (1:ncurve - (ncurve+1)/2)* conf.offset* diff(par("usr")[1:2])
else temp.offset <- rep(conf.offset, length=ncurve) *  diff(par("usr")[1:2])
temp.cap    <-  conf.cap    * diff(par("usr")[1:2])

for (j in 1:ncol(ssurv)) {
    for (i in unique(stemp)) {  #for each strata
        who <- which(stemp==i)

        # if n.censor is missing, then assume any line that does not have an
        #   event would not be present but for censoring, so there must have
        #   been censoring then
        # otherwise categorize is 0= no censor, 1=censor, 2=censor and death
        if (is.null(x$n.censor)) censor <- ifelse(x$n.event[who]==0, 1, 0)
        else censor <- ifelse(x$n.censor[who]==0, 0, 1 + (x$n.event[who] > 0))
        xx <- stime[who]
        yy <- ssurv[who,j]
        if (plot.surv) {
            if (type=='s')
                lines(dostep(xx, yy), lty=lty[c2], col=col[c2], lwd=lwd[c2]) 
            else lines(xx, yy, type=type, lty=lty[c2], col=col[c2], lwd=lwd[c2])
            if (is.numeric(mark.time) || mark.time) 
                drawmark(xx, yy, mark.time, censor, pch=pch[c1], col=mcol[c1],
                         cex=cex)
        }
        xend[c1] <- max(xx)
        yend[c1] <- yy[length(yy)]

        if (conf.int && !is.null(conf.times)) {
            # add vertical bars at the specified times
            x2 <- conf.times + temp.offset[c1]
            templow <- approx(xx, slower[who,j], x2,
                              method='constant', f=1)$y
            temphigh<- approx(xx, supper[who,j], x2,
                              method='constant', f=1)$y
            segments(x2, templow, x2, temphigh,
                      lty=lty[c2], col=col[c2], lwd=lwd[c2])
            if (conf.cap>0) {
                segments(x2-temp.cap, templow, x2+temp.cap, templow,
                         lty=lty[c2], col=col[c2], lwd=lwd[c2] )
                segments(x2-temp.cap, temphigh, x2+temp.cap, temphigh,
                          lty=lty[c2], col=col[c2], lwd=lwd[c2])
            }
           
        }
        c1 <- c1 +1
        c2 <- c2 +1

        if (conf.int && is.null(conf.times)) {
            if (type == 's') {
                lines(dostep(xx, slower[who,j]), lty=lty[c2], 
                      col=col[c2],lwd=lwd[c2])
                c2 <- c2 +1
                lines(dostep(xx, supper[who,j]), lty=lty[c2], 
                      col=col[c2], lwd= lwd[c2])
                c2 <- c2 + 1
            }
            else {
                lines(xx, slower[who,j], lty=lty[c2], 
                      col=col[c2],lwd=lwd[c2], type=type) 
                c2 <- c2 +1
                lines(xx, supper[who,j], lty=lty[c2], 
                      col=col[c2], lwd= lwd[c2], type= type)
                c2 <- c2 + 1
            }
         }

    }
}
invisible(list(x=xend, y=yend))
@




