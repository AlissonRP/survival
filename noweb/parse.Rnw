\subsection{Parsing the covariates list}
For a multi-state Cox model we allow a list of formulas to be given by
the covariates option.
These formulas are not really formulas, instead we abuse the R formula
notation to get what we want.

The input list needs to be taken apart into its component pieces first,
before model.frame is called, in order to have a full list of variable
names that need to be in the model frame.
After the model frame is constructed we have the necessary data to
check that state names given in the formulas actually exist in the 
data and that initial value strings are the right length.
We can then construct the \code{cmap} matrix.

<<parsecovar>>=
parsecovar1 <- function(flist, statedata) {
    if (any(sapply(flist, function(x) !inherits(x, "formula"))))
        stop("flist must be a list of formulas")
    if (any(sapply(flist, length) != 3))
        stop("all formulas must have a left and right side")
    
    # split the formulas into a right hand and left hand side
    lhs <- lapply(flist, function(x) x[-3])
    rhs <- lapply(flist, function(x) x[-2])
    
    <<parse-rightside>>
    <<parse-leftside>>
    list(rhs = rhs2, lhs= lterm)
}
@ 

First look at the right hand side of each formula.  There are 4
possble options of common, fixed, clear, and init.  
The first 3 appear just as words, the last should have a set of
values attached which become the \code{ival} vector.
The end result is a list for each formula containing the actual right
hand side formula along with the options.

<<parse-rightside>>=
# take apart the right hand side of each formula
# the function below is applied to each formula in turn.
rh2 <- lapply(rh2, function(form) {
    parts <- strsplit(deparse(form, width.cutoff=300, control=NULL), 
                      '/', fixed=TRUE)[[1]]
    if (length(parts) ==1)  { # nothing after a /
        ival <- NULL; common <- FALSE; fixed <- FALSE; clear <- FALSE;
    }
    else{
        # treat the right hand side as though it were a formula
        optterms <- terms(formula(paste("~", parts[2])))
        ff <- rownames(attr(optterms, "factors"))
        index <- match(ff, c("common", "fixed", "init", "clear"))
        if (any(is.na(index)))
            stop("option not recognized in a covariates formula: ",
                 paste(ff[is.na(indx)], collapse=", "))
        common <- any(index==1)
        fixed  <- any(index==2)
        clear  <- any(index==3)
        if (any(index==3)) {
            optatt <- attributes(optterms)
            j <- optatt$variables[1 + which(index==3)]
            j[[1]] <- as.name("list")
            ival <- unlist(eval(j, parent.frame()))
        } else ival <- NULL
    }

    # and now the terms before the slash, which is the actual formula
    #  a formula of -1 +1 is recorded as intercept=TRUE, pasting a -1 on
    #  allows us to tell if a 1 was included.
    form <- formula(paste("~ -1 +", parts[1]))
    list(common=common, fixed=fixed, clear=clear, ival=ivar, 
       formula = form) 
})
@ 
 
The left hand side of each formula specifies the set of transitions to which
the covariates apply, and is more complex.
Say instance that we had 7 states and the following statedata
data set.
\begin{center}
  \begin{tabular}{cccc}
    state & A&  N& death \hline \\
    A-N- &  0&  0 & 0\\
    A+N- &  1&  0 & 0\\
    A-N1 &  0&  1 & 0\\
    A+N1 &  1&  1 & 0\\
    A-N2 &  0&  2 & 0\\
    A+N2 &  1&  2 & 0\\
    Death&  NA & NA& 1 
\end{tabular}
\end{center}

  Here are some valid transitions
\begin{itemize}
   \item 1:state('A+N+'),   any transition to the A+N+ state
   \item state('A-N-'):death(0), a transition from A-N-, but not to death
   \item A(0):A(1), any of the 4 changes that start with A=0 and end with A=1
   \item N(0):N(1,2) + N(1):N(2), an upward change of N
   \item 'A-N-':c('A-N+','A+N-'); if there is no variable then the 
     overall state is assumed
\end{itemize}

<<parse-leftside>>=
# deal with the left hand side of the formula
# the next routine cuts at '+' signs
pcut <- function(form) {
    if (length(form)==3 && form[[1]] == '+') 
        c(pcut(form[[2]]), pcut(form[[3]]))
    else form
}
lcut <- lapply(lhs, function(x) pcut(x[[2]]))
@ 
We now have one list per formula, each list is either a single term
or a list of terms (case 4 above).
To make evaluation easier, create functions that append their
name to a list of values.
I have not yet found a way to do this without eval(parse()), which
always seems clumsy.
A use for the labels without an argument will arise later, hence the
double environments.

<<parse-leftside>>=
env1 <- new.env(parent= parent.frame(2))
env2 <- new.env(parent= env1)
if (is.null(statedata))
    assign("state", function(...) list(statedatacolname= "state", 
                                       values=c(...)), env1)
else {
    for (i in names(statedata)) {
        assign(i, i, env2)
        tfun <- eval(parse(text=paste0("function(...) list(statedatacolname='"
                                       , i, "', values=c(...)")))
        assign(i, tfun, env1)
    }
}

lterm <- lapply(lcut, function(x) {
    lapply(x, function(z) {
        if (length(z)==1) eval(z, envir=env2)
        else if (length(z) ==3 && z[[1]]==':')
            list(eval(z[[2]], envir=env2), eval(z[[3]], envir=env2))
        else stop("invalid term: ", deparse(z))
    })
})
@ 


The second call, which builds tmap, the terms map.
Arguments are the results from the first pass, the statedata data frame,
the default formula, the terms structure from the full formula,
and the transitions count.

<<parsecovar>>=
parsecovar2 <- function(covar1, statedata, dformula, Terms, transitions) {
    istate <- row.names(transitions)
    ystate <- col.names(transitions)[-1]
    if (is.null(statedata))
        statedata <- data.frame(state = unique(ystate, istate))
    else {
        if (is.null(statedata$state)) 
            stop("the statedata data set must contain a variable 'state'")
        indx1 <- match(istate, statedata$state, nomatch=0)
        if (any(indx1==0))
            stop("statedata does not contain initial state(s) ", 
                 istate[indx1==0])
        indx2 <- match(ystate, statedata$state, nomatch=0)
        if (any(indx2==0))
            stop("statedata does not contain ending state(s) ", ystate[indx2==0])
    }
    
    # Statedata might have rows for states that are not in the data set,
    #  for instance if the coxph call had used a subset argument
    # Likewise, the covariates list might have rules for transitions that are
    #  not present.  Don't worry about it at this stage.
    allterm <- attr(Terms, 'term.labels')
    nterm <- length(alltem)

    <<parse-tmap>>
    
    # fold the 3-dimensional tmap into a matrix with terms as rows
    #  and columns for transtions
    browser()
    mapid <- cbind(row(transitions), col(transitions))[,c(was.seen)
    list(tmap = matrix(tmap, dim(tmap)[1])[,was.seen], inits=inits,
         mapid = rbind(c(0,0), mapid)  # the first row is the intercept term
}
@ 

Create a map for every transition, even the ones that were not used.
The very first term is the intercept or strata.
We initialize all the ones that are actually used to the default formula,
the rest remain as zeros.
<<parse-tmap>>=
# create the map and fill it in with the default formula
tmap <- array(0L, dim=c(nterm+1, length(istate), length(ystate)))
dterms <- match(attr(terms.formula(dformula), "term.labels"), allterm,
                nomatch=0)
if (any(dterms==0)) stop("dterm mismatch bug 1")
dterms <- c(1L, 1L+ dterms)  # add the intercept
was.seen <- (transitions[,-1] > 0)
nseen <- sum(was.seen)
temp <- matrix(tmap, dim(tmap)[1])  # make it a matrix, temporarily
ncoef <-  sum(was.seen)*length(dterms) # "coef" labels used to initialize
temp[dterms, which(was.seen)] <- seq_len(ncoef)
tmap[,,,] <- c(temp)
@ 

Now go through the formulas one by one.  The left hand side tells us which
state:state transitions to fill in,  the right hand side tells the variables.
A given portin of the left hand side can be a list whose first element
is ``statedatacolname'', which will be the result of parsing a string
like \code{A(1,3)}, or it could be a simple vector resulting from
\code{c(1,3)}.  In the second case we assume it matches the state variable.
<<parse-lmatch>>=
if (is.list(lhs[[1]]) && length(lhs[[1]])==2 && 
    all(names(lhs[[1]]) == c("sdatacolname", "values")) {
        lrow <- match(lhs[[1]]$values, sdata[[lhs[[1]]$sdatacolname]])
        if (any(is.na(lrow))) 
            stop("value not found in statedata: ",
                 lhs[[1]]$values[is.na(lrow)])
    }
else {
    lrow <- match(unlist(lhs[[1]]), sdata$state)  
    if (any(is.na(lrow))) 
        stop("value not found in statedata: ",
                 unlist(lhs[[1]])[is.na(lrow)])
}
state1 <- statedata$state[lrow]
    
if (is.list(lhs[[2]]) && length(lhs[[2]])==2 && 
    all(names(lhs[[2]]) == c("sdatacolname", "values")) {
        lrow <- match(lhs[[2]]$values, sdata[[lhs[[2]]$sdatacolname]])
        if (any(is.na(lrow))) 
            stop("value not found in statedata: ",
                 lhs[[2]]$values[is.na(lrow)])
    }
else {
    lrow <- match(unlist(lhs[[2]]), sdata$state)  
    if (any(is.na(lrow))) 
        stop("value not found in statedata: ",
                 unlist(lhs[[2]])[is.na(lrow)])
}
state2 <- statedata$state[lrow]                 
@ 

The inits need to wait a little longer, until the X matrix is in hand.
<<parse-tmap>>=
inits <- NULL  
for (i in 1:length(covar1)) {  
    rhs <- covar1$rhs[[i]]
    lhs <- covar1$lhs[[i]]  # the two are the same length
    rterm <- terms.formula(rhs$formula)
    rindex <- 1L + match(attr(rterm, "term.labels"), allterm, nomatch=0)
    if (any(rindex== 1L)) stop("dterm mismatch bug 2")
    if (attr(rindex, "intercept")==1) rindex <- c(1L, rindex)
    
    if (length(lhs)==1) {
        # a term with no : in it
        stop("term with no colon, saved for future extension")
    } else {
        <<parse-lmatch>>
        if (rhs$clear) tmap[rindex, state1, state2] <- 0
        if (length(rhs$ival)) 
            inits <- c(inits, list(term=rindex, state1=state2, 
                                   state2= state2, init= rhs$ival))
        if (rhs$common) j <- ncoef + seq_len(length(rindex))
        else j <- ncoef + seq_len(length(rindex)*length(state1)*length(state2))
        tmap[rindex, state1, state2] <- j
        ncoef <- max(j)
    }
}    
@ 

