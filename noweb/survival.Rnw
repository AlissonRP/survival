\section{Survival curves}
\subsection{Cumulative Incidence}
Consider the following simple multi-state model for patients awaiting
a liver transplant.
Endpoints are transplant, death, and removal from the waiting list for
other causes, of which the first two are the most common.
We would like to know, at any given time, what fraction of patients have
reached each of the endpoints.
(This was a study of a transplant program's liver allocation policies,
and death after transplant is not of interest for this analysis.)
This result is known as a cumulative incidence curve and is produced
by the survfitCI function.

<<survfitCI>>=
survfitCI <- function(X, Y, weights, 
                      type=c('kaplan-meier', 'fleming-harrington', 'fh2'),
                      error, se.fit=TRUE,
                      conf.int= .95,
                      conf.type=c('log',  'log-log',  'plain', 'none'),
                      conf.lower=c('usual', 'peto', 'modified'),
                      id, istate) {
    <<sci-check-args>>
    <<sci-compute>>
    <<sci-finish>>
}
@ 

Start by checking the arguments for validity.  
<<sci-check-args>>=
method <- match.arg(type)
conf.type <- match.arg(conf.type)
conf.lower<- match.arg(conf.lower)

type <- attr(Y, "type")
if (type!='mright' && type!='mcounting')
    stop(paste("cumulative incidence computation doesn't support \"", type,
              "\" survival data", sep=''))
n <- nrow(Y)
if (length(X) != n) stop("wrong length for X")
if (missing(weights)) weights <- rep(1.0, n)
if (length(weights) != n) stop("wrong length for weights")
X <- as.factor(X)
if (missing(id) || is.null(id)) id <- 1:n
else if (length(id) != n) stop("wrong length for id")
@ 

If an istate argument was supplied, then this gives the initial state
for each observation of the data.
If not then all subjects are assumed to start in an initial state
named ``(Initial)''.  The total set of states will
be the the union of those in the survival time (attribute ``states'')
and the initial state.
If no istate argument was given, then we assume that everyone
starts in state ``none'', and the final result will not include a curve
for that although we will compute it.
The integer vectors istate and estate start at 1 for R indexing, but
will have 1 subtracted for the C code. 

<<sci-check-args>>=
if (missing(istate) || length(istate)==0) {
    istate <- rep("(Initial)", n)
    if (any(attr(Y, "states") == "(Initial)"))
        stop ("input data has a state named '(Initial)'")
}
istate <- as.factor(istate)
state.labels <- unique(c(attr(Y, "states"), levels(istate)))
states <- 1:length(state.labels)
istate <- match(istate, state.labels) 
estate <- as.integer(Y[,ncol(Y)])  # 0 for censored
status <- pmin(estate, 1L)
if (any(istate==estate)) stop("transition from one state to the same state")
nstate <- length(states)
@ 

Due to roundoff [[unique(time]] and [[table(time)]] may not be the
same.  Variants of this can catch us when counting the number at risk, tied
event times, etc.
Avoid this by turning time into a factor and then back to
numeric.  Deal with the integer numeric until all is done, then
put the correct values back on.
<<sci-check-args>>=
ftime <- factor(Y[, -ncol(Y)])  # both start and stop time, if present
itime <- matrix(as.integer(ftime), nrow=n)
@ 

If there is start, stop time data and an id variable, then we have the case
of subjects being followed forward in time.
Make sure that each subject is a contiguous set of intervals.
Replace values for istate on the second, third, \ldots interval for a
subject with the state they just came from.
Also verify that subject don't change groups.
<<sci-compute>>=
if (any(duplicated(id))) {
    if (ncol(Y) ==2) stop("multiple obs per subject requires start/stop data")
    indx <- order(id, itime[,2])
    temp <- c(0, as.numeric((etype[indx])[-n])) 
    istate <- ifelse(duplicated(id[indx]), temp, istate)

    temp <- c(0, itime[indx,2][-n]) #lagged ending time of the interval
    if (any(duplicated(id[indx]) & itime[indx,1] != temp))
        stop("time intervals for a subject must form a continuous series")

    temp <- c(X[1], (X[indx])[-n])  #lagged X
    if (any(duplicated(id[indx]) & X[indx]!= temp))
        stop("a subject may not change from one group to another")
    ijack <- TRUE  #use infinitesimal jackknife estimate
}
else ijack <- TRUE  # the alternate code isn't done
@ 

Based on Andersen, Borgan, Gill and Keiding (ABGK) \cite{Andersen93} 
equation 4.4.1 the transition
matrix is
\begin{align}
  P(t) &= P(0) \prod_{s<t} [I+ h(s)] \label{eq:prob}\\
  h_{jk}(s) &= d_{jk}(s)/n_j(s), \, j\ne k \label{eq:H}
\end{align}
Here $d_{jk}(s)$ is the weighted number of subjects who are observed to make a
transition from state $j$ to state $k$ at exactly time $s$, it is 
the multivariate analog to the number of deaths at a time point.
The weighted number at risk in state $j$ is $n_j(s)$, and $h$ is the
empirical hazard matrix for all pairs of transitions.
The diagonal elements of $h$ are defined so that row sums of $h$ are 0.
$P$ will be an $m$ by $m$ matrix, $P_{jk}(t)$  gives the probability that
a subject starting in state $j$ at time 0 will be in state $k$ at time $t$.
$P(0)$ is the distribtion of subjects at the start of the follow-up.

An alternative defintion uses the cumulative hazard matrix $H$.
\begin{align*}
   H(t) &= \sum_{s \le t} h(s) \\
   P(t) &= P(0) e^{H(t)}
\end{align*}
where $e$ is the matrix exponential.  This corresponds to the Fleming-Harrington
estimate of survival in a simple survival curve.

When there is an [[id]] variable we compute the variance using an 
infinitesimal jackknife.  To this end consider a weighted estimate.
Assume that we have done the computation up
to time $t-$, and have the estimate $P(t-)$ and the matrix of per subject
derivatives $D_{ij}(t) = \partial P_j(t-)/\partial w_i$. 
The jth element of $P(t)$ is the sum over all the prior states times the
probability of transition from that state to $j$.  
The derivative with respect to subject is derived using the chain rule.
\begin{align}
  P_j(t) &= \sum_k P_k(t-) [I + H_{kj}(t)]  \nonumber \\
  D_{ij} &= \frac{\partial P_j(t)}{\partial w_i} \nonumber \\ &= 
  \sum_k \left[\frac{\partial P_k(t-)}{\partial w_i} [I +H_{kj}(t)] + 
  P_k(t-) \frac{\partial H_{kj}(t)}{\partial w_i} \right]\label{eq:recur} \\
  \frac{\partial H_{kj}(t)}{\partial w_i} &= 
    \begin{array}{cc}
       Y_{ik}(t)\left[\delta_{ikj}(t) - H_{kj}(t)
         \right] /n_k(t) & j\ne k \\
      Y_{ij}(t) \left[-\delta_{ij.}(t) - H_{jj}(t)
           \right]/n_j(t) & j = k \\
    \end{array}   
      \label{eq:recur2}
\end{align}
where $Y_{ij}(t)$ is 1 if subject $i$ is in state $j$ at time $t$,
$\delta_{ijk}$ is 1 if subject $i$ had a transition from $j$ to $k$
at that time point and $\delta_{ij.}$ is 1 for any transition from 
state $j$.
Then the variance of $P_k(t)$ is estimates as $\sum_i w_i D_{ik}^2$.  
The above derivation assumes legal data, i.e., that a given subject is
in only one state at a given time, and that there is only one copy
of the subject present (you can't have two obs each with weight 1/2).

The first term of \eqref{eq:recur} is a simple matrix multiplication where
$D$ is $n$ by $p$ and $p$ is the number of states.
The second term \eqref{eq:recur2} has two parts.  
The derivative of the numerator of \eqref{eq:H} 
$d_{jk}(s)= \sum_i \delta_{ijk}(s)$ will affect only subjects $i$ who had
a transition at time $s$ and only two elements of $H$: the transition that
occured for that subject and the diagonal element for that row.
The derivative of the denominator of \eqref{eq:H} is the $H$ portion of
\eqref{eq:recur2} and involves all subjects still at risk at time $s$.


If there is not an id variable we can use the asymptotic formula
of 4.4.20 of ABGK.  
This starts with the variance covariance matrix of $h$.  The covariance
matrix between rows of $h$ is zero.  Within the $i$th row we have
\begin{align*}
  {\rm var}(h_{ii}(t)) &= \frac{[n_i(t) - d_{i.}(t)]d_{i.}(t)}{n_i(t)^3} \\
  {\rm var}(h_{ij}(t)) &= \frac{[n_i(t) - d_{ij}(t)]d_{ij}(t)}{n_i(t)^3},
  \; i\ne j \\
  {\rm cov}(h_{ii}(t), h_{ij}(t)) &=\frac{[n_i(t) - d_{i.}(t)]d_{ij}(t)}
                          {n_i(t)^3}, \; i\ne j \\
  {\rm cov}(h_{ij}(t), h_{ik}(t)) &= -\frac{d_{ij}(t) d_{ik}(t)}{n_i(t)^3},
     \; i\ne j \ne k
\end{align*}
If there are $k$ states then this result can be kept in a $k\times k \times k$
array.
The variance matrix for the cumulative hazard $H$ is the sum of the 
variances for each individual death time.
We can multiply each of these by $n_i/(n_i-d_i)$ to get the more common
formula used by Aalen and Tsiatis, or by $[n_i/(n_i - d_i)]^2$ to get
the Greenwood like estimate.  

The closed form variance for $P$ is 
                          


To compute the transitions I need to know the prior state for each
observation.
Also check for no illegal overlaps, e.g., (0,10) and (6,15) as two
successive intervals for a subject.
Such data would produce an answer, but one without any meaning.

Computations are done separately for each level of X,
set this up as a function [[docurve]].
Start by ordering the the times within the subset, then call the C routine
to calculate 
\begin{description}
  \item [nrisk] number at risk just prior to time t
  \item [wrisk] weighted number at risk = sum of weights for those at risk
  \item [nevent] number of events (deaths)
  \item [wevent] weighted number of events
\end{description}
The returned arrays are ordered from largest time to smallest time.
<<sci-compute>>=
docurve <- function(who) {
    itemp <- itime[who,,drop=FALSE]
    utime <- sort(unique(itime[,ncol(itime)])) 
    ntime <- length(utime) #number of unique event times
    if (ncol(itemp)==1) {
        dsort <- order(itemp[,1])
        isort <- NULL
        censor <- table(itemp[,1], status[who]==0)[,2]
    }
    else {
        dsort <- order(itemp[,2])
        isort <- order(itemp[,1])
        censor <- table(itemp[,2], status[who]==0)[,2]
    }
    mfit <- .Call("msurv",
                  nrisk = matrix(0L, nstate, ntime),
                  wrisk = matrix(0., nstate, ntime),
                  nevent= array (0L, dim=c(nstate, nstate, ntime)),
                  wevent= array (0., dim=c(nstate, nstate, ntime)),
                  itime[who,],
                  status[who],
                  istate[who] -1L,
                  estate[who] -1L, 
                  weights[who],
                  dsort -1L,
                  isort -1L)
    <<docurve-create-p>> 

    n.risk <- t(mfit$nrisk[, ntime:1])
    n.event <- apply(mfit$nevent[,,ntime:1], 3:2, sum)
        
    rlist <- list(n=nrow(itemp), time= utime, n.risk=n.risk,
                  n.event =n.event, n.censor=as.vector(censor),
                  surv= P[-1,])
    if (se.fit) rlist$std.err =sqrt(semat[-1,])
    rlist
}
@
Now create the probability matrix $P$ and its standard error.
For simplicity both of these have an initial row corresponding to the
starting states (the error is 0 for this row), then one for each
unique death time.  We'll later throw away this first row.
A standard error is the long part of the computation.  
It keeps an array [[dmat]] with one row per subject and one column
per state that captures equation \eqref{eq:recur}, updated at each
time point.
<<docurve-create-p>>= 
P <- matrix(0., nrow= 1+ ntime, ncol=nstate)
temp <- table(factor(((istate[who])[dsort])[!duplicated((id[who])[dsort])],
              levels= 1:nstate))
P[1,]<- as.vector(temp)/sum(temp)

if (se.fit) {
    semat <- matrix(0., ntime+1, nstate)
    if (ijack) {
        nperson <- length(unique(id))
        dmat <- matrix(0., nperson, nstate)
    }
}

for (i in 1:ntime) {
    indx <- 1+ ntime -i
    risk2 <-ifelse(mfit$nrisk[, indx]==0, 1, mfit$nrisk[, indx]) #avoid 0/0
    Hmat <- mfit$wevent[,, indx]/ risk2
    diag(Hmat) <- -rowSums(Hmat)
    IHmat <- Hmat + diag(nstate)
    P[i+1,] <- P[i,] %*% IHmat
    
    if (se.fit) {
        if (sum(mfit$nevent[,,indx]) ==0 ) {
            semat[i+1,] <- semat[i,]
        }
        else {
            deaths <- which(status==1 & itemp[,ncol(itemp)]==utime[i])
            if (ijack) {
                dmat <- dmat %*% IHmat
                if (ncol(itime)==2) 
                    atrisk <- (id[itemp[,1] <utime[i] & 
                                  itemp[,2] >= utime[i]])
                else atrisk <- id[itemp[,1] >= utime[i]]
                dmat[atrisk,] <- dmat[atrisk,] - 
                    rep((P[i,]/risk2) %*% Hmat, each=length(atrisk))
                tindx <- cbind(id[deaths], istate[deaths])
                dmat[tindx] <- dmat[tindx] +P[i, istate[deaths]] * 
                    diag(Hmat)[istate[deaths]] / sum(weights[deaths])
                tindx <- cbind(id[deaths], estate[deaths])
                dmat[tindx] <- dmat[tindx] + P[i, istate[deaths]] *
                    Hmat[cbind(istate[deaths], estate[deaths])] /
                        sum(weights[deaths])
                semat[i+1,] <- colSums(dmat*dmat*weights)
            } 
            else stop("code not done")
        }
    }
}
@

<<sci-compute>>= 
# Call the function for each group in turn
ngroup <- length(levels(X))
if (ngroup ==1) {
    fit <- docurve(rep(TRUE, n))
}
else {
    fitlist <- vector("list", ngroup)
    for (i in ngroup) fitlist[[i]] <- docurve(X== levels(X)[i])
    extract <- function(x, name) unlist(lapply(x, function(x) x[[name]]))
    mextract <- function(x, name) matrix(unlist(lapply(x, function(x)
                                                       t(x[[name]])),
                                                ncol=nstate, byrow=T))
    fit <- list(n=      extract(fitlist, "n"),
                time=   extract(fitlist, "time"),
                n.risk =mextract(fitlist, "n.risk"),
                n.event=extract(fitlist, "n.event"),
                n.censor=extract(fitlist, "n.censor"),
                surv =  mextract(fitlise, "surv"))
    if (se.fit) fit$std.err <- mextract(fitlist, "std.err")
    fit$strata <- unlist(lapply(fitlist$time, length))
    names(fit$strata) <- levels(X)
}
@ 

Convert time back to the original scale.
If the initial state is a dummy, then drop that column from the results
so that it doesn't get printed or plotted.
<<sci-finish>>=
fit$time <- as.numeric(levels(ftime)[fit$time])  #return to original time values
dimnames(fit$surv) <- list(NULL, state.labels)

fit$type <- type
fit$states <- state.labels
fit
@ 

The weighted number at risk is a sum of case weights, nevent is a count and
wevent the total weight of the deaths.
The first four arguments will have their valued filled in.
<<msurv>>=
/*  -*- c -*-  */
#include "Rinternals.h"
SEXP msurv(SEXP nrisk2, SEXP wrisk2, SEXP nevent2, SEXP wevent2,
           SEXP itime2, SEXP status2,
           SEXP prior2, SEXP etype2,  SEXP wt2,
           SEXP dsort2, SEXP isort2) {
    int i,j,k;
    double *wrisk, *wevent, *wt;
    int    *nrisk, *status, *prior, *etype, *nevent;
    int    *dtime,  *etime;  /* death time and optional entry time */
    int    *dsort, *isort;
    int    eflag, i2, k2;
    SEXP   retlist;  
    int    time;  /* current time of interest */
    int    ntime, nstate, n;
    static const char *outnames[]= {"nrisk", "wrisk", "nevent", "wevent", ""};
    
    nrisk = INTEGER(nrisk2);
    wrisk = REAL(wrisk2);
    wevent= REAL(wevent2);
    nevent= INTEGER(nevent2);
    dtime = INTEGER(itime2);
    status= INTEGER(status2);
    prior = INTEGER(prior2);
    etype = INTEGER(etype2);
    wt    = REAL(wt2);
    dsort = INTEGER(dsort2);
    nstate= nrows(nrisk2);
    n     = length(dsort2);
    
    /* 
    ** Add up the risk set and the deaths 
    **   Walk backwards through the observations and through time
    */
    if (ncols(itime2)==2) {
	etime = dtime;
	dtime += n;  /* point at the death time */
        isort = INTEGER(isort2);
	eflag=1;
        i2 = n-1;
        k2 = isort[i2];
	}
    else eflag=0;
    
    for (i=n-1; i>=0; ) {
        k = dsort[i];
	time = dtime[k];  /* current time of interest (there may be ties) */

	while (eflag==1 && i2>=0 && etime[k2] >=time) {
	    /* remove those who start later than "time" from the risk set */
	    wrisk[prior[k2]] -= wt[k2];
	    nrisk[prior[k2]] --;
	    i2--;
	    k2 = isort[i2];
	}
 
	
	if (i<(n-1)) {
	    /* new death time */
	    for (j=0; j<nstate; j++) nrisk[j+nstate] = nrisk[j];
	    nrisk += nstate;
	    wrisk += nstate;
	    nevent += nstate*nstate;
            wevent += nstate*nstate;
	    }
	    
	while(i >=0 && dtime[k] == time) {
	    if (status[k] ==1) {
                nevent[prior[k]+ nstate*etype[k]]++;
                wevent[prior[k] +nstate*etype[k]] += wt[k];
            }
            wrisk[prior[k]] += wt[k];
	    nrisk[prior[k]] ++;
	    i--;
	    k = dsort[i];
	    }
	}
    
    /*
    ** Create output structure
    */
    PROTECT(retlist = mkNamed(VECSXP, outnames));
    SET_VECTOR_ELT(retlist, 0, nrisk2);
    SET_VECTOR_ELT(retlist, 1, wrisk2);
    SET_VECTOR_ELT(retlist, 2, nevent2);
    SET_VECTOR_ELT(retlist, 3, wevent2);
    UNPROTECT(1);
    return(retlist);
}	
@ 

