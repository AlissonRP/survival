Now for the primary function.
The user may have a list of tests, or a single term.

<<yates>>=
yates <- function(fit, test, population=c("none", "data", "factorial", "sas"),
                  method=c("direct", "sgtt"), 
                  ss, ...) {
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)
    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    xassign <- fit$assign
    nvar <- length(xassign)
    nterm <- length(Tatt$term.names)
    termname <- rownames(Tatt$factors)
    
    if (is.null(fit$contrasts)) iscat <- rep(FALSE, nterm)
    else iscat <- sapply(fit$contrasts, 
                         function(x) x %in% c("character", "factor"))
    
    if (missing(method)) method <- "direct"
    method <- match.arg(casefold(method), c("direct", "sgtt")) #allow SGTT
    if (method=="sgtt" && missing(population)) population <- "SAS"

    if (is.character(population))  population <- match.arg(population)
    else {
        if (!inherits(population, "data.frame"))
            stop("the population argument must be a data frame or character")
        pdata <- population
        population <- "user"
        }
 
    if (method=="sgtt" && population !=SAS)
        stop("sgtt method only applies if population = SAS")

    beta <-  coef(fit)
    nabeta <- is.na(beta)  # undetermined coefficients
    vmat <-  vcov(fit)
    
    # grab the dispersion
    if (missing(ss)) do.ss <- FALSE
    else do.ss <- ss
    if (class(fit)[1] =="lm") {
        if (missing(ss)) do.ss <- TRUE
        sigma <- summary(fit)$sigma
        }
    else if(class(fit)[1]=="glm") {
        sigma <- summary(fit)$dispersion
#        if (is.null(sigma)) sigma <- 1
        }
    else sigma <- NULL

    # A bit of trickery to allow users to type "cm" instead of "cmatrix"
    ff <- parent.frame()
    tempenv <- new.env(parent=ff)
    assign("cm", function(...) cmatrix(fit, ...), env=tempenv)
    test <- eval(substitute(test), tempenv)
    if (is.character(test) || inherits(test, "formula"))
        test <- cmatrix(fit, test)

    # check that the test argument is legal: each element should have
    #  class "cmatrix"
    # it can be a list or nested list of such elements, with optional names
    legal <- function(x) {
        if (inherits(x, "cmatrix")) TRUE
        else if (is.list(x)) all(sapply(x, legal))
        else FALSE
    }
    if (!legal(test))
        stop("the test argument should contain elements of class cmatrix")
    xassign <- attr(fit, "assign")
    
    # process the tests
    #  if the argument is a list of tests, the dummy function simply iterates
    #  over the list, or sublists of list elements, etc.
    dummy <- function(x) {
        if (inherits(x, "cmatrix")) dotest(x, method, population)
        else lapply(x, dummy)
    }

    if (method != "sgtt") {
        <<yates-build-fake>>
    }
    dotest <- function(cm, method, population) {
        if (is.na(match(cm$termname, colnames(Tatt$factors))))
            stop("term '", cm$tername, "' not found in the model")
        if (method == "sgtt"){
            << yates-build-sgtt>>
        }
        else {
            if (population == "none") {
                <<yates-build-apv1>>
            }
            else {
                <<yates-build-apv2>>
            }
        }
        cfun(Cmat, beta, vmat, sigma^2)
        }
    }
    result <- dummy(test)
    class(result) <- "yates"
    result
}
@

The \code{cmatrix} object contains three peices of information: the term of
the model that will be tested, a set of data values used to populate that
term and give a set of targets,  and the contrast(s) that will be
applied to those predicted values.  
The program has to
\begin{enumerate}
  \item Create the population data set for the other terms, those that we
    are averaging over. What I call x2 in the vignette.
  \item Fill in the values of interest, ``x1''.
  \item Combine each row of x1 with x2 to get an average predicted value (APV)
    for that x1 row.  This is a vector of length coef(fit).
  \item Perform the requested contrasts on the APV values.
\end{enumerate}
If \code{test} is a list with multiple contrast matrices we simply iterate
over them, doing the entire task separately for each one.

For each contrast the first step is to create APV matrix.
For the SGTT algorithm this is accomplished by a manipulation of the
original $X$ matrix.  Otherwise
each row of APV is, formally, the column sums of a new model.matrix call that
had the selected values for x1 + the population for x2.  
This is a fairly straightforward task using the original data set.
The rub is that we don't have the original data set, we have the model frame.
If someone has a term like \code{ns(age, df=4)} in the model then the mf
will not have age, and we won't have access inverse function -- it could even
be a user defined function.  
One approach is to try to grab the original data, but that is dangerous: 
it might be gone, or it might have changed.  
Particularly if the model did not use data= as the source of the data 
re-fetching will be dicey.

Some issues:
\begin{itemize}
  \item If there are functions in the formula we need to guess the right
    name for the variable.  For something like \code{I(x < z)} we can't know
    what the actual variable is.  If there is only one variable then we
    are fine.
  \item If population=user there is no is no issue with x2, and the user's
    data set may often include x1, which has the potential to resolve those
    name issues.
  \item If population=none and \code{cm\$levels} is NULL, we don't need to
    reconstruct the data at all.
  \item If population=factorial then all of the variables in x2 must be
    categorical, and \code{fit\$xlevels} contains the values.  
    For population=data and functions of continuous variables the fakery is more
    complex: we first try out a call with a dummy covariate of 1:n/n, and if 
    that produces an object of the right shape with no missings we use that x;
    then the original model frame result will be pasted over columns after
    each temporary model frame is created.
\end{itemize}

<<yates-build-fake>>=
vnames <- lapply(Tatt$variables, all.vars)[-1]  # first element will be "list"
x1index <- (Tatt$factors[,cm$termname] >0)      # which variables(s) in x1
x2index <- !x1
if (population=="factorial") {
    if (any(!iscat[x2indx]))
        stop("population=factorial only applies if all the adjusting terms are categorical")
    pdata2 <- do.call("expand.grid", fit$xlevels)
    if (any(!iscat[x1indx])) { # add these to the data set, should be rare
        for (i in which(!iscat[x1indx])) {
            <<fillin-x1>>
        }
    }
} else if (population=="user") {
    # paste in any left hand side variables that are not present
    
    hit <- sapply(vnames, function(x) x %in% names(pdata))
    # any right-hand side which is found, leave it alone, not found=error
    if (any(!hit[x2index])) {
        i <- (which(x2index))[!hit[x2indx]]
        stop("terms with variables not found in data: ", termname[i])
    }
    if (any(!hit[x1index])) {  
        # a left-hand side variable not present
        # we allow this
        for (i in (which(x1index))[!hit[x1index]]) {
            <<fillin-x1>>
        }
    }
}
            if (length(vnames[[i]]) != 1)
                stop("cannot reconstruct data for ", 
                     deparse(Tatt$variables[[i+1]]))
             if (iscat[i]) 
                pdata[[unlist(vnames[[i]])]] <- 
                    rep(fit$xlevels[[termname[[i]]]], length=nrow(pdata))
            else {
                z <- seq(.1, 2, length=nrow(pdata2))
                pdata[[unlist(vnames[[i]])]] <- z
                temp <- try(eval(Tatt$variables[[i+1]], pdata), silent=TRUE)
                if (class(temp) == "try-error" || !any(is.finite(temp)))
                    stop("cannot reconstruct data for ", 
                         deparse(Tatt$variables[[i+1]]))
                else if (!all(j <- is.finite(temp))) {
                    z <- rep(z[j], length=nrow(pdata2))
                    pdata[[unlist(vnames[[i]])]] <- z
                }
            }
        }
    }
} else if (population == "data")
    
@ 
The code to fill in an x2 variable
<<fillin-x2>>=
if (length(vnames[[i]]) != 1)
    stop("cannot reconstruct data for ", 
         deparse(Tatt$variables[[i+1]]))
else tname <- unlist(vnames[[i]])  # the name in the data frame

if (iscat[i]) z <- rep(fit$xlevels[[termnames[i]]], nrow(pdata2))
else z <- seq(.1, 2, length=nrow(pdata2))  #continuous variable
pdata[[unlist(vnames[[i]])]] <- z      # stick it in
if (is.call(Tatt$variables[[i+1]])) {
    # it's not just a name
    tcall <- Tatt$variables[[i+1]]  # save coding keystrokes
    bad <- c("$", "[", "[[", "get")
    if (any(sapply(bad, function(x) zz[[1]] == as.name(x))))
        stop("formulas can not use redirection")
    
    temp <- try(eval(tcall, pdata), silent=TRUE)
    if (class(temp) == "try-error" || !any(is.finite(temp)))
        stop("cannot reconstruct data for ", 
                     deparse(Tatt$variables[[i+1]]))
    else if (!all(j <- is.finite(temp))) {
        z <- rep(z[j], length=nrow(pdata2))
        pdata[[unlist(vnames[[i]])]] <- z
    }
}
@ 

<<yates-build-none>>=
#  The population="none" case. cm will be a cmatrix object
index <- match(cm$termname, Tatt$term.labels)
whichcol <- which(xassign %in% index)  #columns to fill in
ncol <- length(whichcol)
if (is.null(cm$levels)) {
    # population = none is the one case where we allow values for 
    #  x1 to be unspecified.  
    apv <- matrix(0., nrow=ncol, ncol=nvar)
    apv[,whichcol] <- diag(ncol)
}
else {
    apv <- matrix(0., nrow=nrow(cm$levels), ncol=nvar)
    
    
ncoef <- length(xassign)
whichcol <- which(xassign %in% index)  #columns to fill in
clevel <- cm$levels
nullcm <- sapply(clevel, is.null)
if (all(nullcm)) {
    Xmat <- matrix(0., nrow=length(whichcol), ncol=ncoef)
    Xmat[,whichcol] <- diag(length(whichcol))
}
else if (any(nullcm))                            
    stop("can't handle this type of mixed term, yet")
else {
    # Get the inner part of each name, e.g, ns(age, df=3) turns into "age".
    #  The line below is killing a fly with a triphammer, but we only run
    #  it once.  
    pname <- names(clevel)
    for (i in 1:length(pname)) pname[i] <- all.vars(parse(text=pname[i]))[1]
    
    if (!is.data.frame(clevel)) clevel <- do.call("expand.grid", clevel)
    Xmat <- matrix(0., nrow=nrow(clevel), ncol=ncoef)
    for (i in 1:ncol(clevel)) {
        cname <- names(clevel)[i]
        ccol <- which(xassign== index[i])
        if (cm$iscat[i]) {
            if (length(ccol) < length(fit$xlevels[[cname]])) 
                temp <- get(fit$contrasts[[cname]])(length(ccol))
            else temp <- get(fit$contrasts[[cname]])(length(ccol),
                                                     contrasts=FALSE)
            Xmat[,ccol] <- temp[match(clevel[[i]], fit$xlevels[[cname]]),]
        }
        else { # continuous
            j <- match(cname, row.names(Tattr$factors))
            pcall <- Tattr$predictCall[[j+1]] #skip the "list" element
            if (is.call(pcall)) {
                temp <- list(clevel[[i]])
                names(temp) <- pname[i]
                Xmat[,ccol] <- eval(pcall, temp)
            }
            else if (is.name(temp)) {
                if (length(ccol) !=1) stop("logic error")
                Xmat[,ccol] <- clevel[[i]]
            }
            else stop("logic error 2")  #should be impossible
        }
    }
}
@ 

Now go through the contrast matrices 1 by 1 and evaluate them.
<<yates-build-none>>=
if (is.list(cm$cmatrix)) 
    r1 <- sapply(cm$cmatrix, function(z) cfun(z, beta, vmat, sigma^2))
else r1 <- cfun(cm$cmatrix, beta, vmat, sigma^2)
@ 


Population estimates are more work since they involve manipulation
of the model frame.  We essentially break it into two parts: the term
that was asked for, and all the others.
From all the others build a population model frame: that has 4 cases to
consider for the 4 population type.
Model frames are perilous objects: you can't just cut and paste one, as it
has to exactly match the formula that generated it in certain ways.  
It is far better to start with data.  
But we don't have the data.  
One can often recreate the data from the model frame, but not always:
if the user has \code{ns(age, 4)} the mf contains the result of the
computation and there is no simple inverse function.  
We handle the inverse for just a few: \code{I()} and \code{factor()},
as that just entails a change of the name.  
For the variable of interest things are ok: for that we have the levels.

<<yates-build-pop>>=
# x1 = my shorthand for the term of interest, x2 = the rest
tfac   <- Tatt$factors[, cm$termname]
x1name <- names(tfac)[tfac> 0]  # names for the second data set
x2name <- names(tfac)[tfac==0]  # names for the second data set

if (is.null(cm$level) || any(is.na(match(x1name, names(cm$level)))))
    stop("levels are needed for a population contrast")

data1 <- cm$level
# for the left part, we have data, not functions, so just remove any
#  function names.  Assume that the very first arg is the variable name
inner <- function(x) {
    for (i in 1:length(x)) 
        x[i] <- all.vars(parse(text=x[i]))[1]
    x
}
names(data1) <- inner(names(data1))

fixname <- function(x) { #remove calls to I() and factor()
    x <- sub("(factor\\()([^\\)]*)(\\))", "\\2", x)
    x <- sub("(I\\()([^\\)]*)(\\))", "\\2", x)
    x
}

if (population != "user") { # construct data2
    mf <- model.frame(fit)
    data2 <- mf[x2name]
    names(data2) <- fixname(names(data2))
    complex <- fgrepl('(', names(data2)) 
    if (any(complex)) {  # terms that are functions
        # fill in a dummy value
        names(data2) <- inner(names(data2))
        for (i in complex) data2[[i]] <- 1:nrow(data2)
    }
    if (population == "factorial") {
        if (!all(iscat[tfac==0])) 
            stop("all population variables must be categorical")
        data2 <- do.call("expand.grid", lapply(data2, unique))
    }        
    else if (population == "SAS" && method != "SGTT") {
        # expand the data set, but who would want to do this?
        stop("cannot yet have population=SAS and not use the SGTT")
    }
}

# Now create the estimate matrix one row at at time, and create the
#  APV (average predicted value) estimates and their std
emat <- matrix(0., nrow(data1), length(fit$coef))
apv  <- matrix(0., nrow(data1), ncol=2)    
for (i in 1:nrow(data1)) {
    tdata <- cbind(data1[i,], data2)
    newmf <- model.frame(Terms, tdata, xlev= fit$xlevels)
    if (any(complex)) { # fix it
        stop("not yet done")
    }
    newx  <- model.matrix(Terms, tdata, xlev=fit$xlevels,
                          contrasts.arg = fit$contrasts)
    emat[i,] <- colMeans(newx)
}    
@ 



<<yates>>=
as.matrix.yates <- function(x, indent=4) {
    # Create the labels column
    space <- paste(rep(" ", indent), collapse="")
    namefun <- function(zed, indent) {
        if (is.list(zed)){
            sublist <- sapply(zed, is.list)
            if (any(sublist)) {
                i2 <- paste0(space, indent)
                n2 <- names(zed)[sublist]
                temp <- lapply(zed[sublist], namefun, indent=i2)
                for (i in 1:length(temp)) 
                    temp[[i]] <- paste0(i2, c(n2[i], temp[[i]]))
                c(paste0(indent, attr(zed, "label")),
                  unlist(temp, use.names=FALSE))
            }
            else NULL
        }
        else  NULL
    }
    tname <- namefun(x, "")

    # unlist a particular element of the array
    grabit <- function(x, what) {
        sublist <- sapply(x, is.list)
        temp <- if (what %in% names(x) && length(x[[what]])==1) x[[what]] 
                else NA
        if (any(sublist)) c(temp, unlist(lapply(x[sublist], grabit, what=what)))
        else temp
    }
 
    temp <- cbind(grabit(x, "estimate"),
                  sqrt(grabit(x, "var")),
                  grabit(x, "test"),
                  grabit(x, "df"),
                  grabit(x, "ss"))
    dimnames(temp) <- list(tname, c("estimate", "std", "test", "df", "SS"))
    if (all(is.na(temp[,5]))) temp <- temp[, -5]
    temp
}

print.yates <- function(x, ...) 
    print(as.matrix(x), na.print="")
@ 
