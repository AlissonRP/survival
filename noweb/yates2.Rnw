Now for the primary function.
The user may have a list of tests, or a single term.

<<yates>>=
yates <- function(fit, test, population=c("data", "factorial", "none", "sas"),
                  method=c("direct", "sgtt"), 
                  ss, ...) {
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)
    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    xassign <- fit$assign
    nvar <- length(xassign)
    nterm <- length(Tatt$term.names)
    termname <- rownames(Tatt$factors)
    
    if (is.null(fit$contrasts)) iscat <- rep(FALSE, nterm)
    else iscat <- sapply(fit$contrasts, 
                         function(x) x %in% c("character", "factor"))
    
    if (missing(method)) method <- "direct"
    method <- match.arg(casefold(method), c("direct", "sgtt")) #allow SGTT
    if (method=="sgtt" && missing(population)) population <- "SAS"

    if (is.character(population))  population <- match.arg(population)
    else {
        if (!inherits(population, "data.frame"))
            stop("the population argument must be a data frame or character")
        pdata <- population
        population <- "user"
        }
 
    if (method=="sgtt" && population !=SAS)
        stop("sgtt method only applies if population = SAS")

    beta <-  coef(fit)
    nabeta <- is.na(beta)  # undetermined coefficients
    vmat <-  vcov(fit)
    
    # grab the dispersion
    if (missing(ss)) do.ss <- FALSE
    else do.ss <- ss
    if (class(fit)[1] =="lm") {
        if (missing(ss)) do.ss <- TRUE
        sigma <- summary(fit)$sigma
        }
    else if(class(fit)[1]=="glm") {
        sigma <- summary(fit)$dispersion
#        if (is.null(sigma)) sigma <- 1
        }
    else sigma <- NULL

    # A bit of trickery to allow users to type "cm" instead of "cmatrix"
    ff <- parent.frame()
    tempenv <- new.env(parent=ff)
    assign("cm", function(...) cmatrix(fit, ...), env=tempenv)
    test <- eval(substitute(test), tempenv)
    if (is.character(test) || inherits(test, "formula"))
        test <- cmatrix(fit, test)

    # check that the test argument is legal: each element should have
    #  class "cmatrix"
    # it can be a list or nested list of such elements, with optional names
    legal <- function(x) {
        if (inherits(x, "cmatrix")) TRUE
        else if (is.list(x)) all(sapply(x, legal))
        else FALSE
    }
    if (!legal(test))
        stop("the test argument should contain elements of class cmatrix")
    xassign <- attr(fit, "assign")
    
    # create a data set that will be used for the reconstruction
    if (method=="sgtt") pdata <- model.matrix(fit)
    else {
        <<yates-build-pdata>>
    }
    
    # process the tests
    #  if the argument is a list of tests, the dummy function simply iterates
    #  over the list, or sublists of list elements, etc.
    dummy <- function(x) {
        if (inherits(x, "cmatrix")) dotest(x, method, population)
        else lapply(x, dummy)
    }
    dotest <- function(cm, method, population) {
        if (is.na(match(cm$termname, colnames(Tatt$factors))))
            stop("term '", cm$tername, "' not found in the model")
        if (method == "sgtt"){
            <<yates-build-sgtt>>
        else {
            <<yates-build-apv2>>
        }
        
        cfun(Cmat, beta, vmat, sigma^2)
    }
    result <- dummy(test)
    class(result) <- "yates"
    result
}
@

The \code{cmatrix} object contains three peices of information: the term of
the model that will be tested, a set of data values used to populate that
term and give a set of targets,  and the contrast(s) that will be
applied to those predicted values.  

For each contrast the first step is to create the average predicted
value (APV) matrix.
For the SGTT algorithm this is accomplished by a manipulation of the
original $X$ matrix.  Otherwise
each row of APV is, formally, the column sums of a new model.matrix call that
had the selected values for x1 + the population for x2.  
This is a fairly straightforward task using the original data set.
The rub is that we don't have the original data set, we have the model frame.
If someone has a term like \code{ns(age, df=4)} in the model then the mf
will not have age, and we won't have access inverse function -- it could even
be a user defined function.  
One approach is to try to grab the original data, but that is dangerous: 
it might be gone, or it might have changed.  
Particularly if the model did not use data= as the source of the data 
re-fetching variables will be dicey.

The primary trick is to change our point of view: that the mf \emph{is} the
raw data, it is just a data set with funny variable names.
This is in fact how R treats the model frame when creating the model matrix.
Some issues:
\begin{itemize}
  \item Model frames have the terms structure that generated them attached,
    and they need to match it: you cannot add, subtract, or rearrange columns.
    This simply means some extra care when manipulating them.
  \item If values for x1 were given by the user, they will be in the original
    variable names.  The fit object contains the information needed to transform
    it.
  \item If population=user we build a model frame for x2, and use it to overlay
    select columns of the mf.  
  \item If population=factorial then all of the variables in x2 must be
    categorical, and \code{fit\$xlevels} contains the values.  
  \item We treat population=none the same way as population=data, then
    after building the model matrix only the x1 columns are used to create
    the apv.  
\end{itemize}

<<yates-build-pdata>>=
mf <- model.frame(fit)
x1index <- (Tatt$factors[,cm$termname] >0)      # which variables(s) in x1
x2index <- !x1index                             # which are in x2
if (population == "factorial") {
    if (any(!iscat[x2indx]))
        stop("population=factorial requires that all the adjusting terms are categorical")
    temp <- do.call("expand.grid", fit$xlevels)
    if (ncol(pdata) != ncol(mf)) { #x1 is not categorical: rare
        pdata <- mf[rep(1:nrow(mf), length=nrow(temp)), ]
        pdata[,names(temp)] <- temp
        }
    for (i in c('terms', 'class', 'na.action'))
        attr(pdata, i) <- attr(mf, i)
    }

} else if (population=="user") {
    # very often they will have all the variables, both x1 and x2. Try
    p2 <- try(model.frame(Terms, data=pdata))
    if (class(p2) == "model.frame") pdata <- p2
    else {
        # Only grab the terms for x2
        pdata <- model.frame(Terms[x2], data=pdata)
        }

} else if (population == "SAS") 
    stop("can't use population=SAS and method=direct")
else pdata <- mf
@ 

Now create the data for x1 from the levels component of the
test. 
\begin{itemize}
  \item If x1 is missing and population=none the routine will work directly
    with the model matrix and we don't need to do anything.  Otherwise a
    missing x1 is fatal: we can't give an answer when we don't know the
    question.
  \item Most of the time x1 will be a factor and the user will
    not have specified levels, in which case they are easily filled in
    from xlevels: the assumption will be ``all combinations''.
  \item If x1 is not a factor and there are no levels, we can only proceed if
    population=none, in which case x is set to a diagonal matrix.

@ 
The code to fill in a value for a 
<<fillin-x>>=
if (length(vnames[[i]]) != 1)
    stop("cannot reconstruct data for ", 
         deparse(Tatt$variables[[i+1]]))
else tname <- unlist(vnames[[i]])  # the name in the data frame

if (iscat[i]) z <- rep(fit$xlevels[[termnames[i]]], nrow(pdata2))
else z <- seq(.1, 2, length=nrow(pdata2))  #continuous variable
pdata[[unlist(vnames[[i]])]] <- z      # stick it in
if (is.call(Tatt$variables[[i+1]])) {
    # it's not just a name
    tcall <- Tatt$variables[[i+1]]  # save coding keystrokes
    bad <- c("$", "[", "[[", "get")
    if (any(sapply(bad, function(x) zz[[1]] == as.name(x))))
        stop("formulas can not use redirection")
    
    temp <- try(eval(tcall, pdata), silent=TRUE)
    if (class(temp) == "try-error" || !any(is.finite(temp)))
        stop("cannot reconstruct data for ", 
                     deparse(Tatt$variables[[i+1]]))
    else if (!all(j <- is.finite(temp))) {
        z <- rep(z[j], length=nrow(pdata2))
        pdata[[unlist(vnames[[i]])]] <- z
    }
}
@ 

<<fillin-x1>>=
<<<<<<< working copy
=======
@ 
<<yates-build-none>>=
#  The population="none" case. cm will be a cmatrix object
index <- match(cm$termname, Tatt$term.labels)
whichcol <- which(xassign %in% index)  #columns to fill in
ncol <- length(whichcol)
if (is.null(cm$levels)) {
    # population = none is the one case where we allow values for 
    #  x1 to be unspecified.  
    apv <- matrix(0., nrow=ncol, ncol=nvar)
    apv[,whichcol] <- diag(ncol)
}
else {
    apv <- matrix(0., nrow=nrow(cm$levels), ncol=nvar)
    
    
ncoef <- length(xassign)
whichcol <- which(xassign %in% index)  #columns to fill in
clevel <- cm$levels
nullcm <- sapply(clevel, is.null)
if (all(nullcm)) {
    Xmat <- matrix(0., nrow=length(whichcol), ncol=ncoef)
    Xmat[,whichcol] <- diag(length(whichcol))
}
else if (any(nullcm))                            
    stop("can't handle this type of mixed term, yet")
else {
    # Get the inner part of each name, e.g, ns(age, df=3) turns into "age".
    #  The line below is killing a fly with a triphammer, but we only run
    #  it once.  
    pname <- names(clevel)
    for (i in 1:length(pname)) pname[i] <- all.vars(parse(text=pname[i]))[1]
    
    if (!is.data.frame(clevel)) clevel <- do.call("expand.grid", clevel)
    Xmat <- matrix(0., nrow=nrow(clevel), ncol=ncoef)
    for (i in 1:ncol(clevel)) {
        cname <- names(clevel)[i]
        ccol <- which(xassign== index[i])
        if (cm$iscat[i]) {
            if (length(ccol) < length(fit$xlevels[[cname]])) 
                temp <- get(fit$contrasts[[cname]])(length(ccol))
            else temp <- get(fit$contrasts[[cname]])(length(ccol),
                                                     contrasts=FALSE)
            Xmat[,ccol] <- temp[match(clevel[[i]], fit$xlevels[[cname]]),]
        }
        else { # continuous
            j <- match(cname, row.names(Tattr$factors))
            pcall <- Tattr$predictCall[[j+1]] #skip the "list" element
            if (is.call(pcall)) {
                temp <- list(clevel[[i]])
                names(temp) <- pname[i]
                Xmat[,ccol] <- eval(pcall, temp)
            }
            else if (is.name(temp)) {
                if (length(ccol) !=1) stop("logic error")
                Xmat[,ccol] <- clevel[[i]]
            }
            else stop("logic error 2")  #should be impossible
        }
    }
}
@ 

Now go through the contrast matrices 1 by 1 and evaluate them.
<<yates-build-none>>=
if (is.list(cm$cmatrix)) 
    r1 <- sapply(cm$cmatrix, function(z) cfun(z, beta, vmat, sigma^2))
else r1 <- cfun(cm$cmatrix, beta, vmat, sigma^2)
@ 

<<yates-build-apv1>>=
@ 
<<yates-build-apv2>>=
@ 

<<yates-build-sgtt>>=
@ 


