Now for the primary function.
The user may have a list of tests, or a single term.
The first part of the function does the usual of grabbing arguments
and then checking them.
The fit object has to have the standard stuff: terms, assign, xlevels
and contrasts. 
Attributes of the terms are used often enough that we copy them
to \code{Tatt} to save typing.
We will almost certainly need the model frame and/or model matrix as
well.

In the discussion below I use x1 to refer to the covariates/terms that are
the target, e.g. \code{test='Mask'} to get the mean population values for
each level of the Mask variable in the solder data set, and x2 to refer to
all the other terms in the model, the ones that we average over.  
These are also referred to as U and V in the vignette.

<<yates>>=
yates <- function(fit, term, population=c("data", "none", "factorial", "sas"),
                  levels, test=c("global", "trend", "pairwise"),
                  type="linear", method=c("direct", "sgtt"), 
                  dispersion, ...) {
    Call <- match.call()
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)
    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    # a flaw in delete.response: it doesn't subset dataClasses
    Tatt$dataClasses <- Tatt$dataClasses[row.names(Tatt$factors)]
    
    # we will need the original model frame ans X matrix
    mframe <- fit$model
    if (is.null(mframe)) mframe <- model.frame(fit)
    Xold <- model.matrix(fit)
    if (is.null(fit$assign)) { # glm models don't save assign
        xassign <- attr(Xold, "assign")
    }
    else xassign <- fit$assign 

    nvar <- length(xassign)
    nterm <- length(Tatt$term.names)
    termname <- rownames(Tatt$factors)
    iscat <- sapply(Tatt$dataClasses, 
                    function(x) x %in% c("character", "factor"))
    
    method <- match.arg(casefold(method), c("direct", "sgtt")) #allow SGTT
    if (method=="sgtt" && missing(population)) population <- "sas"

    if (is.character(population)) {
        population <- match.arg(tolower(population[1]),
                                c("data", "none", "factorial", "sas",
                                  "empirical", "yates"))
        if (population=="empirical") population <- "data"
        if (population=="yates") population <- "factorial"
    }
    else {
        if (!inherits(population, "data.frame"))
            stop("the population argument must be a data frame or character")
        pdata <- population
        population <- "user"
        }
    test <- match.arg(test)
    
    if (method=="sgtt" && (population !="sas" || type != "linear"))
        stop("sgtt method only applies if population = sas and type = linear")

    beta <-  coef(fit, complete=TRUE)
    nabeta <- is.na(beta)  # undetermined coefficients
    vmat <-  vcov(fit, complete=FALSE)
    if (nrow(vmat) > sum(!nabeta)) {
        # a vcov method that does not obey the complete argument
        vmat <- vmat[!nabeta, !nabeta]
    }
    
    # grab the dispersion, needed for the writing an SS in linear models
    if (missing(dispersion)) do.ss <- FALSE
    else do.ss <- dispersion
    if (class(fit)[1] =="lm") {
        if (missing(dispersion)) do.ss <- TRUE
        sigma <- summary(fit)$sigma
        }
    else if(class(fit)[1]=="glm") {
        sigma <- summary(fit)$dispersion
#        if (is.null(sigma)) sigma <- 1
        }
    else sigma <- NULL
    
    # process the term argument and check its legality
    if (missing(levels)) 
        contr <- cmatrix(fit, term, test)
    else contr <- cmatrix(fit, term, test, levels)
    x1data <- as.data.frame(contr$levels)  # labels for the MPV values
    
    # Make the list of X matrices that drive everything: xmatlist
    #  (Over 1/2 the work of the whole routine)
    if (population == "none") xmatlist <- yates_none()
    else if (population == "user") xmatlist <- yates_xmat_user()
    else xmatlist <- yates_xmat(Terms, Tatt, contr, population, mframe, fit)

    # check rows of xmat for estimability
    <<yates-estim-setup>>
    
    # Now use xmatlist to compute the results
    if (type != "linear") 
        mfun <- yates_model_setup(fit, type)
    if (type == "linear" || is.null(mfun)) {
        # population averages of the simple linear predictor
        <<yates-linear>>
    }
    else stop("nonlinear portion still in development")
    class(result) <- "yates"
    result
}
@

Models with factor variables may often lead to population predictions that
involve non-estimable functions, particularly if there are interactions
or the user specifies a factorial population.  
If there are any missing coefficients we have to do formal checking for
this: any given row of the new $X$ matrix, for prediction, must be in the
row space of the original $X$ matrix. 
If this is true then a regression of a new row on the old $X$ will have 
residuals of zero.
It is not possible to derive this from the pattern of NA coefficients alone.
Set up a function that returns a true/false vector of whether each row of
a matrix is estimable.  This test isn't relevant if population=none.

<<yates-estim-setup>>=
if (any(is.na(beta)) && population != "none") {
    if (inherits(fit, "coxph")) X.qr <- qr(rbind(1, t(Xold)))
    else  X.qr <- qr(t(Xold))   # QR decomposition of the row space
    estimcheck <- function(x, eps= sqrt(.Machine$double.eps)) {
        temp <- abs(qr.resid(X.qr, t(x)))
        # apply(abs(temp), 1, function(x) all(x < eps)) # each row estimable
        all(temp < eps)
    }
    estimable <- sapply(xmatlist, estimcheck)
} else estimable <- rep(TRUE, length(xmatlist))
@ 

When the prediction target is $X\beta$ there is a four step
process: build the reference population, create the list of X matrices
(one prediction matrix for each for x1 value), 
column means of each X form each row of the
contrast matrix Cmat, and then use Cmat to get the mpv values and
tests of the mpv values.

<<yates-linear>>=
if (is.na(match(contr$termname, colnames(Tatt$factors))))
    stop("term '", contr$termname, "' not found in the model")

Cmat <- t(sapply(xmatlist, colMeans))
          
# coxph model: the X matrix is built as though an intercept were there (the
#  baseline hazard plays that role), but then drop it from the coefficients
#  before computing estimates and tests.
if (inherits(fit, "coxph")) Cmat <- Cmat[,-1, drop=FALSE]
    
# Get the MPV estimates, but only for estimable ones
estimate <- cbind(x1data, mpv=NA, std=NA)
if (any(estimable)) {
    etemp <- estfun(Cmat[estimable,,drop=FALSE], beta, vmat)
    estimate$mpv[estimable] <- etemp$estimate
    estimate$std[estimable] <- sqrt(diag(etemp$var))
}
    
# Now do tests on the MPV estimates, one by one
if (method=="sgtt") {
        <<yates-sgtt>>
}
else {
    if (is.list(contr$cmat)) {
        test <- t(sapply(contr$cmat, function(x)
                         testfun(x %*% Cmat, beta, vmat, sigma^2)))
        natest <- sapply(contr$cmat, nafun, estimate$mpv)
    }
    else {
        test <- testfun(contr$cmat %*% Cmat, beta, vmat, sigma^2)
        test <- matrix(test, nrow=1, 
                       dimnames=list(contr$termname, names(test)))
        natest <- nafun(contr$cmat, estimate$mpv)
    }
    if (any(natest)) test[natest,] <- NA
    if (any(estimable))
        result <- list(estimate=estimate, test=test, mvar=etemp$var)
    else  result <- list(estimate=estimate, test=test, mvar=NA)
}
@ 

Build the population data set. 
If the user provided a data set as the population then the task is
fairly straightforward: we manipulate the data set and then call
model.frame followed by model.matrix in the usual way.
The primary task in that
case is to verify that the data has all the needed variables.

Otherwise we have to be subtle.
\begin{enumerate}
  \item We have ready access to a model frame, but not to the data.
    Consider a spline term for instance --- it's not always possible
    to go backwards and get the data.
  \item We need to manipulate this model frame, e.g., make everyone
    treatment=A, then repeat with everyone treatment B.
  \item We need to do it in a way that makes the frame still look
    like a correct model frame to R.  This requires care.
\end{enumerate}

For population= factorial we create a population data set that has all
the combinations.  If there are three adjusters z1, z2 and z3 with
2, 3, and 5 levels, respectively, the new data set will have 30
rows.  
If the primary model didn't have any z1*z2*z3 terms in it we
likely could get by with less, but it's not worth the programming effort
to figure that out: predicted values are normally fairly cheap.
For population=sas we need a mixture: categoricals are factorial and others
are data.  Say there were categoricals with 3 and 5 levels, so the factorial
data set has 15 obs, while the overall n is 50.  We need a data set of 15*50
observations to ensure all combinations of the two categoricals with each
continuous line.

An issue  with data vs model is names.  Suppose the original model was
\code{lm(y \textasciitilde ns(age,4) + factor(ph.ecog))}.
In the data set the variable name is ph.ecog, in the model frame,
the xlevels list, and terms structure it is factor(ph.ecog). 
The data frame has individual columns for the four variables, the model frame
is a list with 3 elements, one of which is named ``ns(age, 4)'': notice the
extra space before the 4 compared to what was typed.

<<yates>>=
yates_xmat <- function(Terms, Tatt, contr, population, mframe, fit) {
    vnames <- lapply(Tatt$variables, all.vars)[-1]  # first element was "list"
    x1indx <- (Tatt$factors[,contr$termname] >0)      # which variables(s) in x1
    x2indx <- !x1indx
    if (population=="data") pdata <- mframe  #easy case
    else if (population=="factorial") 
        pdata <- yates_factorial_pop(mframe, Terms, x2indx, fit$xlevels)
    else if (population=="sas") {
        if (all(iscat(x2indx))) 
            pdata <- yates_factorial_pop(mframe, Terms, x2indx, fit$xlevels)
        else if (!any(iscat(x2indx))) pdata <- mframe # no categoricals
        else { # mixed population
            pdata <- yates_factorial_pop(mframe, Terms, x2indx, fit$xlevels)
            n2 <- nrow(pdata)
            pdata <- pdata[rep(1:nrow(pdata), each=nrow(mframe)), ]
            row.names(pdata) <- 1:nrow(pdata)
            # fill in the continuous
            k <- rep(1:nrow(mframe), n2)
            for (i in which(!iscat(x2indx))) {
                j <- names(x1indx)[i]
                if (is.matrix(mframe[[j]])) 
                    pdata[[j]] <- mframe[[j]][k,, drop=FALSE]
                else pdata[[j]] <- (mframe[[j]])[k]
                attributes(pdata[[j]]) <- attributes(mframe[[j]])
            }
        }
    }
    else if (population=="user") {
        # nothing needs to be done
    }

    # Now create the x1 data set, the unique rows we want to test
    <<yates-x1mat>>
    
    xmatlist
}
@ 

Build a factorial data set from a model frame. 
<<yates>>=
yates_factorial_pop <- function(mframe, terms, x2indx, xlevels) {
    x2name <- names(x2indx)[x2indx]
    dclass <- attr(terms, "dataClasses")[x2name]
    if (!all(dclass %in% c("character", "factor")))
        stop("population=factorial only applies if all the adjusting terms are categorical")
   
    nvar <- length(x2name)
    n2 <- sapply(xlevels[x2name], length)  # number of levels for each
    n <- prod(n2)                          # total number of rows needed
    pdata <- mframe[rep(1, n), -1]  # toss the response
    row.names(pdata) <- NULL        # throw away funny names
    n1 <- 1
    for (i in 1:nvar) {
        j <- rep(rep(1:n2[i], each=n1), length=n)
        xx <- xlevels[[x2name[i]]]
        if (dclass[i] == "factor") 
            pdata[[x2name[i]]] <- factor(j, 1:n2[i], labels= xx)
        else pdata[[x2name[i]]] <- xx[j]
        n1 <- n1 * n2[i]
    }
    attr(pdata, "terms") <- terms
    pdata
}
@ 

The next section builds a set of X matrices, one for each level of the
x1 combination. 
The following was learned by reading the source code for
model.matrix:
\begin{itemize}
\item If pdata has no terms attribute then model.matrix will call model.frame
  first, otherwise not.  The xlev argument is passed forward to model.frame
  but is otherwise unused.
\item If necessary, it will reorder the columns of pdata to match the terms,
  though I try to avoid that.  
\item Toss out the response variable, if present.
\item Any character variables are turned into factors.  The dataClass attribute
  of the terms object is not consulted.
\item For each column that is a factor
  \begin{itemize}
    \item if it alreay has a contrasts attribute, it is left alone.
    \item otherwise a contrasts attribute is added using a matching
      element from contrasts.arg, if present, otherwise the global default
    \item contrasts.arg must be a list, but it does not have to contain all
      factors
  \end{itemize}
  \item Then call the internal C code
\end{itemize}

If pdata already is a model frame we want to leave it as one, so as to
avoid recreating the raw data.
The x1data comes from the user though, so we need to do that portion of
model.frame processing ourselves, in order to get it into the right
form.  Always turn characters into factors, since individual elements
of \code{xmatlist} will have only a subset of the x1 variables.
One nuisance is name matching.  Say the model had 
\code{factor(ph.ecog)} as a term; then \code{fit\$xlevels} will have
`factor(ph.ecog)' as a name but the user will likely have created a
data set using `ph.ecog' as the name.

<<yates-x1mat>>=
if (is.null(contr$levels)) stop("levels are missing for this contrast")
x1data <- as.data.frame(contr$levels)  # in case it is a list
x1name <- names(x1indx)[x1indx]
for (i in 1:ncol(x1data)) {
    if (is.character(x1data[[i]])) {
        if (is.null(fit$xlevels[[x1name[i]]])) 
            x1data[[i]] <- factor(x1data[[i]])
        else x1data[[i]] <- factor(x1data[[i]], fit$xlevels[[x1name[i]]])
    }
}

xmatlist <- vector("list", nrow(x1data))
if (is.null(attr(pdata, "terms"))) {
    np <- nrow(pdata)
    pdata <- pdata[[x2name]]  # data set order does not matter
    for (i in 1:nrow(x1data)) {
        j <- rep(i, np)
        tdata <- cbind(pdata, x1data[j,,drop=FALSE]) # new data set
        xmatlist[[i]] <- model.matrix(Terms, tdata, xlev=fit$xlevels,
                                      contrast.arg= fit$contrasts)
    }
} else {
    # pdata is a model frame, convert x1data
    # if the name agrees but not the class, do a simple conversion
    # if names don't agree, call model.frame
    index <- match(names(x1data), names(pdata), nomatch=0)
    if (all(index >0)) { # names agree
        for (i in 1:nrow(x1data)) {
            j <- rep(i, nrow(pdata))
            tdata <- pdata
            tdata[,names(x1data)] <- x1data[j,]
            xmatlist[[i]] <- model.matrix(Terms, tdata,
                                           contrasts.arg= fit$contrasts)
        }
    }
    else if (any(index > 0)) {
        # some names match and some don't
        stop("impossible match in yates, contact author")
    }
    else {
        # create a subset of the terms structure, for x1 only
        x1term <- Terms[which(x1indx)]
        x1name <- names(x1indx)[x1indx]
        attr(x1term, "dataClasses") <- Tatt$dataClasses[x1name] # R bug
        x1frame <- model.frame(x1term, x1data, xlev=fit$xlevels[x1name])
        for (i in 1:nrow(x1data)) {
            j <- rep(i, nrow(pdata))
            tdata <- pdata
            tdata[,names(x1frame)] <- x1frame[j,]
            xmatlist[[i]] <- model.matrix(Terms, tdata, xlev=fit$xlevels,
                                      contrast.arg= fit$contrasts)
        }
    }
}      
@ 

<<yates>>=
yates_none <- function(Terms, Tatt, contr, xassign) {
    #  The population="none" case. contr will be a cmatrix object
    index <- match(contr$termname, Tatt$term.labels)
    whichcol <- which(xassign %in% index)  #columns to fill in
    ncol <- length(whichcol)
    if (is.null(contr$levels)) {
        # population = none is the one case where we allow values for 
        #  x1 to be unspecified.  
        apv <- matrix(0., nrow=ncol, ncol=nvar)
        apv[,whichcol] <- diag(ncol)
    }
    else {
        apv <- matrix(0., nrow=nrow(contr$levels), ncol=nvar)
    }    

    ncoef <- length(xassign)
    whichcol <- which(xassign %in% index)  #columns to fill in
    clevel <- contr$levels
    nullcontr <- sapply(clevel, is.null)
    if (all(nullcontr)) {
        Xmat <- matrix(0., nrow=length(whichcol), ncol=ncoef)
        Xmat[,whichcol] <- diag(length(whichcol))
    }
    else if (any(nullcontr))                            
        stop("can't handle this type of mixed term, yet")
    else {
        # Get the inner part of each name, e.g, ns(age, df=3) turns into "age".
        #  The line below is killing a fly with a triphammer, but we only run
        #  it once.  
        pname <- names(clevel)
        for (i in 1:length(pname)) pname[i] <- all.vars(parse(text=pname[i]))[1]

        if (!is.data.frame(clevel)) clevel <- do.call("expand.grid", clevel)
        Xmat <- matrix(0., nrow=nrow(clevel), ncol=ncoef)
        for (i in 1:ncol(clevel)) {
            cname <- names(clevel)[i]
            ccol <- which(xassign== index[i])
            if (contr$iscat[i]) {
                if (length(ccol) < length(fit$xlevels[[cname]])) 
                    temp <- get(fit$contrasts[[cname]])(length(ccol))
                else temp <- get(fit$contrasts[[cname]])(length(ccol),
                                                         contrasts=FALSE)
                Xmat[,ccol] <- temp[match(clevel[[i]], fit$xlevels[[cname]]),]
            }
            else { # continuous
                j <- match(cname, row.names(Tattr$factors))
                pcall <- Tattr$predictCall[[j+1]] #skip the "list" element
                if (is.call(pcall)) {
                    temp <- list(clevel[[i]])
                    names(temp) <- pname[i]
                    Xmat[,ccol] <- eval(pcall, temp)
                }
                else if (is.name(temp)) {
                    if (length(ccol) !=1) stop("logic error")
                    Xmat[,ccol] <- clevel[[i]]
                }
                else stop("logic error 2")  #should be impossible
            }
        }
    }
    # Now go through the contrast matrices 1 by 1 and evaluate them.
    if (is.list(contr$cmatrix)) 
        r1 <- sapply(contr$cmatrix, function(z) cfun(z, beta, vmat, sigma^2))
    else r1 <- cfun(contr$cmatrix, beta, vmat, sigma^2)
}
@ 
 
The decompostion based algorithm for SAS type 3 tests.
The algorithm will ignore the set of contrasts cmat; the algorithm can only
do a global test.
First make a $Z$ matrix, which is the $X$ matrix using only the unique
categorical variable rows.
Our goal is to find an upper triangular matric $C$ such that 
$C (Z'Z)^-C'$ has zeros in any block corresponding two factor terms, one of
which contains the other.
If $Z$ is full rank we are in the Yates' situation and the cholesky 
decomposition of $Z'Z$ is a solution.
If it is not full rank we need to mimic SAS and make sure that 
these ``one term contains another'' blocks are
the \emph{only} blocks that we make orthagonal.
Treat $Z'Z$ as a block matrix
\begin{equation*}
  \left( \begin{array}{cccc} 
    B_{11} & B_{12} & \ldots & B_{1k} \\
    B_{21} & B_{22} & \ldots & B_{2k} \\
    \vdots& \vdots& \ddots & \vdots \\
     B_{k1} & B_{k2} & \ldots & B_{kk}  \end{array} \right )
\end{equation*}
with each term in the model as a block, and assume that blocks $i$ and $j$
need to be orthagonal. 
The number of terms $k$ is the number of columns in the \code{factors}
component of the terms object for the model.
(Well almost:  if there is an intercept colum it does not appear in the
\code{factors} matrix.)
A contrast matrix $C$ that fullfills our requirements will have
\begin{align*}
  C_{i.} (Z'Z)^- C'_{j.} & = 0 \\
\end{align*}
for the required pairs of blocks $i$ and $j$,
where $(Z'Z)^-$ is a generalized inverse.
The standard order of terms in the $X$ matrix means that any term $j$
that contains term $i$ will be further to the right in the matrix.
One solution is to start with $C$ as an identity matrix and then
fill in the relevant blocks above the diagonal.
\begin{align*}
  V &= (Z'Z)^- \\
  C_{ij} &= -V_{ij} V_{jj}^{-1}, \, j>i
\end{align*}


Using the formula for the inverse of a symmetric partitioned matrix
\begin{equation}
  \left( \begin{array}{cc} E & F \\ G & H \end{array} \right)^{-1} =
  \left( \begin{array}{cc} (E- FH^{-1}G)^{-1} & -E^{-1}F (H - GE^{-1}F)^{-1} \\
                           -H^{-1}G(E- FH^{-1}G)^{-1} &  (H - GE^{-1}F)^{-1} 
  \end{array} \right) \label{partition}
\end{equation}
this gives 
\begin{equation}
  C_{ij} = B_{ii}^{-1} B_{ij} \label{inverse}
\end{equation}
Well, not quite.  The right formula is
\code{solve(B[-j,-j], B[-j, j])[i,]}: when dividing the matrix into
$k$ pieces one has to use all but the column of interest in formula
\eqref{partition}.

Continuous variables are not orthagonalized in the SAS type III approach,
nor any interaction that contains a continuous variable as one of its parts.
To find the nested terms first note which rows of \code{factors} refer
to categorical variables (the \code{iscat} variable);
columns of \code{factors} that are non-zero only
in categorical rows are the ``categorical'' columns.
A term represented by one column in \code{factors} ``contains'' the term 
represented in some other column iff it's non-zero elements are a superset.

The entire process below is simpler if we work only with the non-missing
coefficients.  If all of the models obeyed the \code{complete} argument
of the coef() and vcov() methods that would suffice, but they often don't 
so we first have to check.
<<yates-sgtt>>=
# create Z
whichrows <- !duplicated(mframe[names(iscat)[iscat]])
Z <- Xold[whichrows,]
beta2 <- beta[!nabeta]
Z <- Z[,!nabeta]
ztz <- t(Z) %*% Z
#zvar <- solve(ztz)
assign2 <- xassign[!nabeta]

# Create the contrast matrix
Cmat <- diag(ncol(Z))
# which terms are factors?
fterm <- apply(Tatt$factors[!iscat,, drop=FALSE], 2, function(x)!any(x>0))
for (iterm in which(fterm)) {  # might be none
    for (j in (iterm:length(fterm))) { # all terms to the right
        # the term includes iterm if it has non-zeros wherever iterm does
        irow <- which(Tatt$factors[,iterm] > 0)
        if (j> iterm && fterm[j] && all(Tatt$factors[irow, j] >0)) {
            i1 <- which(assign2 == iterm)  # colums for the first term
            i2 <- which(assign2 == j)      # and for the second
            Cmat[i1, i2] <- solve(ztz[-i2, -i2], ztz[-i2,i2])[i1,]  
            # Cmat[i1, i2] <- -t(solve(zvar[i2, i2], zvar[i2, i1]))
        }
    }
}   
@ 

Should we print only the term of interest, or all of them?
At this point ``all'' is a touch easier.
Fix it later.
<<yates-sgtt>>=
if (max(xassign) >1) { # more than 1 term in the model
    test <- t(sapply(1:max(assign2), function(i)
                   testfun(Cmat[assign2==i,,drop=FALSE], beta2, vmat, sigma^2)))
    rownames(test) <- colnames(Tatt$factors)
}  else {
    test <- testfun(Cmat[assign2==1,, drop=FALSE], beta2, vmat, sigma^2)
    test <- matrix(test, nrow=1, 
                   dimnames=list(colnames(Tatt$factors), names(test)))
}
@ 


The print routine places the population predicted values (PPV) alongside the
tests on those values.  Defaults are copied from printCoefmat.

<<yates>>=
print.yates <- function(x, digits = max(3, getOption("digits") -2),
                        dig.tst = max(1, min(5, digits-1)),
                        eps=1e-8, ...) {
    temp1 <- x$estimate
    temp1$mpv <- format(temp1$mpv, digits=digits)
    temp1$std <- format(temp1$std, digits=digits)

    # the spaces help separate the two parts of the printout
    temp2 <- cbind(test= paste("    ", rownames(x$test)), 
                   data.frame(x$test), stringsAsFactors=FALSE)
    row.names(temp2) <- NULL
    temp2$Pr <- format.pval(pchisq(temp2$chisq, temp2$df, lower.tail=FALSE),
                            eps=eps)
    temp2$chisq <- format(temp2$chisq, digits= dig.tst)
    temp2$df <- format(temp2$df)
    if (!is.null(temp2$ss)) temp2$ss <- format(temp2$ss, digits=digits)
    
    if (nrow(temp1) > nrow(temp2)) {
        dummy <- temp2[1,]
        dummy[1,] <- ""
        temp2 <- rbind(temp2, dummy[rep(1, nrow(temp1)-nrow(temp2)),])
        }
    if (nrow(temp2) > nrow(temp1)) {
        # get rid of any factors before padding
        for (i in which(sapply(temp1, is.factor))) 
            temp1[[i]] <- as.character(temp1[[i]])
        
        dummy <- temp1[1,]
        dummy[1,] <- ""
        temp1 <- rbind(temp1, dummy[rep(1, nrow(temp2)- nrow(temp1)),])
        }
    print(cbind(temp1, temp2), row.names=FALSE)
    invisible(x)
}
@ 


Routines to allow yates to interact with other models.

<<yates>>=
yates_model_setup <- function(fit, ...)
    UseMethod("yates_model_setup", fit)

yates_model_setup.glm <- function(fit, type, ...) {
    if (type == "link") NULL # same as linear
    else if (type == "response") family(fit)$linkinv
    else if (type == "terms")
        stop("type terms not yet supported")
}

        
@ 
