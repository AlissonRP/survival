\section{Linear models and contrasts}
The primary contrast function is \code{yates}.  
This function does both simple and population contrasts; the name is a nod
to the ``Yates weighted means'' method, the first population contrast that
I know of.  
A second reason for the name is that
the word ``contrast'' is already overused in the S/R lexicon.
Both \code{yates}  and \code{cmatrix} can be used with any model that returns 
the necessary
portions, e.g., lm, coxph, or glm.
They were written because I became embroiled in the ``type III'' controversy,
and made it a goal to figure out what exactly it is that SAS does. 
If I had known that that quest would take multiple years would 
perhaps have never started.

Population contrasts can result in some head scratching.
It is easy to create the predicted value for any hypothethical
subject from a model.  
A population prediction holds some data values constant and lets the
others range over a population, giving a mean predicted value or
population average.  
Population predictions for two treatments are the familiar g-estimates
of causal models. 
We can take sums of differences of these predictions as well, e.g. to
ask if they are significantly different.
What can't be done is to work backwards from one of these contrasts to the
populations, at least for continuous variables.
If someone asks for an x contrast of 15-5 is this a sum of two population
estimates at 15 and -5, or a difference?  
It's always hard to guess the mind of a user.
Therefore what is needed is a fitted model, the term (covariate) of interest,
levels of that covariate, a desired comparison, and a population.

First is cmatrix routine.  This is called by users to create a contrast
matrix for a model, users can also construct their own contrast matrices.
The result has two parts: the definition of a set of predicted values and
a set of contrasts between those values.  
The routine requires a fit and a term; the default test will be for
the entire term.  The result will be a matrix or list that has a label
attribute containing the name of the term; this is used in printouts in the
obvious way.
Suppose that our model was \code{coxph(Surv(time, status) ~ age*sex + ph.ecog)}.
Someone might want the matrix for the age, sex, age*sex (2 df),
age:sex or ph.ecog term.
The first task is to parse the user's formula and match it to the terms
structure found in the data: we should be a proper subset of it.
  
<<yates>>=
cmatrix <- function(fit, term, levels, 
                    type=c("full", "linear", "pairwise")){
    # Make sure that "fit" is present and isn't missing any parts.
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)

    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    
    # a function that allows them to refer to terms by name or by number
    matchterm <- function(x) {
        nlab <- length(term.label)
        index <- pmatch(x, c(term.label, 1:nlab), nomatch=0) 
        index <- ifelse(index > nlab, index-nlab, index)
        c("", term.label)[1+index]
    }

    if (missing(term)) stop("a term argument is required")
    if (is.character(term)) term <- formula(paste("~", term))
    else if (is.numeric(term)) {
        if (all(term == floor(term) & term >0 & term < length(Tatt$term.labels)))
            term <- formula(paste("~", 
                                  paste(Tatt$term.labels[term], collapse='+')))
        else stop("a numeric term must be an integer between 1 and max terms in the fit")
        }
    else if (!inherits(term, "formula"))
        stop("the term must be a formula, character string, or integer")
    fterm <- delete.response(terms(term))
    fatt <- attributes(fterm)
    indx <- match(fatt$term.labels, Tatt$term.labels)
    if (any(is.na(indx))) {
        # allow partial matching.  If the fit had factor(x) but user said "x",
        #  pretend they said "factor(x)".  Fail for ns(x) + log(x) though.
        # but match the first for factor(x) + factor(x):z
        temp <- fatt$term.labels
        temp2 <- Tatt$term.labels
        temp2[grepl(":", temp2)] <- ""
        for (i in 1:length(temp)) {
            j <- grep(temp[i], Tatt$term.labels)
            k <- grep(temp[i], temp2)
            if (length(j)==1) temp[i] <- Tatt$term.labels[j]
            else if (length(k)==1) temp[i] <- Tatt$term.labels[k]
            else stop("term '", temp[i], "' not found in the fit")
            }
        fterm <- terms(formula( paste("~", paste(temp, collapse="+"))))
        fatt <- attributes(fterm)
        indx <- match(fatt$term.labels, Tatt$term.labels)
   }
    
    # match these up with the columns via the assign attribute
    xassign <- fit$assign
    if (missing(xassign)) stop("the fit is missing an assign component")
    if (is.list(xassign)) {
        # old style assign as used in Splus, and still used in coxph
        xassign <- rep(1:length(xassign), sapply(xassign, length))
    }
    ncoef <- length(xassign)
    whichcol <- which(xassign %in% indx & !is.na(coef(fit)))
    ntest <- length(whichcol)
    if (ntest ==0) stop("no non-missing coefficients in the estimate")
    termname <- Tatt$term.labels[indx]  # to label the output
    
    # What kind of term is being tested.  It can be categorical, continuous,
    #  an interaction of only categorical terms, interaction of only continuous
    #  terms, or a mixed interaction.
    parts <- row.names(Tatt$factors)[Tatt$factors[,indx] !=0]
    types <- Tatt$dataClasses[parts]
    iscat <- as.integer(types=="factor" | types=="character")
    if (length(parts)==1) termtype <-iscat
    else  termtype <- 2 + any(iscat) + all(iscat)


    # Were levels specified?  If so we either simply accept them (continuous),
    #  or double check them (categorical)
    if (missing(levels)) levels <- NULL
    else {  #user supplied
        if (is.data.frame(levels)) {
            temp <- match(names(levels), parts)
            if (any(is.na(temp)))
                stop("not found in levels data frame:", parts)
            else levels <- levels[temp]  # reorder it
            if (any(duplicated(levels))) stop("levels data frame has duplicates")
        }
        else if (is.list(levels)) {
            if (length(levels) != length(parts))
                stop("levels list should have", length(parts), "components")
            if (!is.null(names(levels))) {
                temp <- match(names(levels), parts)
                if (any(is.null(temp)))
                    stop("names of levels does not match the terms")
                else levels <- levels[temp]  #reorder them
            }
            if (any(sapply(levels, function(x) any(duplicated(x)))))
                stop("one or more elements of the levels list has duplicates")
            levels <- do.call("expand.grid", levels)
        }
        else if (is.matrix(levels)) {
            if (ncol(levels) != length(parts))
                stop("levels matrix has the wrong number of columns")
            if (!is.null(dimnames(levels)[[2]])) {
                temp <- match(dimnames(levels)[[2]], parts)
                if (any(is.na(temp)))
                    stop("matrix column names do no match the terms")
            } else dimnames(levels)[[2]] <- parts
            if (any(duplicated(levels)))
                stop("levels matrix has duplicated rows")
            levels <- data.frame(levels)
         }
        else if (length(parts) > 1)
            stop("levels should be a data frame or matrix")
        else levels <- data.frame(x=unique(levels))
        names(levels) <- parts 
    }

    # check that any categorical levels are legal
    for (i in which(iscat==1)) {
        xlev <- fit$xlevels[[parts[i]]]
        if (is.null(xlev))
            stop("xlevels attribute not found for", parts[i])
        temp <- match(levels[[parts[i]]], xlev)
        if (any(is.na(temp)))
            stop("invalid level for term", parts[i])
    }
    
    rval <- list(levels=levels, termname=termname)
    # Now add the contrast matrix between the levels, if needed
    <<cmatrix-build>>

    rval <- list(levels=levels, termname=termname, cmat=cmat, iscat=iscat)
    class(rval) <- "cmatrix"
    rval
}
@ 

Building the contrast matrix is very easy for type=full; it is simply
a test of ``are all these coefficients zero''.
The \code{pairwise} option creates a set of contrast matrices for all pairs
of a factor.
The  \code{linear} option is of interest for terms that have more than one
column; the two most common cases are a factor variable or a spline.
It forms a pair of tests, one for the linear and one
for the nonlinear part.  For non-linear functions such as splines we need
some notion of the range of the data, since we want to be linear over the
entire range.  

<<cmatrix-build>>=
type <- match.arg(type)
if (type=="full") cmat <- diag(ntest)
else {
    if (length(parts) > 1)
        stop(test, " tests must be for a single term")
    if (type=="pairwise") {
        tindex <- match(levels[[1]], levels[[1]])  #convert to integer
        nlev <- length(tindex)  # this is the number of groups being compared
        if (nlev < 2) stop("pairwise tests need at least 2 levels")
        npair <- nlev*(nlev-1)/2
        if (npair==1) cmat <- matrix(c(1, -1), nrow=1)
        else {
            cmat <- vector("list", npair)
            k <- 1
            for (i in 1:(nlev-1)) {
                temp <- double(nlev)
                temp[tindex[i]] <- 1
                for (j in (i+1):nlev) {
                    temp[tindex[j]] <- -1
                    cmat[[k]] <- matrix(temp, nrow=1)
                    temp[tindex[j]] <- 0
                    k <- k+1
                }
            }
        }
    }
    else if (type=="linear") {
        <<cmatrix-linear>>
    }
    else stop("unknown type")
}
@ 
    
The linear transform works for factors and splines.  It would in theory
work for polynomial terms as well, but I don't know a good way to pick
a range.  For splines, a prediction that is linear on the knots is linear
globally.

<<cmatrix-linear>>=
cmat <- vector("list", 2)
cmat[[1]] <- matrix(1:ntest, 1, ntest)
cmat[[2]] <- diag(ntest)
attr(cmat, "nested") <- TRUE
if (is.null(levels[[1]])) {
    # a continuous variable, and the user didn't give levels for the test
    #  look up the call and use the knots
    tcall <- Tatt$predvars[[indx + 1]]  # skip the 'call' 
    if (tcall[[1]] == as.name("pspline")) {
        bb <- tcall[["Boundary.knots"]]
        levels[[1]] <- seq(bb[1], bb[2], length=ntest)
    }
    else if (tcall[[1]] %in% c("ns", "bs")) {
        bb <- c(tcall[["Boundary.knots"]], tcall[["knots"]])
        levels[[1]] <- sort(bb)
    }
    else stop("don't know how to do a linear contrast for this term")
}
@ 


Here are some helper routines.
Formulas are from chapter 5 of Searle.  The sums of squares only makes
sense within a linear model.
<<yates>>=
gsolve <- function(mat, y, eps=sqrt(.Machine$double.eps)) {
    # solve using a generalized inverse
    # this is very similar to the ginv function of MASS
    temp <- svd(mat, nv=0)
    dpos <- (temp$d > max(temp$d[1]*eps, 0))
    dd <- ifelse(dpos, 1/temp$d, 0)
    # all the parentheses save a tiny bit of time if y is a vector
    if (all(dpos)) x <- drop(temp$u %*% (dd*(t(temp$u) %*% y)))
    else if (!any(dpos)) x <- drop(temp$y %*% (0*y)) # extremely rare
    else x <-drop(temp$u[,dpos] %*%(dd[dpos] * (t(temp$u[,dpos, drop=FALSE]) %*% y)))
    attr(x, "df") <- sum(dpos)
    x
}

qform <- function(var, beta) { # quadratic form b' (V-inverse) b
    temp <- gsolve(var, beta)
    list(test= sum(beta * temp), df=attr(temp, "df"))
}
cfun <- function(cmat, beta, varmat, sigma2) {
    estimate <- drop(cmat %*% beta)  #vector of contrasts
    ss <- qform(cmat %*% varmat %*% t(cmat), estimate)
    evar <- drop(cmat %*% varmat %*% t(cmat)) #variance of the estimate
    rval <- list(estimate=estimate, var=evar, test=ss$test, df=ss$df)
    if (!is.null(sigma2)) rval$ss <- ss$test*sigma2
    rval
}
@ 

