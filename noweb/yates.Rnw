\section{Linear models and contrasts}
The primary contrast function is \code{yates}.  
This function does both simple and population contrasts; the name is a nod
to the ``Yates weighted means'' method, the first population contrast that
I know of.  
A second reason for the name is that
the word ``contrast'' is already overused in the S/R lexicon.
Both \code{yates}  and \code{cmatrix} can be used with any model that returns 
the necessary
portions, e.g., lm, coxph, or glm.
They were written because I became embroiled in the ``type III'' controversy,
and made it a goal to figure out what exactly it is that SAS does. 
If I had known that that quest would take multiple years would 
perhaps have never started.

Population contrasts can result in some head scratching.
It is easy to create the predicted value for any hypothethical
subject from a model.  
A population prediction holds some data values constant and lets the
others range over a population, giving a mean predicted value or
population average.  
Population predictions for two treatments are the familiar g-estimates
of causal models. 
We can take sums of differences of these predictions as well, e.g. to
ask if they are significantly different.
What can't be done is to work backwards from one of these contrasts to the
populations, at least for continuous variables.
If someone asks for an x contrast of 15-5 is this a sum of two population
estimates at 15 and -5, or a difference?  
It's always hard to guess the mind of a user.
Therefore what is needed is a fitted model, the term (covariate) of interest,
levels of that covariate, a desired comparison, and a population.

First is cmatrix routine.  This is called by users to create a contrast
matrix for a model, users can also construct their own contrast matrices.
The result has two parts: the definition of a set of predicted values and
a set of contrasts between those values.  
The routine requires a fit and a term; the default test will be for
the entire term.  The result will be a matrix or list that has a label
attribute containing the name of the term; this is used in printouts in the
obvious way.
Suppose that our model was \code{coxph(Surv(time, status) ~ age*sex + ph.ecog)}.
Someone might want the matrix for the age, sex, age*sex (2 df),
age:sex or ph.ecog term.
The first task is to parse the user's formula and match it to the terms
structure found in the data: we should be a proper subset of it.
  
<<yates>>=
cmatrix <- function(fit, term, levels, 
                    type=c("full", "linear", "pairwise")){
    # Make sure that "fit" is present and isn't missing any parts.
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)

    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    
    # a function that allows them to refer to terms by name or by number
    matchterm <- function(x) {
        nlab <- length(term.label)
        index <- pmatch(x, c(term.label, 1:nlab), nomatch=0) 
        index <- ifelse(index > nlab, index-nlab, index)
        c("", term.label)[1+index]
    }

    if (missing(term)) stop("a term argument is required")
    if (is.character(term)) term <- formula(paste("~", term))
    else if (is.numeric(term)) {
        if (all(term == floor(term) & term >0 & term < length(Tatt$term.labels)))
            term <- formula(paste("~", 
                                  paste(Tatt$term.labels[term], collapse='+')))
        else stop("a numeric term must be an integer between 1 and max terms in the fit")
        }
    else if (!inherits(term, "formula"))
        stop("the term must be a formula, character string, or integer")
    fterm <- delete.response(terms(term))
    fatt <- attributes(fterm)
    indx <- match(fatt$term.labels, Tatt$term.labels)
    if (any(is.na(indx))) {
        # allow partial matching.  If the fit had factor(x) but we have "x",
        #  pretend we said "factor(x)".  Fail for ns(x) + log(x) though.
        temp <- fatt$term.labels
        for (i in 1:length(temp)) {
            j <- grep(temp[i], Tatt$term.labels)
            if (length(j)==1) temp[i] <- Tatt$term.labels[j]
            else stop("test term not found in the fit")
            }
        fterm <- terms(formula( paste("~", paste(temp, collapse="+"))))
        fatt <- attributes(fterm)
        indx <- match(fatt$term.labels, Tatt$term.labels)
   }
    
    # match these up with the columns via the assign attribute
    xassign <- fit$assign
    if (missing(xassign)) stop("the fit is missing an assign component")
    if (is.list(xassign)) {
        # old style assign as used in Splus, and still used in coxph
        xassign <- rep(1:length(xassign), sapply(xassign, length))
    }
    ncoef <- length(xassign)
    whichcol <- which(xassign %in% indx & !is.na(coef(fit)))
    ntest <- length(whichcol)
    if (ntest ==0) stop("no non-missing coefficients in the estimate")
    termname <- Tatt$term.labels[indx]  # to label the output
    
    # What kind of term is being tested.  It can be categorical, continuous,
    #  an interaction of only categorical terms, interaction of only continuous
    #  terms, or a mixed interaction.
    parts <- row.names(Tatt$factors)[Tatt$factors[,indx] !=0]
    types <- Tatt$dataClasses[parts]
    iscat <- as.integer(types=="factor" | types=="character")
    if (length(parts)==1) termtype <-iscat
    else  termtype <- 2 + any(iscat) + all(iscat)


    # Were levels specified?  If so we either simply accept them (continuous),
    #  or double check them (categorical)
    if (missing(levels)) {
        levels <- vector("list", length(parts))
         if (any(iscat==1)) {
            temp <- fit$xlevels[parts]
            if (is.null(temp) || any(sapply(temp, is.null)))
                stop("xlevels not found for all variables:", parts)
            levels[which(iscat==1)] <- temp
        }
     }
    else {
        if (is.data.frame(levels)) {
            temp <- match(names(levels), parts)
            if (any(is.na(temp)))
                stop("not found in levels data frame:", parts)
            else levels <- levels[temp]  # reorder it
            if (any(duplicated(levels))) stop("levels data frame has duplicates")
        }
        else if (is.list(levels)) {
            if (length(levels) != length(parts))
                stop("levels list should have", length(parts), "components")
            if (!is.null(names(levels))) {
                temp <- match(names(levels), parts)
                if (any(is.null(temp)))
                    stop("names of levels does not match the terms")
                else levels <- levels[temp]  #reorder them
            }
            if (any(sapply(levels, function(x) any(duplicated(x)))))
                stop("one or more elements of the levels list has duplicates")
        }
        else if (is.matrix(levels)) {
            if (ncol(levels) != length(parts))
                stop("levels matrix has the wrong number of columns")
            if (!is.null(dimnames(levels)[[2]])) {
                temp <- match(dimnames(levels)[[2]], parts)
                if (any(is.na(temp)))
                    stop("matrix column names do no match the terms")
            } else dimnames(levels)[[2]] <- parts
            if (any(duplicated(levels)))
                stop("levels matrix has duplicated rows")
            levels <- data.frame(levels)
         }
        else if (length(parts) > 1)
            stop("levels should be a data frame or matrix")
        else levels <- list(unique(levels))
    }
    names(levels) <- parts

    # check that any categorical levels are legal
    for (i in which(iscat==1)) {
        xlev <- fit$xlevels[[parts[i]]]
        if (is.null(xlev))
            stop("xlevels attribute not found for", parts[i])
        temp <- match(levels[[parts[i]]], xlev)
        if (any(is.na(temp)))
            stop("invalid level for term", parts[i])
    }
    
    rval <- list(levels=levels, termname=termname)
    # Now add the contrast matrix between the levels, if needed
    <<cmatrix-build>>

    rval <- list(levels=levels, termname=termname, cmat=cmat, iscat=iscat)
    class(rval) <- "cmatrix"
    rval
}
@ 

Building the contrast matrix is very easy for type=full; it is simply
a test of ``are all these coefficients zero''.
The \code{pairwise} option creates a set of contrast matrices for all pairs
of a factor.
The  \code{linear} option is of interest for terms that have more than one
column; the two most common cases are a factor variable or a spline.
It forms a pair of tests, one for the linear and one
for the nonlinear part.  For non-linear functions such as splines we need
some notion of the range of the data, since we want to be linear over the
entire range.  

<<cmatrix-build>>=
type <- match.arg(type)
if (type=="full") cmat <- diag(ntest)
else {
    if (length(parts) > 1)
        stop(test, " tests must be for a single term")
    if (type=="pairwise") {
        tindex <- match(levels[[1]], levels[[1]])  #convert to integer
        nlev <- length(tindex)  # this is the number of groups being compared
        if (nlev < 2) stop("pairwise tests need at least 2 levels")
        npair <- nlev*(nlev-1)/2
        if (npair==1) cmat <- matrix(c(1, -1), nrow=1)
        else {
            cmat <- vector("list", npair)
            k <- 1
            for (i in 1:(nlev-1)) {
                temp <- double(nlev)
                temp[tindex[i]] <- 1
                for (j in (i+1):nlev) {
                    temp[tindex[j]] <- -1
                    cmat[[k]] <- matrix(temp, nrow=1)
                    temp[tindex[j]] <- 0
                    k <- k+1
                }
            }
        }
    }
    else if (type=="linear") {
        <<cmatrix-linear>>
    }
    else stop("unknown type")
}
@ 
    
The linear transform works for factors and splines.  It would in theory
work for polynomial terms as well, but I don't know a good way to pick
a range.  For splines, a prediction that is linear on the knots is linear
globally.

<<cmatrix-linear>>=
cmat <- vector("list", 2)
cmat[[1]] <- matrix(1:ntest, 1, ntest)
cmat[[2]] <- diag(ntest)
attr(cmat, "nested") <- TRUE
if (is.null(levels[[1]])) {
    # a continuous variable, and the user didn't give levels for the test
    #  look up the call and use the knots
    tcall <- Tatt$predvars[[indx + 1]]  # skip the 'call' 
    if (tcall[[1]] == as.name("pspline")) {
        bb <- tcall[["Boundary.knots"]]
        levels[[1]] <- seq(bb[1], bb[2], length=ntest)
    }
    else if (tcall[[1]] %in% c("ns", "bs")) {
        bb <- c(tcall[["Boundary.knots"]], tcall[["knots"]])
        levels[[1]] <- sort(bb)
    }
    else stop("don't know how to do a linear contrast for this term")
}
@ 


Here are some helper routines.
Formulas are from chapter 5 of Searle.  The sums of squares only makes
sense within a linear model.
<<yates>>=
gsolve <- function(mat, y, eps=sqrt(.Machine$double.eps)) {
    # solve using a generalized inverse
    # this is very similar to the ginv function of MASS
    temp <- svd(mat, nv=0)
    dpos <- (temp$d > max(temp$d[1]*eps, 0))
    dd <- ifelse(dpos, 1/temp$d, 0)
    # all the parentheses save a tiny bit of time if y is a vector
    if (all(dpos)) x <- drop(temp$u %*% (dd*(t(temp$u) %*% y)))
    else if (!any(dpos)) x <- drop(temp$y %*% (0*y)) # extremely rare
    else x <-drop(temp$u[,dpos] %*%(dd[dpos] * (t(temp$u[,dpos, drop=FALSE]) %*% y)))
    attr(x, "df") <- sum(dpos)
    x
}

qform <- function(var, beta) { # quadratic form b' (V-inverse) b
    temp <- gsolve(var, beta)
    list(test= sum(beta * temp), df=attr(temp, "df"))
}
cfun <- function(cmat, beta, varmat, sigma2) {
    estimate <- drop(cmat %*% beta)  #vector of contrasts
    ss <- qform(cmat %*% varmat %*% t(cmat), estimate)
    evar <- drop(cmat %*% varmat %*% t(cmat)) #variance of the estimate
    rval <- list(estimate=estimate, var=evar, test=ss$test, df=ss$df)
    if (!is.null(sigma2)) rval$ss <- ss$test*sigma2
    rval
}
@ 

Now for the primary function.

<<yates>>=
yates <- function(fit, test, population=c("none", "data", "factorial", "sas"),
                  method=c("direct", "stt"), 
                  ss, ...) {
    if (missing(fit)) stop("a fit argument is required")
    Terms <- try(terms(fit), silent=TRUE)
    if (inherits(Terms, "try-error"))
        stop("the fit does not have a terms structure")
    else Terms <- delete.response(Terms)   # y is not needed
    Tatt <- attributes(Terms)
    xassign <- fit$assign
    
    if (is.character(population)) {
        population <- match.arg(population)
        if (population != "none") mf <- stats::model.frame(fit)
    }
    else {
        if (!inherits(population, "data.frame"))
            stop("the population argument must be a data frame or character")
        # treat it like the newdata argument of a predict call.
        mf <- stats::model.frame(Terms, population, xlev=fit$xlevels)
        if (!is.null(cl <- attr(Terms, "dataClasses")))
            .checkMFClasses(cl, mf)
        population <- "user"
        }
 
    if (population =="none" && method != "direct")
        stop(method, " method only applies to population estimates")
    beta <-  coef(fit)
    nabeta <- is.na(beta)  # undetermined coefficients
    vmat <-  vcov(fit)
    term.label <- attr(Terms, "term.labels")
    
    # grab the dispersion
    if (missing(ss)) do.ss <- FALSE
    else do.ss <- ss
    if (class(fit)[1] =="lm") {
        if (missing(ss)) do.ss <- TRUE
        sigma <- summary(fit)$sigma
        }
    else if(class(fit)[1]=="glm") {
        sigma <- summary(fit)$dispersion
#        if (is.null(sigma)) sigma <- 1
        }
    else sigma <- NULL

    # A bit of trickery to allow users to type "cm" instead of "cmatrix"
    ff <- parent.frame()
    tempenv <- new.env(parent=ff)
    assign("cm", function(...) cmatrix(fit, ...), env=tempenv)
    test <- eval(substitute(test), tempenv)

    # check that the test argument is legal: each element should have
    #  class "cmatrix"
    # it can be a list or nested list of such elements, with optional names
    legal <- function(x) {
        if (inherits(x, "cmatrix")) TRUE
        else if (is.list(x)) all(sapply(x, legal))
        else FALSE
    }
    if (!legal(test))
        stop("the test argument should contain elements of class cmatrix")
    xassign <- attr(fit, "assign")
    
    # process the tests
    dummy <- function(x) {
        if (inherits(x, "cmatrix")) dotest(x, method, population)
        else lapply(x, dummy)
    }

    dotest <- function(cm, method, population) {
        if (population=="none") {
            <<yates-build-none>>
            cfun(Cmat, beta, vmat, sigma^2)
        } else {
            <<yates-build-pop>>
            cfun(Cmat, beta, vmat, sigma^2)
        }
    }
    result <- dummy(test)
    class(result) <- "yates"
    result
}
@

The \code{cmatrix} object contains two peices of information: which predicted
values we are going to start with, and then the contrast(s) that we are going
to apply to those predicted values.
For population=none, we build the neccesary $X$ matrix directly. Each element
of \code{cm\$levels} is transformed into the coding of the original
$X$ matrix.  For each element:
\begin{enumerate}
  \item if it is NULL, then this was a continuous variable for which no levels
    were given.  Any non-zero dummy value for those columns of $X$ will
    suffice, so we just set it (or them) to 1.
  \item if the variable is categorical then the corresponding element of
    the \code{fit\$contrast} is used to create the coding.  
  \item for a continuous variable use the predvars attribute of the terms
    structure; if that is missing reconstruct a call from
    the formula itself.
\end{enumerate}
    
  
<<yates-build-none>>=
# cm will be a cmatrix object
index <- match(cm$termname, Tatt$term.labels)
iname <- 
ncoef <- length(xassign)
whichcol <- which(xassign %in% index)  #columns to fill in
clevel <- cm$levels
nullcm <- sapply(clevel, is.null)
if (all(nullcm)) {
    Xmat <- matrix(0., nrow=length(whichcol), ncol=ncoef)
    Xmat[,whichcol] <- diag(length(whichcol))
}
else if (any(nullcm))                            
    stop("can't handle this type of mixed term, yet")
else {
    # Get the inner part of each name, e.g, ns(age, df=3) turns into "age".
    #  The line below is killing a fly with a triphammer, but we only run
    #  it once.  
    pname <- names(clevel)
    for (i in 1:length(pname)) pname[i] <- all.vars(parse(text=pname[i]))[1]
    
    if (!is.data.frame(clevel)) clevel <- do.call("expand.grid", clevel)
    Xmat <- matrix(0., nrow=nrow(clevel), ncol=ncoef)
    for (i in 1:ncol(clevel)) {
        cname <- names(clevel)[i]
        ccol <- which(xassign== index[i])
        if (cm$iscat[i]) {
            if (length(ccol) < length(fit$xlevels[[cname]])) 
                temp <- get(fit$contrasts[[cname]])(length(ccol))
            else temp <- get(fit$contrasts[[cname]])(length(ccol),
                                                     contrasts=FALSE)
            Xmat[,ccol] <- temp[match(clevel[[i]], fit$xlevels[[cname]]),]
        }
        else { # continuous
            j <- match(cname, row.names(Tattr$factors))
            pcall <- Tattr$predictCall[[j+1]] #skip the "list" element
            if (is.call(pcall)) {
                temp <- list(clevel[[i]])
                names(temp) <- pname[i]
                Xmat[,ccol] <- eval(pcall, temp)
            }
            else if (is.name(temp)) {
                if (length(ccol) !=1) stop("logic error")
                Xmat[,ccol] <- clevel[[i]]
            }
            else stop("logic error 2")  #should be impossible
        }
    }
}
@ 

Now go through the contrast matrices 1 by 1 and evaluate them.
<<yates-build-none>>=
if (is.list(cm$cmatrix)) 
    sapply(cm$cmatrix, function(z) cfun(z %*% Xmat, beta, vmat, sigma^2))
else cfun(cm$cmatrix %*% Xmat, beta, vmat, sigma^2)
@ 


Population estimates are definitely more work.
<<yates-none>>=
tfun <- function(x) {
    if (!is.null(attr(x, "global")) && attr(x, "global")) {
        # Do a global test on all children
        tmat <- do.call(rbind, x)
        c(cfun(tmat, beta, vmat, sigma^2), lapply(x, tfun))
    }
    else cfun(x, beta, vmat, sigma^2)
}
result <- tfun(test)
@ 

For a population estimate the first task is to build the data set.
<<yates-data>>=
@ 

<<yates-pop>>=
@ 

<<yates-sgtt>>=
@ 
This function is used by the print routine, but it is worthwhile to
expose it.  Some user's might want to print things on their own.

<<yates>>=
as.matrix.yates <- function(x, indent=4) {
    # Create the labels column
    space <- paste(rep(" ", indent), collapse="")
    namefun <- function(zed, indent) {
        if (is.list(zed)){
            sublist <- sapply(zed, is.list)
            if (any(sublist)) {
                i2 <- paste0(space, indent)
                n2 <- names(zed)[sublist]
                temp <- lapply(zed[sublist], namefun, indent=i2)
                for (i in 1:length(temp)) 
                    temp[[i]] <- paste0(i2, c(n2[i], temp[[i]]))
                c(paste0(indent, attr(zed, "label")),
                  unlist(temp, use.names=FALSE))
            }
            else NULL
        }
        else  NULL
    }
    tname <- namefun(x, "")

    # unlist a particular element of the array
    grabit <- function(x, what) {
        sublist <- sapply(x, is.list)
        temp <- if (what %in% names(x) && length(x[[what]])==1) x[[what]] 
                else NA
        if (any(sublist)) c(temp, unlist(lapply(x[sublist], grabit, what=what)))
        else temp
    }
 
    temp <- cbind(grabit(x, "estimate"),
                  sqrt(grabit(x, "var")),
                  grabit(x, "test"),
                  grabit(x, "df"),
                  grabit(x, "ss"))
    dimnames(temp) <- list(tname, c("estimate", "std", "test", "df", "SS"))
    if (all(is.na(temp[,5]))) temp <- temp[, -5]
    temp
}

print.yates <- function(x, ...) 
    print(as.matrix(x), na.print="")
@ 
