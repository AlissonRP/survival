\subsubsection{Printing and plotting}
The \code{survfitms} class differs from a \code{survfit}, but many of the
same methods nearly apply.
<<survfitms>>=
# Methods for survfitms objects
<<survfitms-summary>>
<<survfitms-subscript>>
@ 

The subscript method is a near copy of that for survfit
objects, but with a slightly different set of components. 
The object could have strata and will almost always have multiple
columns.  If there is only one subscript it is preferentially
associated with the strata, if there is no strata argument \code{i}
will associate with the columns.
If there are two subscripts the first goes with the strata.
The little \code{nmatch} function allow the user to use either names
or integer indices.

<<survfitms-subscript>>=
"[.survfitms" <- function(x, ..., drop=TRUE) {
    nmatch <- function(indx, target) { 
        # This function lets R worry about character, negative, or logical subscripts
        #  It always returns a set of positive integer indices
        temp <- 1:length(target)
        names(temp) <- target
        temp[indx]
    }
        
    if (missing(..1)) i<- NULL  else i <- sort(..1)
    if (missing(..2)) j<- NULL  else j <- ..2
    n <- length(x$time)

    if (is.null(x$strata) && is.matrix(x$pstate)) {
        # No strata, but a matrix of prevalence values
        #  In this case, allow them to use a single i subscript as well
        if (is.null(j) && !is.null(i)) {
            j <- i
            i <- NULL
        }
    }
    if (is.null(i)) {
        i2 <- 1:n
        if (is.null(strata)) i <- 1
        else i <- seq(along=strata)
    }
    else {
        if (is.null(x$strata) && (length(i) > 1 || i != 1))
            stop("subscript out of bounds")
        indx <- nmatch(i, names(x$strata)) #strata to keep
        if (any(is.na(indx))) 
            stop(paste("strata", 
                       paste(i[is.na(indx)], collapse=' '),
                       'not matched'))
        # Now, i may not be in order: a user has curve[3:2] to reorder 
        #  a plot.  Hence the "unlist(lapply(" construct which will reorder
        #  the data in the curves
        temp <- rep(1:length(x$strata), x$strata)
        keep <- unlist(lapply(i, function(x) which(temp==x)))

        if (length(i) <=1 && drop) x$strata <- NULL
        else               x$strata  <- x$strata[indx]
        i2 <- keep
    }

    if (!is.null(j)) {
        indx <- nmatch(j, x$states)
        if (any(is.na(indx)))
            stop("subscript out of bounds", j[is.na(indx)])
        else j <- as.vector(indx)
    }

    if (length(i2) ==1 && !is.null(j) && missing(drop)) drop <- FALSE
 
    # all the elements that can have "nstate" elements or columns
    #  The n.event variable can have fewer
    temp <- c("states", "n.risk", "n.event", "n.censor", "pstate", 
              "cumhaz", "std.err", "lower", "upper")
    sfun <- function(z) {
        if (is.null(j)) {
            if (is.array(z)) {
                if (length(dim(z)) > 2) z[,,i2, drop=drop]  
                else z[i2,,drop=drop]
            }
            else z
        }
        else {
            if (is.array(z)) {
                if (length(dim(z)) > 2) z[j,j,i2, drop=drop]  
                else z[i2,j, drop=drop]
            }
            else z[j]
        }
    }
    for (k in temp) x[[k]] <- sfun(x[[k]])
    x$n <- x$n[i]
    x$time <- x$time[i2]

    if (is.null(j)) x$p0<- x$p0[i,]
    else x$p0 <- x$p0[i,j]
    
    x
}
@ 

The summary.survfit and summary.survfitms functions share a large
amount of code.  
One part of the code that once was subtle is dealing with
intermediate time points; the findInterval function in base R has
made that much easier.

<<survfitms-summary>>=
summary.survfit <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean=getOption('survfit.rmean'),
                            ...) {
    fit <- object
    if (!inherits(fit, 'survfit'))
	    stop("summary.survfit can only be used for survfit objects")

    # The print.rmean option is depreciated, it is still listened
    #   to in print.survfit, but ignored here
    if (is.null(rmean)) rmean <- "common"

    temp <- survmean(fit, scale=scale, rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time

    if (!missing(times)) {
        if (!is.numeric(times)) stop ("times must be numeric")
        times <- sort(times)
    }

    # The fit$surv object is sometimes a vector and sometimes a
    #  matrix.  We calculate row indices first, and then deal
    #  with the cases at the end.
    nsurv <- if (is.matrix(fit$surv)) nrow(fit$surv) else length(fit$surv)
    if (is.null(fit$strata)) {
	nstrat <- 1
	stemp <- rep(1L, nsurv)
        strata.names <- ""
	}
    else   {
	nstrat <- length(fit$strata)
	stemp <- rep(1:nstrat, fit$strata)
        strata.names <- names(fit$strata)
    }

    <<survsum-findrows>>

    # Create an output structure
    if (length(indx1)==length(fit$time) && all(indx1 == seq(along=fit$time))) {
        temp <- object  #no change
        temp$time <- temp$time/scale
        temp$table <- table
        if (!is.null(temp$strata))
            temp$strata <- factor(stemp, labels=strata.names)

    }
    else if (missing(times)) {  #default censor=FALSE case
        temp <- object
        temp$time <- temp$time[indx1]/scale
        temp$table <- table
        for (j in c("n.risk", "n.event", "n.censor", "n.enter",
                    "surv", "std.err", "cumhaz", "lower", "upper")) {
            zed <- temp[[j]]
            if (!is.null(zed)) {
                if (is.matrix(zed)) temp[[j]] <- zed[indx1,,drop=FALSE]
                else temp[[j]] <- zed[indx1]
            }
        }
        if (!is.null(temp$strata))
            temp$strata <- factor(stemp[indx1], levels=1:nstrat,
                                  labels=strata.names)
    }
    else { #times argument was given
        temp <- list(n=object$n, time=times/scale, 
                     n.risk=n.risk, n.event=n.event,
                     conf.int=fit$conf.int, type=fit$type, table=table)
        if (!is.null(n.censor)) temp$n.censor <- n.censor
        if (!is.null(n.enter))  temp$n.enter <- n.enter
        if (!is.null(fit$start.time)) temp$start.time <- fit$start.time
            
        # why the rbind?  The user may have specified a time point before
        #  the first event, and indx1=1 indicates that case
        if (is.matrix(fit$surv)) {
            temp$surv <- rbind(1, fit$surv)[indx1,,drop=FALSE]
            if (!is.null(fit$std.err))
                temp$std.err <- rbind(0, fit$std.err)[indx1,,drop=FALSE]
            if (!is.null(fit$lower)) {
                temp$lower <- rbind(1, fit$lower)[indx1,,drop=FALSE]
                temp$upper <- rbind(1, fit$upper)[indx1,,drop=FALSE]
             }
            if (!is.null(fit$cumhaz))
                temp$cumhaz <- rbind(0, fit$cumhaz)[indx1,,drop=FALSE]
        }
        else {
            temp$surv <- c(1, fit$surv)[indx1]
            if (!is.null(fit$std.err)) temp$std.err <- c(0,fit$std.err)[indx1]
            if (!is.null(fit$lower)) {
                temp$lower <- c(1, fit$lower)[indx1]
                temp$upper <- c(1, fit$upper)[indx1]
            }
            if (!is.null(fit$cumhaz)) temp$cumhaz <- c(0, fit$cumhaz)[indx1]
        }
        if (!is.null(fit$strata)) {
            scount <- unlist(lapply(newtimes, length))
            temp$strata <- factor(rep(1:nstrat, scount), levels=1:nstrat,
                                  labels=strata.names)
        }
    
        if (length(rmean.endtime)>0  && !is.na(rmean.endtime)) 
            temp$rmean.endtime <- rmean.endtime

        temp$call <- fit$call
        if (!is.null(fit$na.action)) temp$na.action <- fit$na.action
  
    }
    if (!is.null(temp$std.err))
        temp$std.err <- temp$std.err*temp$surv  #std error of the survival curve
    class(temp) <- 'summary.survfit'
    temp
}
@ 

Grab rows: if there is no \code{times} argument it is easy
<<survsum-findrows>>=
if (missing(times)) {
    # just pick off the appropriate rows of the output
    # For a survfitms object n.event is a matrix, pick off all rows with an
    #  event for some endpoint.
    if (censored) indx1 <- seq(along=fit$time)
    else indx1 <- which(rowSums(as.matrix(fit$n.event)) >0)
}
@ 

This second case is actual work, since may involve ``in between'' points
in the curves.
Let's say that we have a line in the data for times 1,2, 5, and 6, and 8 
and a user chose \code{times=c(3,5, 9)}.
At time 3 we have
\begin{itemize}
  \item nrisk[3] = value at the next time point >= 3
  \item nevent[1] + nevent[2] = value since last printout line. 
    However, if there are multiple strata the curves for all strata
    are laid end to end in a single vector; our first row for a curve
    needs to use all events since the start of the curve.
  \item ncensor works like nevent
  \item survival[2] = survival at the last time point <=3
\end{itemize}
At time 5 we pick values directly off the data, since we match.
At time 9 we report nothing if \code{extend} is FALSE, or the value
at the end of the curve.  In this case we need to calculate the
number at risk ourselves, however.
This logic works out best if we do it curve by curve.

<<survsum-findrows>>=
else { 
    # Process the curves one at a time,
    #   adding the results for that curve onto a list, so the
    #   number of events will be n.enter[[1]], n.enter[[2]], etc.
    # For the survival, stderr, and confidence limits it suffices
    #   to create a single list 'indx1' containing a subscripting vector
    indx1 <- n.risk <- n.event <- newtimes <- vector('list', nstrat)
    n.censor <- n.enter <- vector('list', nstrat)
    n <- length(stemp)
    for (i in 1:nstrat) {
        who <- (1:n)[stemp==i]  # the rows of the object for this strata
        stime <- fit$time[who]

        # First, toss any printing times that are outside our range
        if (is.null(fit$start.time)) mintime <- min(stime, 0)
        else                         mintime <- fit$start.time
        ptimes <- times[times >= mintime]

        if (!extend) {
            maxtime <- max(stime)
            ptimes <- ptimes[ptimes <= maxtime]
    	}
        newtimes[[i]] <- ptimes

        indx <- findInterval(ptimes, stime)
        indx1[[i]] <- who[indx]

        # indx gives the index of the first value of stime that
        #  is <= each ptime
        # It will be zero for times that are before the first event,
        #  and length(stime) for any times after the last point in the curve.
        # The cfun function below gives total counts, accounting for the
        #  zeros in indx
        cfun <- function(x, indx, init=0) {
            if (is.matrix(x)) apply(x, 2, function(z) {
                temp <- ifelse(indx==0, init, cumsum(z)[indx])
                diff((c(0, temp)))
                })
            else {
                temp <- ifelse(indx==0, init, cumsum(x)[indx])
                diff(c(0, temp))
                }
            }
 
        n.event[[i]] <- cfun(fit$n.event[who], indx)
        n.risk[[i]]  <- c(0, fit$n.risk[who])[i+1]
  
        if (!is.null(fit$n.censor)) {
    	    n.censor[[i]] <- cfun(fit$n.censor[who], indx)
    	    }
        if (!is.null(fit$n.enter)) {
    	    n.enter[[i]] <- cfun(fit$n.enter[who], indx)
    	    }
     }
	
    # unlisting a list of matrices is a bit more work
    # all the ones in each list have the same number of columns, so it would
    #  be easy if they were in row major order.
    matunlist <- function(z) {
        if (is.matrix(z[[1]])) {
            nc <- ncol(z[[1]])
            matrix(unlist(lapply(z, t)), byrow=TRUE, ncol=nc)
        }
        else unlist(z)
        }
        
    times  <- unlist(newtimes)
    n.risk <-  matunlist(n.risk)
    n.event <- matunlist(n.event)
    n.censor<- matunlist(n.censor)  #may be NULL
    n.enter <- matunlist(n.enter)
    indx1 <- unlist(indx1)
}
@ 


Repeat the code for survfitms objects.  The only real difference is
the preservation of \code{pstate} and \code{cumhaz} instead of \code{surv}.

<<survfitms-summary>>=
summary.survfitms <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean= getOption("survfit.rmean"),
                            ...) {
    fit <- object
    if (!inherits(fit, 'survfitms'))
	    stop("summary.survfitms can only be used for survfitms objects")

    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(x$start.time)) {
            if (rmean < min(x$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < x$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }
       
    if (!missing(times)) {
        if (!is.numeric(times)) stop ("times must be numeric")
        times <- sort(times)
    }

    temp <- survmean2(fit, scale=scale, rmean=rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time

    # The fit$pstate object is usually a matrix but can be a vector
    #  We calculate row indices first, and then deal
    #  with the cases at the end.
    nprev <- if (is.matrix(fit$pstate)) nrow(fit$pstate) else length(fit$pstate)
    if (is.null(fit$strata)) {
	nstrat <- 1
	stemp <- rep(1L, nprev)
        strata.names <- ""
	}
    else   {
	nstrat <- length(fit$strata)
	stemp <- rep(1:nstrat, fit$strata)
        strata.names <- names(fit$strata)
    }

    <<survsum-findrows>>

    # Create an output structure
    if (length(indx1)== length(fit$time) && all(indx1 == seq(along=fit$time))) {
        temp <- object  #no change
        temp$time <- temp$time/scale
        temp$table <- table
        if (!is.null(temp$strata)) 
            temp$strata <- factor(stemp, levels=1:nstrat, labels=strata.names)
    }
    else if (missing(times)) {
        temp <- object
        temp$time <- temp$time[indx1]/scale
        temp$table <- table
        for (j in c("n.risk", "n.event", "n.censor", 
                    "prev", "std.err", "lower", "upper")) {
            zed <- temp[[j]]
            if (!is.null(zed)) {
                if (is.matrix(zed)) temp[[j]] <- zed[indx1,,drop=FALSE]
                else temp[[j]] <- zed[indx1]
            }
        }
        temp$cumhaz <- fit$cumhaz[,,indx1,drop=FALSE]
        if (!is.null(temp$strata))
            temp$strata <- factor(stemp[indx1], levels=1:nstrat,
                                  labels=strata.names)
    }
    else {
        temp <- list(n=object$n, time=times/scale, 
                     n.risk=n.risk, n.event=n.event,
                     conf.int=fit$conf.int, type=fit$type, table=table)
        if (!is.null(n.censor)) temp$n.censor <- n.censor
        if (!is.null(n.enter))  temp$n.enter <- n.enter
        if (!is.null(fit$start.time)) temp$start.time <- fit$start.time

        # why the rbind?  The user may have specified a time point before
        #  the first event, and indx1=1 indicates that case
        # the cumhaz array can't be done with a 1-liner
        if (is.matrix(fit$pstate)) {
            temp$pstate <- rbind(0, fit$pstate)[indx1,,drop=FALSE]
            zz <- ifelse(indx1==1, NA, indx1-1)
            temp$cumhaz <- fit$cumhaz[,,zz, drop=FALSE]
            temp$cumhaz <- ifelse(is.na(temp$cumhaz), 0, temp$cumhaz)
            if (!is.null(fit$std.err)) 
                temp$std.err <- rbind(0, fit$std.err)[indx1,,drop=FALSE]
            if (!is.null(fit$lower)) {
                temp$lower <- rbind(0, fit$lower)[indx1,,drop=FALSE]
                temp$upper <- rbind(0, fit$upper)[indx1,,drop=FALSE]
            }
        }
        else {
            temp$pstate <- c(0, fit$pstate[indx1])
            temp$cumhaz <- c(0, fit$cumhaz[indx1])
            if (!is.null(fit$std.err)) temp$std.err <- c(0, fit$std.err)[indx1]
            if (!is.null(fit$lower)) {
                temp$lower <- c(0, fit$lower)[indx1]
                temp$upper <- c(0, fit$upper)[indx1]
            }
        }
        if (!is.null(fit$strata)) {
            scount <- unlist(lapply(newtimes, length))
            temp$strata <- factor(rep(1:nstrat, scount), levels=1:nstrat,
                                  labels=strata.names)
        }

        temp$call <- fit$call
        if (!is.null(fit$na.action)) temp$na.action <- fit$na.action
  
    }
        
    if (length(rmean.endtime)>0  && !is.na(rmean.endtime)) 
            temp$rmean.endtime <- rmean.endtime
    class(temp) <- "summary.survfitms"
    temp
}

<<printms>>
<<survmean2>>
@ 

Printing for a survfitms object is different than for a survfit one.
The big difference is that I don't have an estimate of the median, or
any other quantile for that matter.  Mean time in state makes sense, but
I don't have a standard error for it at the moment.
The other is that there is usually a mismatch between the n.event matrix
and the n.risk matrix.  
The latter has all the states that were possible whereas the former only
has states with an arrow pointing in.  We need to manufacture the 0 events
for the other states.

<<printms>>=
print.survfitms <- function(x, scale=1,
                            rmean = getOption("survfit.rmean"), ...) {
    if (!is.null(cl<- x$call)) {
	cat("Call: ")
	dput(cl)
	cat("\n")
        }	
    omit <- x$na.action
    if (length(omit)) cat("  ", naprint(omit), "\n")

    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(x$start.time)) {
            if (rmean < min(x$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < x$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean2(x, scale=scale, rmean)
    if (is.null(temp$end.time)) print(temp$matrix, ...)
    else {
        etime <- temp$end.time
        dd <- dimnames(temp$matrix)
        cname <- dd[[2]]
        cname[length(cname)] <- paste0(cname[length(cname)], '*')
        dd[[2]] <- cname
        dimnames(temp$matrix) <- dd
        print(temp$matrix, ...)
        if (length(etime) ==1)
             cat("   *mean time in state, restricted (max time =", 
                 format(etime), ")\n")
        else cat("   *mean time in state, restricted (per curve cutoff)\n")
    }
    invisible(x)
}
@ 

This part of the computation is set out separately since it is called
by both print and summary.
<<survmean2>>=
survmean2 <- function(x, scale, rmean) {
    nstate <- length(x$states)  #there will always be at least 1 state
    ngrp   <- max(1, length(x$strata))
    if (ngrp >1)  {
        igrp <- rep(1:ngrp, x$strata)
        rname <- names(x$strata)
        }
    else {
        igrp <- rep(1, length(x$time))
        rname <- NULL
        }

    # The n.event matrix may not have nstate columms.  Its
    #  colnames are the first elements of states, however
    if (is.matrix(x$n.event)) {
        nc <- ncol(x$n.event)
        nevent <- tapply(x$n.event, list(rep(igrp, nc), col(x$n.event)), sum)
        dimnames(nevent) <- list(rname, x$states[1:nc])
        }
    else {
        nevent <- tapply(x$n.event, igrp, sum)
        names(nevent) <- rname
        }

    outmat <- matrix(0., nrow=nstate*ngrp , ncol=2)
    outmat[,1] <- rep(x$n, nstate)
    outmat[1:length(nevent), 2] <- c(nevent)
  
    if (ngrp >1) 
        rowname <- c(outer(rname, x$states, paste, sep=", "))
    else rowname <- x$states

    # Caculate the mean time in each state
    if (rmean != "none") {
        if (is.numeric(rmean)) maxtime <- rep(rmean, ngrp)
        else if (rmean=="common") maxtime <- rep(max(x$time), ngrp)
        else maxtime <- tapply(x$time, igrp, max)
    
        meantime <- matrix(0., ngrp, nstate)
        p0 <- matrix(x$p0, nrow=ngrp)  #in case there is only one row
        for (i in 1:ngrp) {
            if (is.matrix(x$pstate))
                temp <- rbind(p0[i,], x$pstate[igrp==i,, drop=FALSE])
            else temp <- matrix(c(p0[i,], x$pstate[igrp==i]), ncol=1)

            if (is.null(x$start.time)) tt <- c(0, x$time[igrp==i])
            else tt <- c(x$start.time, x$time[igrp==i])

            # Now cut it off at maxtime
            delta <- diff(c(tt[tt<maxtime[i]], maxtime[i]))
            if (length(delta) > nrow(temp)) delta <- delta[1:nrow(temp)]
            if (length(delta) < nrow(temp))
                delta <- c(delta, rep(0, nrow(temp) - length(delta)))
            meantime[i,] <- colSums(delta*temp)
        }

        outmat <- cbind(outmat, c(meantime))
        cname <- c("n", "nevent", "mean")
        # report back a single time, if there is only one
        if (all(maxtime == maxtime[1])) maxtime <- maxtime[1]
    }
    else cname <- c("n", "nevent")
    dimnames(outmat) <- list(rowname, cname)

    if (rmean=='none') list(matrix=outmat/scale)
    else list(matrix=outmat/scale, end.time=maxtime/scale)
}
@ 

