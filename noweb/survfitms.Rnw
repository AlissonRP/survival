\subsubsection{Printing and plotting}
The \code{survfitms} class differs from a \code{survfit}, but many of the
same methods nearly apply.
<<survfitms>>=
# Methods for survfitms objects
<<dim.survfitms>>
<<survfitms-summary>>
<<survfitms-subscript>>
@ 

The subscript method is a near copy of that for survfit
objects, but with a slightly different set of components. 
The object could have strata and will almost always have multiple
columns.  If there is only one subscript it is preferentially
associated with the strata, if there is no strata argument \code{i}
will associate with the columns.
If there are two subscripts the first goes with the strata.
The little \code{nmatch} function allow the user to use either names
or integer indices.

<<survfitms-subscript>>=
"[.survfitms" <- function(x, ..., drop=FALSE) {
    nmatch <- function(i, target) { 
        # This function lets R worry about character, negative, 
        # or logical subscripts
        #  It always returns a set of positive integer indices
        temp <- 1:
        names(temp) <- target
        temp[indx]
    }
        
    ndots <- ...length()   # number of subscripts that we have
    dd <- dim(x)
    dtype <- match(names(dd), c("strata", "data", "states"))
    target <- list(if (any(dtype==1)) names(x$strata) else NULL,
                   if (any(dtype==2)) seq(along=dd[dtype==2]) else NULL,
                   if (any(dtype==3)) x$states else NULL)

    if (ndots==0) return(x)  # no subscript given
    if (ndots >0) i <- ..1 else i <- NULL
    if (ndots> 1) j <- ..2 else j <- NULL
    if (ndots> 2) k <- ..3 else k <- NULL
    if (ndots >3) stop("too many subscripts for survfit object")

    # Remap subscripts so that ii points to the strata, NULL if there are
    #  no strata in the object, and jj points to the columns
    # A survfitms object can be missing strata, or have only 1 stratum (if
    #  it was previously subscripted), and it can have no data dimension
    #  or a data dimension of 1.  When a dimension is 1 we allow the user
    #  to pretend it isn't present, i.e. a dim of (3,1,4) can be treated as
    #  (3,4).  (The default drop=FALSE keeps names present for labeling.)
    # An exception is that if x has multiple dimensions that are > 1, and only
    #  one subscript is given, then the standard R rule for a matrix/array
    #  is used, namely to treat x as a vector.
    # And ... from a user's point of view the data and state dimensions are
    #  separate, but in the object these two are combined and appear as the
    #  columns of pstate.
    #
    dd2 <- which(dd>1)
    if (ndots==1 && length(dd2) > 1) {
        # the 'treat it as a vector' case
        if (dtype[1] ==1) { # the object has strata
            nstrat <- length(x$strata)
            itemp <- matrix(1:prod(dd), nrow=nstrat)
            ii <- row(itemp)[i]
            jj <- col(itemp)[i]
            
            itemp2 <- split(1:sum(x$strata), rep(1:length(x$strata), x$strata))
            i2 <- unlist(itemp2[ii])  # rows of the pstate matrix
            j2 <- rep(jj, x$strata[i])# cols of the pstate matrix
            indx <- cbind(i2, j2)  # index for pstate and etc

            # The n.risk, n.event, .. matrices dont have a newdata dimension.
            if (dtype[2]==3) indx2 <- indx
            else if (length(dtype==2)) indx2 <- ii
            else {  # all three indices
                itemp <- matrix(1:(dd[1]*dd[3]), nrow=dd[1])
                j3 <- rep(col(itemp)[i], x$strata[i])
                indx2 <- cbind(i2, j3)
            }
  
            x$cumhaz <- x$std.chas <- x$influence.chaz <- NULL  # remove
            x$states <- x$newdata <- x$transitions <- NULL      # remove
            x$n    <-  x$n[ii]
            x$time <-  x$time[i2]
            x$n.risk <- x$n.risk[indx2]
            x$n.event<- x$n.event[indx2]
            x$n.censor <- x$n.censor[indx2]
            x$pstate  <-  x$pstate[indx]
            if (!is.null(x$p0)) x$p0 <- x$p0[cbind(ii,jj)]
            x$strata <- x$strata[ii]
            names(x$strata) <- seq.along(ii)
            if (!is.null(x$std.err)) x$std.err <- x$std.err[indx]
            if (!is.null(x$sp0))     x$sp0 <- x$sp0[cbind(ii,jj)]
            if (!is.null(x$lower))   x$lower <- x$lower[indx]
            if (!is.null(x$upper))   x$upper <- x$upper[indx]
            return(x)
        } else {
            # strange request, mix of states and x values
            itemp <- matrix(1:prod(dd), nrow=dd[1])
            jj <- itemp[i]   # these columns
            j3 <- (col(itemp))[i]
            x$cumhaz <- x$std.chas <- x$influence.chaz <- NULL  # remove
            x$states <- x$newdata <- x$transitions <- NULL      # remove
            x$n.risk <- x$n.risk[,j3, drop=TRUE]
            x$n.event<- x$n.risk[,j3, drop=TRUE]
            x$n.censor<-x$n.censor[,j3,drop=TRUE]
            x$pstate <- x$pstate[,jj, drop=TRUE]
            if (!is.null(x$p0)) x$p0 <- x$p0[,j3]
            if (!is.null(x$std.err)) x$std.err <- x$std.err[,jj]
            if (!is.null(x$sp0))     x$sp0 <- x$sp0[,j3]
            if (!is.null(x$lower))   x$lower <- x$lower[,jj]
            if (!is.null(x$upper))   x$upper <- x$upper[,jj]
            return(x)
        }
    }
    
    if (ndots < length(dd)) {
        # if any of the dimensions are of length 1, let the user ignore them
        if (ndots != length(dd[dd>1])) stop("incorrect number of dimensions")
        else {
            temp <- c(NA,NA, NA)
            dt <- dtype[dd>1]
            temp[dt[1]] <- nmatch(i, target[[dt[1]]])
            if (ndots==2) temp[dt[2]] <- nmatch(j, target[[dt[2]]])
        }
    } else {
        temp <- c(NA, NA, NA)
        temp[dtype[1]] <- nmatch(i, target[[dtype[1]]])
        if (ndots==2) temp[dtype[2]] <- nmatch(j, target[[dtype[2]]])
        if (ndots==3) temp[dtype[3]] <- nmatch(k. target[[dtype[3]]])
    }
    i <- temp[1]
    j <- temp[2]
    k <- temp[3]

    # at this point i will index strata, j the data, k the states; each is NA
    #  if that index isn't used or if the user indicated it without a value
    # ii will be our index for the time vector, and first dim of nevent, pstate,
    #  .. anything that depends on time
    # jj will be our index for the second dimension of pstate, and other objects
    #    that have (data * state) columns
    # kk will be our index for the second dimension of n, n.event, and other
    #    objects whose second dim is the number of states
    if (is.null(i)) ii <- seq(along= x$time) 
    else {
        itemp <- split(seq.int(prod(dd)), rep(1:length(x$strata), x$strata))
        ii <- unlist(itemp[i])
    }

    d2 <- c(1L, 1L, 1L)   # a version with all three dimensions
    d2[dtype] <- dd
    itemp <- matrix(seq.int(d2[2] * d2[3]), nrow=d2[2])
    ktemp <- ifelse(is.na(k), d2[3], k)
    jtemp <- ifelse(is.na(j), d2[2], j)
    if (is.null(j) && is.null(k)) jj <- seq.int(ncol(x$pstate))
    else jj <- c(itemp[jtemp, ktemp])

    if (is.null(k)) kk <- seq(along=states)
    else kk <- k

    # if (and only if) there is no subscripting of the states, then the
    #  transition matrix and the cumulative hazard can be retained
    ckeep <- (length(kk) == length(states) && all(kk = seq(along=states)))
    if (ckeep) {
        if (!is.null(x$cumhaz))

    if (is.matrix(x$pstate)) { # this should be true 99.9% of the time
        
        
        
    if (is.null(x$strata) && is.matrix(x$pstate)) {
        # No strata, but a matrix of P(state) values
        #  In this case, allow them to use a single i subscript as well
        if (is.null(j) && !is.null(i)) {
            j <- i
            i <- NULL
        }
    }

    # 'i' is the subscript from the user's point of view, 'i2' is the
    #  subscript from the program's view, i.e, the row indices to keep
    if (is.null(i)) {
        i2 <- 1:n
        if (is.null(x$strata)) i <- 1
        else i <- seq(along=x$strata)
    }
    else {
        if (is.null(x$strata) && (length(i) > 1 || i != 1))
            stop("subscript out of bounds")
        indx <- nmatch(i, names(x$strata)) #strata to keep
        if (any(is.na(indx))) 
            stop(paste("strata", 
                       paste(i[is.na(indx)], collapse=' '),
                       'not matched'))
        # Now, i may not be in order: a user has curve[3:2] to reorder 
        #  a plot.  Hence the "unlist(lapply(" construct which will reorder
        #  the data in the curves
        temp <- rep(1:length(x$strata), x$strata)
        i2 <- unlist(lapply(i, function(x) which(temp==x)))

        if (length(i) <=1 && drop) x$strata <- NULL
        else               x$strata  <- x$strata[indx]
     }

    if (!is.null(j)) {
        indx <- nmatch(j, x$states)
        if (any(is.na(indx)))
            stop("subscript out of bounds", j[is.na(indx)])
        else j <- as.vector(indx)
    }

    # if only one state is kept, still retain the data as a matrix
    if (length(i2) ==1 && !is.null(j) && missing(drop)) drop <- FALSE
 
    # all the elements that can have "nstate" elements or columns
    #  The n.event variable can have fewer
    temp <- c("n.risk", "n.event", "n.censor", "pstate",
              "cumhaz", "std.err", "lower", "upper", "std.chaz")
    sfun <- function(z) {
        if (is.null(j)) {
            if (is.array(z)) {
                if (length(dim(z)) > 2) z[,,i2, drop=drop]  
                else z[i2,,drop=drop]
            }
            else z[i2]
        }
        else {
            if (is.array(z)) {
                if (length(dim(z)) > 2) z[j,j,i2, drop=drop]  
                else z[i2,j, drop=drop]
            }
            else z[i2]
        }
    }
    for (k in temp) x[[k]] <- sfun(x[[k]])
    if (!is.null(j)) x$states <- x$states[j]
    x$n <- x$n[i]
    x$time <- x$time[i2]
    x$transitions <- NULL  # this is incorrect after subscripting

    if (is.matrix(x$p0)) {
        if (is.null(j)) {
            x$p0<- x$p0[i,]
            if (!is.null(x$sp0)) x$sp0 <- x$sp0[i,]
        }
        else {
            x$p0 <- x$p0[i,j]  
            if (!is.null(x$sp0)) x$sp0 <- x$sp0[i,j]
        }
   }
    else if (!is.null(j)) {
        x$p0 <- x$p0[j]
        if (!is.null(x$sp0)) x$sp0 <- x$sp0[j]
    }
    if (!is.null(x$influence)) {
        if (length(i) >1) x$influence <- x$influence[i]
        else if (is.list(x$influence)) x$influence <- x$influence[[i]]
    
        if (!is.null(j)) {
            if (is.list(x$influence)) 
                x$influence <- lapply(x$influence, function(x) x[,j,])
            else x$influence <- x$influence[,j,]
        }
    }
    x
}
@ 

The summary.survfit and summary.survfitms functions share a significant
amount of code.  
One part of the code that once was subtle is dealing with
intermediate time points; the findInterval function in base R has
made that much easier.
Since the result does not involve interpolation, one should be able
to create a special index vector i and return \code{time[i]},
\code{surv[i,]}, etc, to subscript all the curves in a survfit object
at once.  But that approach, though efficient in theory, runs into
two problems.  First is the extrapolated value for the curves at
time points before the first event, which is allowed to be different
for different curves in survfitms objects. 
The second is that there is interpolation of a sort: the n.event and n.censor
components are summed over intervals when the selected time points are
sparse, and that process is very tricky for multiple curves at once.
At one point the code took that approach, but it became too complex to maintain.
The current approach is slower but more transparent: do the individual
curves one by one, then paste together the results.

<<survfitms-summary>>=
summary.survfit <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean=getOption('survfit.rmean'),
                            ...) {
    fit <- object  #make a local copy
    if (!inherits(fit, 'survfit'))
	    stop("summary.survfit can only be used for survfit objects")
    if (is.null(fit$logse)) fit$logse <- TRUE   #older style

    # The print.rmean option is depreciated, it is still listened
    #   to in print.survfit, but ignored here
    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(object$start.time)) {
            if (rmean < min(object$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < object$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean(fit, scale=scale, rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time
    
    fit$time <- fit$time/scale
    if (!is.null(fit$strata)) {
        nstrat <-  length(fit$strata)
    }    
    delta <- function(x, indx) {  # sums between chosen times
        if (is.logical(indx)) indx <- which(indx)
        if (!is.null(x) && length(indx) >0) {
            fx <- function(x, indx) diff(c(0, c(0, cumsum(x))[indx+1]))
            if (is.matrix(x)) {
                temp <- apply(x, 2, fx, indx=indx)
                # don't return a vector when only 1 time point is given
                if (is.matrix(temp)) temp else matrix(temp, nrow=1)
            }
            else fx(x, indx)
        }
        else NULL
    }

    if (missing(times)) {
        <<survfitms-simple>>
    }
    else {
        <<survfitms-times>>
        times <- sort(times)  #in case the user forgot
        if (is.null(fit$strata)) fit <- findrow(fit, times, extend)
        else {
            ltemp <- vector("list", nstrat)
            for (i in 1:nstrat) 
                ltemp[[i]] <- findrow(fit[i], times, extend)
            fit <- unpacksurv(fit, ltemp)
        }
    }

    # finish off the output structure
    fit$table <- table
    if (length(rmean.endtime)>0  && !any(is.na(rmean.endtime[1]))) 
            fit$rmean.endtime <- rmean.endtime

    # A survfit object may contain std(log S) or std(S), summary always std(S)
    if (!is.null(fit$std.err) && fit$logse) fit$std.err <- fit$std.err * fit$surv 
 
    # Expand the strata
    if (!is.null(fit$strata)) 
        fit$strata <- factor(rep(1:nstrat, fit$strata), 1:nstrat,
                             labels= names(fit$strata))
    class(fit) <- "summary.survfit"
    fit
}
@ 

The simple case of no times argument.
<<survfitms-simple>>=
if (!censored) {
    index <- (rowSums(as.matrix(fit$n.event)) >0)
    for (i in c("time","n.risk", "n.event", "surv", "pstate", "std.err", 
                        "upper", "lower", "cumhaz", "std.chaz")) {
        if (!is.null(fit[[i]])) {  # not all components in all objects
            temp <- fit[[i]]
            if (!is.array(temp)) temp <- temp[index]  #simple vector
            else if (is.matrix(temp)) temp <- temp[index,,drop=FALSE]
            else temp <- temp[,,index, drop=FALSE] # 3 way
            fit[[i]] <- temp
        }
    }
    # The n.enter and n.censor values are accumualated
    #  both of these are simple vectors
    if (is.null(fit$strata)) {
        for (i in c("n.enter", "n.censor"))
            if (!is.null(fit[[i]]))
                fit[[i]] <- delta(fit[[i]], index)
    }
    else {
        sindx <- rep(1:nstrat, fit$strata)
        for (i in c("n.enter", "n.censor")) {
            if (!is.null(fit[[i]]))
                fit[[i]] <- unlist(sapply(1:nstrat, function(j) 
                             delta(fit[[i]][sindx==j], index[sindx==j])))
        }
        # the "factor" is needed for the case that a strata has no
        #  events at all, and hence 0 lines of output
        fit$strata[] <- as.vector(table(factor(sindx[index], 1:nstrat))) 
    }
}
#if missing(times) and censored=TRUE, the fit object is ok as it is
@ 

To deal with selected times we first define a subscripting function.
For indices of 0, which are requested times that are before the first event,
it fills in an initial value. 

<<survfitms-times>>=
ssub <- function(x, indx, init=0) {  #select an object and index
    if (!is.null(x) && length(indx)>0) {
        # the as.vector() is a way to keep R from adding "init" as a row name
        if (is.matrix(x)) rbind(as.vector(init), x)[indx+1,,drop=FALSE]
        else c(init, x)[indx+1]
    }
    else NULL
}
@ 

This function does the real work, for any single curve.
The default value for init is correct for survival curves.

Say that the data has values at time 5, 10, 15, 20 \ldots, and a user asks
for \code{times=c(7, 15, 20, 30)}.  
In the input object \code{n.risk} refers to the number at risk just before
time 5, 10, \ldots; it is a left-continuous function.  
The survival is a right-continuous function.  So at time 7 we want to 
take the survival from time 5 and number at risk from time 10;
\code{indx1} will be the right-continuous index and \code{indx2} the
left continuous one. The value of n.risk at time 30 has to be computed.
For counts of events, censoring, and entry we want to know the total
number that happened during the intervals of 0-7, 7-15, 15-20 and 20-30.
Technically censorings at time 15 happen just after time 15 so would
go into the third line of the report.
However, this would lead to terrible confusion for the user since
using \code{times=c(5, 10, 15, 20)} would lead to different counts than
a call that did not contain the times argument, so all 3 of the intermediates
are computed using indx1.
A report at time 30 is made only if extend=TRUE, in which case we need
to compute a tail value for n.risk.
<<survfitms-times>>=
findrow <- function(fit, times, extend, init=1) {
    # First, toss any printing times that are outside our range
    if (is.null(fit$start.time)) mintime <- min(fit$time, 0)
    else                         mintime <- fit$start.time
    ptimes <- times[times >= mintime]

    if (!extend) {
        maxtime <- max(fit$time)
        ptimes <- ptimes[ptimes <= maxtime]
    }
    ntime <- length(fit$time)
    
    index1 <- findInterval(ptimes, fit$time) 
    index2 <- 1 + findInterval(ptimes, fit$time, left.open=TRUE)
    # The pmax() above encodes the assumption that n.risk for any
    #  times before the first observation = n.risk at the first obs
    fit$time <- ptimes
    for (i in c("surv", "pstate", "upper", "lower")) {
        if (!is.null(fit[[i]])) fit[[i]] <- ssub(fit[[i]], index1, init)
    }
    for (i in c("std.err", "cumhaz")) {
        if (!is.null(fit[[i]])) fit[[i]] <- ssub(fit[[i]], index1, 0)
    }
    
    if (is.matrix(fit$n.risk)) {
        # Every observation in the data has to end with a censor or event.
        #  So by definition the number at risk after the last observed time
        #  value must be 0.
        fit$n.risk <- rbind(fit$n.risk,0)[index2,,drop=FALSE]
    }
    else  fit$n.risk <- c(fit$n.risk, 0)[index2]

    for (i in c("n.event", "n.censor", "n.enter"))
        fit[[i]] <- delta(fit[[i]], index1)
    fit
}

# For a single component, turn it from a list into a single vector, matrix
#  or array
unlistsurv <- function(x, name) {
    temp <- lapply(x, function(x) x[[name]])
    if (is.vector(temp[[1]])) unlist(temp)
    else if (is.matrix(temp[[1]])) do.call("rbind", temp)
    else { 
        # the cumulative hazard is the only component that is an array
        # it's third dimension is n
        xx <- unlist(temp)
        dd <- dim(temp[[1]])
        dd[3] <- length(xx)/prod(dd[1:2])
        array(xx, dim=dd)
    }
}

# unlist all the components built by a set of calls to findrow
#  and remake the strata
unpacksurv <- function(fit, ltemp) {
    keep <- c("time", "surv", "pstate", "upper", "lower", "std.err",
              "cumhaz", "n.risk", "n.event", "n.censor", "n.enter",
              "std.chaz")
    for (i in keep) 
        if (!is.null(fit[[i]])) fit[[i]] <- unlistsurv(ltemp, i)
    fit$strata[] <- sapply(ltemp, function(x) length(x$time))
    fit
}
@ 

Repeat the code for survfitms objects.  The only real difference is
the preservation of \code{pstate} and \code{cumhaz} instead of \code{surv},
use of survmean2, and use of p0 for initial states.

<<survfitms-summary>>=
summary.survfitms <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean= getOption("survfit.rmean"),
                            ...) {
    fit <- object
    if (!inherits(fit, 'survfitms'))
	    stop("summary.survfitms can only be used for survfitms objects")
    if (is.null(fit$logse)) fit$logse <- FALSE  # older style

    # The print.rmean option is depreciated, it is still listened
    #   to in print.survfit, but ignored here
    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(object$start.time)) {
            if (rmean < min(object$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < object$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean2(fit, scale=scale, rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time

    if (!missing(times)) {
        if (!is.numeric(times)) stop ("times must be numeric")
        times <- sort(times)
    }
    fit$time <- fit$time/scale
    if (!is.null(fit$strata)) {
        nstrat <-  length(fit$strata)
        sindx <- rep(1:nstrat, fit$strata)
    }    
    delta <- function(x, indx) {  # sums between chosen times
        if (is.logical(indx)) indx <- which(indx)
        if (!is.null(x) && length(indx) >0) {
            fx <- function(x, indx) diff(c(0, c(0, cumsum(x))[indx+1]))
            if (is.matrix(x)) {
                temp <- apply(x, 2, fx, indx=indx)
                if (is.matrix(temp)) temp else matrix(temp, nrow=1)
            }
            else fx(x, indx)
        }
        else NULL
    }

    if (missing(times)) {
        <<survfitms-simple>>
    }
    else {
        <<survfitms-times>>
        times <- sort(times)
        if (is.null(fit$strata)) fit <- findrow(fit, times, extend, fit$p0)
        else {
            ltemp <- vector("list", nstrat)
            for (i in 1:nstrat) 
                ltemp[[i]] <- findrow(fit[i], times, extend, fit$p0[i,])
            fit <- unpacksurv(fit, ltemp)
        }
    }

    # finish off the output structure
    fit$table <- table
    if (length(rmean.endtime)>0  && !any(is.na(rmean.endtime))) 
            fit$rmean.endtime <- rmean.endtime

    if (!is.null(fit$strata)) 
        fit$strata <- factor(rep(names(fit$strata), fit$strata))

    # A survfit object may contain std(log S) or std(S), summary always std(S)
    if (!is.null(fit$std.err) && fit$logse) fit$std.err <- fit$std.err * fit$surv 

    class(fit) <- "summary.survfitms"
    fit
}

<<printms>>
<<survmean2>>
@ 

Printing for a survfitms object is different than for a survfit one.
The big difference is that I don't have an estimate of the median, or
any other quantile for that matter.  Mean time in state makes sense, but
I don't have a standard error for it at the moment.
The other is that there is usually a mismatch between the n.event matrix
and the n.risk matrix.  
The latter has all the states that were possible whereas the former only
has states with an arrow pointing in.  We need to manufacture the 0 events
for the other states.

<<printms>>=
print.survfitms <- function(x, scale=1,
                            rmean = getOption("survfit.rmean"), ...) {
    if (!is.null(cl<- x$call)) {
	cat("Call: ")
	dput(cl)
	cat("\n")
        }	
    omit <- x$na.action
    if (length(omit)) cat("  ", naprint(omit), "\n")

    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(x$start.time)) {
            if (rmean < min(x$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < x$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean2(x, scale=scale, rmean)
    if (is.null(temp$end.time)) print(temp$matrix, ...)
    else {
        etime <- temp$end.time
        dd <- dimnames(temp$matrix)
        cname <- dd[[2]]
        cname[length(cname)] <- paste0(cname[length(cname)], '*')
        dd[[2]] <- cname
        dimnames(temp$matrix) <- dd
        print(temp$matrix, ...)
        if (length(etime) ==1)
             cat("   *mean time in state, restricted (max time =", 
                 format(etime, ...), ")\n")
        else cat("   *mean time in state, restricted (per curve cutoff)\n")
    }
    invisible(x)
}
@ 

This part of the computation is set out separately since it is called
by both print and summary.
<<survmean2>>=
survmean2 <- function(x, scale, rmean) {
    nstate <- length(x$states)  #there will always be at least 1 state
    ngrp   <- max(1, length(x$strata))
    if (ngrp >1)  {
        igrp <- rep(1:ngrp, x$strata)
        rname <- names(x$strata)
        }
    else {
        igrp <- rep(1, length(x$time))
        rname <- NULL
        }

    # The n.event matrix may not have nstate columms.  Its
    #  colnames are the first elements of states, however
    if (is.matrix(x$n.event)) {
        nc <- ncol(x$n.event)
        nevent <- tapply(x$n.event, list(rep(igrp, nc), col(x$n.event)), sum)
        dimnames(nevent) <- list(rname, x$states[1:nc])
        }
    else {
        nevent <- tapply(x$n.event, igrp, sum)
        names(nevent) <- rname
        }

    outmat <- matrix(0., nrow=nstate*ngrp , ncol=2)
    outmat[,1] <- rep(x$n, nstate)
    outmat[1:length(nevent), 2] <- c(nevent)
  
    if (ngrp >1) 
        rowname <- c(outer(rname, x$states, paste, sep=", "))
    else rowname <- x$states

    # Caculate the mean time in each state
    if (rmean != "none") {
        if (is.numeric(rmean)) maxtime <- rep(rmean, ngrp)
        else if (rmean=="common") maxtime <- rep(max(x$time), ngrp)
        else maxtime <- tapply(x$time, igrp, max)
    
        meantime <- matrix(0., ngrp, nstate)
        p0 <- matrix(x$p0, nrow=ngrp)  #in case there is only one row
        if (!is.null(x$influence)) stdtime <- meantime
        for (i in 1:ngrp) {
            if (is.matrix(x$pstate))
                temp <- rbind(p0[i,], x$pstate[igrp==i,, drop=FALSE])
            else temp <- matrix(c(p0[i], x$pstate[igrp==i]), ncol=1)

            if (is.null(x$start.time)) tt <- c(0, x$time[igrp==i])
            else tt <- c(x$start.time, x$time[igrp==i])

            # Now cut it off at maxtime
            delta <- diff(c(tt[tt<maxtime[i]], maxtime[i]))
            if (length(delta) > nrow(temp)) delta <- delta[1:nrow(temp)]
            if (length(delta) < nrow(temp))
                delta <- c(delta, rep(0, nrow(temp) - length(delta)))
            meantime[i,] <- colSums(delta*temp)

            if (!is.null(x$influence)) {
                # calculate the variance
                if (is.list(x$influence))
                    itemp <- apply(x$influence[[i]], 1,
                                   function(x) colSums(x*delta))
                else itemp <- apply(x$influence, 1,
                                    function(x) colSums(x*delta))
                stdtime[i,] <- sqrt(rowSums(itemp^2))
           }
        }
        outmat <- cbind(outmat, c(meantime)/scale)
        cname <- c("n", "nevent", "rmean")
        if (!is.null(x$influence)) {
            outmat <- cbind(outmat, c(stdtime)/scale)
            cname <- c(cname, "std(rmean)")
        }
        # report back a single time, if there is only one
        if (all(maxtime == maxtime[1])) maxtime <- maxtime[1]
    }
    else cname <- c("n", "nevent")
    dimnames(outmat) <- list(rowname, cname)

    if (rmean=='none') list(matrix=outmat)
    else list(matrix=outmat, end.time=maxtime/scale)
}
@ 

The influence array has subject for the first element, the other two
mimic the is of the same shape as the \code{pstate}, but with
one copy per subject.  For the variance we do exactly the same
calculation as the mean, once per subject, and add up the squares of
the result.  
As with \code{pstate} and \code{p0} a major nuisance for all this is
the fact that the results at time 0 are in a separate object.
This is a consequence of how survfit objects were set up 20+ years ago,
namely that the starting point (time=0, surv=1) was not stored in the object.
With (start, stop] data we want to save a starting time = min of the 
start values, and with multi-state the starting estimate is a vector.
It would be so much easier if I had kept it the other way -- but with 400
dependent packages change is very hard.  
<<msvar>>=
@ 
