# The anova function for a coxph object
anova.coxph <- function (object, ...,  test = 'Chisq') {
    if (!inherits(object, "coxph"))
        stop ("argument must be a cox model")

    # All the ... args need to be coxph or coxme fits.  If any of them
    #  have a name attached, e.g., 'charlie=T' we assume a priori
    #  that they are illegal
    #
    dotargs <- list(...)
    named <- if (is.null(names(dotargs))) 
	           rep(FALSE, length(dotargs))
             else (names(dotargs) != "")
    if (any(named)) 
        warning(paste("The following arguments to anova.coxph(..)", 
            "are invalid and dropped:", paste(deparse(dotargs[named]), 
                collapse = ", ")))
    dotargs <- dotargs[!named]

    if (length(dotargs) >0) {
        # Check that they are all cox or coxme models
        is.coxmodel <-unlist(lapply(dotargs, function(x) inherits(x, "coxph")))
        is.coxme <- unlist(lapply(dotargs, function(x) inherits(x, "coxme")))
        if (!all(is.coxmodel | is.coxme))
            stop("All arguments must be Cox models")
        
        if (any(is.coxme)) {
            # We need the anova.coxmelist function from coxme
            # If coxme is not loaded the line below returns NULL
            temp <- getS3method("anova", "coxmelist", optional=TRUE)
            if (is.null(temp)) 
                stop("a coxme model was found and library coxme is not loaded")
            else return(temp(c(list(object), dotargs), test = test))
        }
        else return(anova.coxphlist(c(list(object), dotargs), test = test))
    }

    #
    # The argument is a single Cox model 
    # Show the nested list of models generated by this model.
    # Missings are the real nuisance here, we want all the models to be
    #  evaluated on the same subset of observations.  Use the result of
    #  model.frame, called on the largest model, for all fits.
    if (length(object$rscore)>0)
        stop("Can't do anova tables with robust variances")
    newdata <- model.frame(object)
 
    # Get the list of things to drop, one by one
    #  An offset variable will not appear, which is ok since we don't want
    #  to drop them.
    termlist<-attr(object$terms,"term.labels") #variables in the formula
    specials <- attr(object$terms, "specials")
    if (!is.null(specials$strata)) {
        # The strata term is not dropped
        termlist <- termlist[-(specials$strata -1)]
        }
    
    # Create variables to hold the output
    nmodel <- length(termlist)
    df <- integer(nmodel+1)  #this will hold the df vector
    loglik <- double(nmodel+1) #and the loglike vector
    df[nmodel+1] <- if (is.null(object$df)) sum(!is.na(object$coefficients))
                    else sum(object$df)
    loglik[nmodel+1] <- object$loglik[2]
    df[1] <- 0
    loglik[1] <- object$loglik[1]

    # Now for some slight of hand.  The update function fails if any of
    #  the variables are complex, like "Surv(time, stat)" or "log(age)".
    # The reason is that the model.frame "newdata" has these as the
    #  variable names, update uses formulas, formulas don't like quotes
    #  in them, and we need quotes to parse odd names like this.  The
    #  cannonical way to do this is to get the model matrix, extract the
    #  "assign" attribute from it, and then call the internal fit routine,
    #   e.g., anova.glm calls glm.fit.  Coxph does not save the information
    #   on which was internal was run, however (coxph.fit, coxpenal.fit, etc.)
    #   and besides that wouldn't work for penalized terms.
    #  So, rename all the variables to "zed1", "zed2", etc, then change
    #   the formula and the termlist.  Response is always first in
    #   the data frame.
    nvar <- ncol(newdata)  #number of terms
    fname <- names(newdata)
    zname <- paste("zed", 1:nvar, sep="")
    termlist2 <- zname[match(termlist, fname)]
    fit <- object

    #build a new formula. Someone can have multiple offset(), strata(), or tt()
    #  terms, hence the call to collapse.
    temp <- paste("zed1 ~", paste(termlist2, collapse= " + "))
    offset <- attr(object$terms, "offset")
    if (length(offset)) temp <- paste(c(temp, 
                                       paste("offset(", zname[offset], ")")),
                                   collapse=" +")
    specials <- attr(terms(fit), "specials")
    if (!is.null(specials$tt))
        temp <- paste(c(temp, paste("tt(", zname[specials$tt], ")")),
                      collapse = " + ")
    if (!is.null(specials$strata))
        temp <- paste(c(temp, paste("strata(", zname[specials$strata], ")")),
                      collapse = " + ")

    fit$formula <- formula(temp)
    fit$call$formula <- fit$formula
    fit$call$data <- as.name("newdata")
    names(newdata) <- zname

    if (nmodel > 1) for (i in nmodel:2) {
        fit <- update(fit, formula(paste(".~. -", termlist2[i])), data=newdata)
        df[i] <- if (is.null(fit$df)) sum(!is.na(coef(fit)))
                 else sum(fit$df)
        loglik[i] <- fit$loglik[2]
        }

    table <- data.frame(loglik=loglik, Chisq=c(NA, 2*diff(loglik)), 
                        Df=c(NA, diff(df))) 

    if (nmodel == 0) #failsafe for a NULL model
             table <- table[1, , drop = FALSE]

    if (length(test) >0 && test[1]=='Chisq') {
        table[['Pr(>|Chi|)']] <- 1- pchisq(table$Chisq, table$Df)
        }
    row.names(table) <- c('NULL', termlist)

    title <- paste("Analysis of Deviance Table\n Cox model: response is ",
		   deparse(object$terms[[2]]),
		   "\nTerms added sequentially (first to last)\n", 
		   sep = "")
    structure(table, heading = title, class = c("anova", "data.frame"))
}
